<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wstのBlog</title>
  
  <subtitle>座右铭</subtitle>
  <link href="http://wstcly.xyz/atom.xml" rel="self"/>
  
  <link href="http://wstcly.xyz/"/>
  <updated>2024-07-01T13:18:07.982Z</updated>
  <id>http://wstcly.xyz/</id>
  
  <author>
    <name>Heuwst</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>72.深入浅出pandas-1</title>
    <link href="http://wstcly.xyz/2024/07/01/72.shen-ru-qian-chu-pandas-1/"/>
    <id>http://wstcly.xyz/2024/07/01/72.shen-ru-qian-chu-pandas-1/</id>
    <published>2024-07-01T13:14:24.000Z</published>
    <updated>2024-07-01T13:18:07.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入浅出pandas-1"><a href="#深入浅出pandas-1" class="headerlink" title="深入浅出pandas-1"></a>深入浅出pandas-1</h2><p>Pandas 是 Wes McKinney 在2008年开发的一个强大的<strong>分析结构化数据</strong>的工具集。Pandas 以 NumPy 为基础（实现数据存储和运算），提供了专门用于数据分析的类型、方法和函数，对数据分析和数据挖掘提供了很好的支持；同时 pandas 还可以跟数据可视化工具 matplotlib 很好的整合在一起，非常轻松愉快的实现数据可视化呈现。</p><p>Pandas 核心的数据类型是<code>Series</code>（数据系列）、<code>DataFrame</code>（数据窗&#x2F;数据框），分别用于处理一维和二维的数据，除此之外，还有一个名为<code>Index</code>的类型及其子类型，它们为<code>Series</code>和<code>DataFrame</code>提供了索引功能。日常工作中<code>DataFrame</code>使用得最为广泛，因为二维的数据结构刚好可以对应有行有列的表格。<code>Series</code>和<code>DataFrame</code>都提供了大量的处理数据的方法，数据分析师以此为基础，可以实现对数据的筛选、合并、拼接、清洗、预处理、聚合、透视和可视化等各种操作。</p><h3 id="创建Series对象"><a href="#创建Series对象" class="headerlink" title="创建Series对象"></a>创建Series对象</h3><p>Pandas 库中的<code>Series</code>对象可以用来表示一维数据结构，但是多了索引和一些额外的功能。<code>Series</code>类型的内部结构包含了两个数组，其中一个用来保存数据，另一个用来保存数据的索引。我们可以通过列表或数组创建<code>Series</code>对象，代码如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">import numpy as npimport pandas as pdser1 &#x3D; pd.Series(data&#x3D;[120, 380, 250, 360], index&#x3D;[&#39;一季度&#39;, &#39;二季度&#39;, &#39;三季度&#39;, &#39;四季度&#39;])ser1</code></pre><blockquote><p><strong>说明</strong>：<code>Series</code>构造器中的<code>data</code>参数表示数据，<code>index</code>参数表示数据的索引，相当于数据对应的标签。</p></blockquote><p>输出：</p><pre class="language-none"><code class="language-none">一季度    120二季度    380三季度    250四季度    360dtype: int64</code></pre><p>通过字典创建Series对象。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser2 &#x3D; pd.Series(&#123;&#39;一季度&#39;: 320, &#39;二季度&#39;: 180, &#39;三季度&#39;: 300, &#39;四季度&#39;: 405&#125;)ser2</code></pre><blockquote><p><strong>说明</strong>：通过字典创建<code>Series</code>对象时，字典的键就是数据的标签（索引），键对应的值就是数据。</p></blockquote><p>输出：</p><pre class="language-none"><code class="language-none">一季度    320二季度    180三季度    300四季度    405dtype: int64</code></pre><h3 id="Series对象的运算"><a href="#Series对象的运算" class="headerlink" title="Series对象的运算"></a>Series对象的运算</h3><h4 id="标量运算"><a href="#标量运算" class="headerlink" title="标量运算"></a>标量运算</h4><p>我们尝试给刚才的<code>ser1</code>每个季度加上<code>10</code>，代码如下所示。</p><p>代码：</p><pre class="language-python" data-language="python"><code class="language-python">ser1 <span class="token operator">+=</span> <span class="token number">10</span>ser1</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">一季度    130二季度    390三季度    260四季度    370dtype: int64</code></pre><h4 id="矢量运算"><a href="#矢量运算" class="headerlink" title="矢量运算"></a>矢量运算</h4><p>我们尝试把<code>ser1</code>和<code>ser2</code>对应季度的数据加起来，代码如下所示。</p><p>代码：</p><pre class="language-python" data-language="python"><code class="language-python">ser1 <span class="token operator">+</span> ser2</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">一季度    450二季度    570三季度    560四季度    775dtype: int64</code></pre><h4 id="索引运算"><a href="#索引运算" class="headerlink" title="索引运算"></a>索引运算</h4><h5 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h5><p>跟数组一样，<code>Series</code>对象也可以进行索引和切片操作，不同的是<code>Series</code>对象因为内部维护了一个保存索引的数组，所以除了可以使用整数索引检索数据外，还可以通过自己设置的索引（标签）获取对应的数据。</p><p>使用整数索引。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser1[2]</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">260</code></pre><p>使用自定义索引。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser1[&#39;三季度&#39;]</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">260</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser1[&#39;一季度&#39;] &#x3D; 380ser1</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">一季度    380二季度    390三季度    260四季度    370dtype: int64</code></pre><h5 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h5><p><code>Series</code>对象的切片操作跟列表、数组类似，通过给出起始和结束索引，从原来的<code>Series</code>对象中取出或修改部分数据，这里也可以使用整数索引和自定义的索引，代码如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser2[1:3]</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">二季度    180三季度    300dtype: int64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser2[&#39;二季度&#39;:&#39;四季度&#39;]</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">二季度    180三季度    300四季度    405dtype: int64</code></pre><blockquote><p><strong>提示</strong>：在使用自定义索引进行切片时，结束索引对应的元素也是可以取到的。</p></blockquote><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser2[1:3] &#x3D; 400, 500ser2</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">一季度    320二季度    400三季度    500四季度    405dtype: int64</code></pre><h5 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h5><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser2[[&#39;二季度&#39;, &#39;四季度&#39;]]</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">二季度    400四季度    405dtype: int64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser2[[&#39;二季度&#39;, &#39;四季度&#39;]] &#x3D; 600, 520ser2</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">一季度    320二季度    600三季度    500四季度    520dtype: int64</code></pre><h5 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h5><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser2[ser2 &gt;&#x3D; 500]</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">二季度    600三季度    500四季度    520dtype: int64</code></pre><h3 id="Series对象的属性和方法"><a href="#Series对象的属性和方法" class="headerlink" title="Series对象的属性和方法"></a>Series对象的属性和方法</h3><p><code>Series</code>对象的属性和方法非常多，我们就捡着重要的跟大家讲吧。先看看下面的表格，它展示了<code>Series</code>对象常用的属性。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>dtype</code> &#x2F; <code>dtypes</code></td><td>返回<code>Series</code>对象的数据类型</td></tr><tr><td><code>hasnans</code></td><td>判断<code>Series</code>对象中有没有空值</td></tr><tr><td><code>at</code> &#x2F; <code>iat</code></td><td>通过索引访问<code>Series</code>对象中的单个值</td></tr><tr><td><code>loc</code> &#x2F; <code>iloc</code></td><td>通过索引访问<code>Series</code>对象中的单个值或一组值</td></tr><tr><td><code>index</code></td><td>返回<code>Series</code>对象的索引（<code>Index</code>对象）</td></tr><tr><td><code>is_monotonic</code></td><td>判断<code>Series</code>对象中的数据是否单调</td></tr><tr><td><code>is_monotonic_increasing</code></td><td>判断<code>Series</code>对象中的数据是否单调递增</td></tr><tr><td><code>is_monotonic_decreasing</code></td><td>判断<code>Series</code>对象中的数据是否单调递减</td></tr><tr><td><code>is_unique</code></td><td>判断<code>Series</code>对象中的数据是否独一无二</td></tr><tr><td><code>size</code></td><td>返回<code>Series</code>对象中元素的个数</td></tr><tr><td><code>values</code></td><td>以<code>ndarray</code>的方式返回<code>Series</code>对象中的值（<code>ndarray</code>对象）</td></tr></tbody></table><p>我们可以通过下面的代码来了解<code>Series</code>对象的属性。</p><p>代码：</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>ser2<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span>                    <span class="token comment"># 数据类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>ser2<span class="token punctuation">.</span>hasnans<span class="token punctuation">)</span>                  <span class="token comment"># 有没有空值</span><span class="token keyword">print</span><span class="token punctuation">(</span>ser2<span class="token punctuation">.</span>index<span class="token punctuation">)</span>                    <span class="token comment"># 索引</span><span class="token keyword">print</span><span class="token punctuation">(</span>ser2<span class="token punctuation">.</span>values<span class="token punctuation">)</span>                   <span class="token comment"># 值</span><span class="token keyword">print</span><span class="token punctuation">(</span>ser2<span class="token punctuation">.</span>is_monotonic_increasing<span class="token punctuation">)</span>  <span class="token comment"># 是否单调递增</span><span class="token keyword">print</span><span class="token punctuation">(</span>ser2<span class="token punctuation">.</span>is_unique<span class="token punctuation">)</span>                <span class="token comment"># 是否每个值都独一无二</span></code></pre><p>输出：</p><pre class="language-none"><code class="language-none">int64FalseIndex([&#39;一季度&#39;, &#39;二季度&#39;, &#39;三季度&#39;, &#39;四季度&#39;], dtype&#x3D;&#39;object&#39;)[320 600 500 520]FalseTrue</code></pre><p><code>Series</code>对象的方法很多，下面我们通过一些代码片段为大家介绍常用的方法。</p><h4 id="统计相关"><a href="#统计相关" class="headerlink" title="统计相关"></a>统计相关</h4><p><code>Series</code>对象支持各种获取描述性统计信息的方法。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">print(ser2.count())   # 计数print(ser2.sum())     # 求和print(ser2.mean())    # 求平均print(ser2.median())  # 找中位数print(ser2.max())     # 找最大print(ser2.min())     # 找最小print(ser2.std())     # 求标准差print(ser2.var())     # 求方差</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">41940485.0510.0600320118.1806526749055713966.666666666666</code></pre><p><code>Series</code>对象还有一个名为<code>describe()</code>的方法，可以获得上述所有的描述性统计信息，如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser2.describe()</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">count      4.000000mean     485.000000std      118.180653min      320.00000025%      455.00000050%      510.00000075%      540.000000max      600.000000dtype: float64</code></pre><blockquote><p><strong>提示</strong>：因为<code>describe()</code>返回的也是一个<code>Series</code>对象，所以也可以用<code>ser2.describe()[&#39;mean&#39;]</code>来获取平均值，用<code>ser2.describe()[[&#39;max&#39;, &#39;min&#39;]]</code>来获取最大值和最小值。</p></blockquote><p>如果<code>Series</code>对象有重复的值，我们可以使用<code>unique()</code>方法获得由独一无二的值构成的数组；可以使用<code>nunique()</code>方法统计不重复值的数量；如果想要统计每个值重复的次数，可以使用<code>value_counts()</code>方法，这个方法会返回一个<code>Series</code>对象，它的索引就是原来的<code>Series</code>对象中的值，而每个值出现的次数就是返回的<code>Series</code>对象中的数据，在默认情况下会按照出现次数做降序排列，如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser3 &#x3D; pd.Series(data&#x3D;[&#39;apple&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;pitaya&#39;, &#39;apple&#39;, &#39;pitaya&#39;, &#39;durian&#39;])ser3.value_counts()</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">apple     3pitaya    2durian    1banana    1dtype: int64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser3.nunique()</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">4</code></pre><p>对于<code>ser3</code>，我们还可以用<code>mode()</code>方法来找出数据的众数，由于众数可能不唯一，所以<code>mode()</code>方法的返回值仍然是一个<code>Series</code>对象。</p><p>代码：</p><pre class="language-python" data-language="python"><code class="language-python">ser3<span class="token punctuation">.</span>mode<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0    appledtype: object</code></pre><h4 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h4><p><code>Series</code>对象的<code>isna()</code>和<code>isnull()</code>方法可以用于空值的判断，<code>notna()</code>和<code>notnull()</code>方法可以用于非空值的判断，代码如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser4 &#x3D; pd.Series(data&#x3D;[10, 20, np.nan, 30, np.nan])ser4.isna()</code></pre><blockquote><p><strong>说明</strong>：<code>np.nan</code>是一个IEEE 754标准的浮点小数，专门用来表示“不是一个数”，在上面的代码中我们用它来代表空值；当然，也可以用 Python 中的<code>None</code>来表示空值，在 pandas 中<code>None</code>也会被处理为<code>np.nan</code>。</p></blockquote><p>输出：</p><pre class="language-none"><code class="language-none">0    False1    False2     True3    False4     Truedtype: bool</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser4.notna()</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0     True1     True2    False3     True4    Falsedtype: bool</code></pre><p><code>Series</code>对象的<code>dropna()</code>和<code>fillna()</code>方法分别用来删除空值和填充空值，具体的用法如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser4.dropna()</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0    10.01    20.03    30.0dtype: float64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser4.fillna(value&#x3D;40)  # 将空值填充为40</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0    10.01    20.02    40.03    30.04    40.0dtype: float64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser4.fillna(method&#x3D;&#39;ffill&#39;)  # 用空值前面的非空值填充</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0    10.01    20.02    20.03    30.04    30.0dtype: float64</code></pre><p>需要提醒大家注意的是，<code>dropna()</code>和<code>fillna()</code>方法都有一个名为<code>inplace</code>的参数，它的默认值是<code>False</code>，表示删除空值或填充空值不会修改原来的<code>Series</code>对象，而是返回一个新的<code>Series</code>对象。如果将<code>inplace</code>参数的值修改为<code>True</code>，那么删除或填充空值会就地操作，直接修改原来的<code>Series</code>对象，此时方法的返回值是<code>None</code>。后面我们会接触到的很多方法，包括<code>DataFrame</code>对象的很多方法都会有这个参数，它们的意义跟这里是一样的。</p><p><code>Series</code>对象的<code>mask()</code>和<code>where()</code>方法可以将满足或不满足条件的值进行替换，如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser5 &#x3D; pd.Series(range(5))ser5.where(ser5 &gt; 0)</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0    NaN1    1.02    2.03    3.04    4.0dtype: float64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser5.where(ser5 &gt; 1, 10)</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0    101    102     23     34     4dtype: int64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser5.mask(ser5 &gt; 1, 10)</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0     01     12    103    104    10dtype: int64</code></pre><p><code>Series</code>对象的<code>duplicated()</code>方法可以帮助我们找出重复的数据，而<code>drop_duplicates()</code>方法可以帮我们删除重复数据。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser3.duplicated()</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0    False1    False2     True3    False4     True5     True6    Falsedtype: bool</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser3.drop_duplicates()</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0     apple1    banana3    pitaya6    duriandtype: object</code></pre><p><code>Series</code>对象的<code>apply()</code>和<code>map()</code>方法非常重要，它们可以通过字典或者指定的函数来处理数据，把数据映射或转换成我们想要的样子。这两个方法在数据准备阶段非常重要，我们先来试一试这个名为<code>map</code>的方法。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser6 &#x3D; pd.Series([&#39;cat&#39;, &#39;dog&#39;, np.nan, &#39;rabbit&#39;])ser6</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">0       cat1       dog2       NaN3    rabbitdtype: object</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser6.map(&#123;&#39;cat&#39;: &#39;kitten&#39;, &#39;dog&#39;: &#39;puppy&#39;&#125;)</code></pre><blockquote><p><strong>说明</strong>：通过字典给出的映射规则对数据进行处理。</p></blockquote><p>输出：</p><pre class="language-none"><code class="language-none">0    kitten1     puppy2       NaN3       NaNdtype: object</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser6.map(&#39;I am a &#123;&#125;&#39;.format, na_action&#x3D;&#39;ignore&#39;)</code></pre><blockquote><p><strong>说明</strong>：将指定字符串的<code>format</code>方法作用到数据系列的数据上，忽略掉所有的空值。</p></blockquote><p>输出：</p><pre class="language-none"><code class="language-none">0       I am a cat1       I am a dog2              NaN3    I am a rabbitdtype: object</code></pre><p>我们创建一个新的<code>Series</code>对象，</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser7 &#x3D; pd.Series([20, 21, 12],  index&#x3D;[&#39;London&#39;, &#39;New York&#39;, &#39;Helsinki&#39;])ser7</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">London      20New York    21Helsinki    12dtype: int64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser7.apply(np.square)</code></pre><blockquote><p><strong>说明</strong>：将求平方的函数作用到数据系列的数据上，也可以将参数<code>np.square</code>替换为<code>lambda x: x ** 2</code>。</p></blockquote><p>输出：</p><pre class="language-none"><code class="language-none">London      400New York    441Helsinki    144dtype: int64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser7.apply(lambda x, value: x - value, args&#x3D;(5, ))</code></pre><blockquote><p>注意：上面<code>apply</code>方法中的<code>lambda</code>函数有两个参数，第一个参数是数据系列中的数据，而第二个参数需要我们传入，所以我们给<code>apply</code>方法增加了<code>args</code>参数，用于给<code>lambda</code>函数的第二个参数传值。</p></blockquote><p>输出：</p><pre class="language-none"><code class="language-none">London      15New York    16Helsinki     7dtype: int64</code></pre><h4 id="取头部值和排序"><a href="#取头部值和排序" class="headerlink" title="取头部值和排序"></a>取头部值和排序</h4><p><code>Series</code>对象的<code>sort_index()</code>和<code>sort_values()</code>方法可以用于对索引和数据的排序，排序方法有一个名为<code>ascending</code>的布尔类型参数，该参数用于控制排序的结果是升序还是降序；而名为<code>kind</code>的参数则用来控制排序使用的算法，默认使用了<code>quicksort</code>，也可以选择<code>mergesort</code>或<code>heapsort</code>；如果存在空值，那么可以用<code>na_position</code>参数空值放在最前还是最后，默认是<code>last</code>，代码如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser8 &#x3D; pd.Series(    data&#x3D;[35, 96, 12, 57, 25, 89],     index&#x3D;[&#39;grape&#39;, &#39;banana&#39;, &#39;pitaya&#39;, &#39;apple&#39;, &#39;peach&#39;, &#39;orange&#39;])ser8.sort_values()  # 按值从小到大排序</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">pitaya    12peach     25grape     35apple     57orange    89banana    96dtype: int64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser8.sort_index(ascending&#x3D;False)  # 按索引从大到小排序</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">pitaya    12peach     25orange    89grape     35banana    96apple     57dtype: int64</code></pre><p>如果要从<code>Series</code>对象中找出元素中最大或最小的“Top-N”，我们不需要对所有的值进行排序的，可以使用<code>nlargest()</code>和<code>nsmallest()</code>方法来完成，如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser8.nlargest(3)  # 值最大的3个</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">banana    96orange    89apple     57dtype: int64</code></pre><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">ser8.nsmallest(2)  # 值最小的2个</code></pre><p>输出：</p><pre class="language-none"><code class="language-none">pitaya    12peach     25dtype: int64</code></pre><h4 id="绘制图表"><a href="#绘制图表" class="headerlink" title="绘制图表"></a>绘制图表</h4><p><code>Series</code>对象有一个名为<code>plot</code>的方法可以用来生成图表，如果选择生成折线图、饼图、柱状图等，默认会使用<code>Series</code>对象的索引作为横坐标，使用<code>Series</code>对象的数据作为纵坐标。下面我们创建一个<code>Series</code>对象并基于它绘制柱状图，代码如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">import matplotlib.pyplot as pltser9 &#x3D; pd.Series(&#123;&#39;Q1&#39;: 400, &#39;Q2&#39;: 520, &#39;Q3&#39;: 180, &#39;Q4&#39;: 380&#125;)# 通过plot方法的kind指定图表类型为柱状图ser9.plot(kind&#x3D;&#39;bar&#39;)# 定制纵轴的取值范围plt.ylim(0, 600)# 定制横轴刻度（旋转到0度）plt.xticks(rotation&#x3D;0)# 为柱子增加数据标签for i in range(ser9.size):    plt.text(i, ser9[i] + 5, ser9[i], ha&#x3D;&#39;center&#39;)plt.show()</code></pre><p>输出：</p><img src="res/ser_bar_graph.png" style="zoom:35%;"><p>我们也可以将其绘制为饼图，代码如下所示。</p><p>代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python"># plot方法的kind参数指定了图表类型为饼图# autopct会自动计算并显示百分比# pctdistance用来控制百分比到圆心的距离ser9.plot(kind&#x3D;&#39;pie&#39;, autopct&#x3D;&#39;%.1f%%&#39;, pctdistance&#x3D;0.65)plt.show()</code></pre><p>输出：</p><img src="res/ser_pie_graph.png" style="zoom:35%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;深入浅出pandas-1&quot;&gt;&lt;a href=&quot;#深入浅出pandas-1&quot; class=&quot;headerlink&quot; title=&quot;深入浅出pandas-1&quot;&gt;&lt;/a&gt;深入浅出pandas-1&lt;/h2&gt;&lt;p&gt;Pandas 是 Wes McKinney 在2008年开发</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>01.初识Python</title>
    <link href="http://wstcly.xyz/2024/07/01/01.chu-shi-python/"/>
    <id>http://wstcly.xyz/2024/07/01/01.chu-shi-python/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:02.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识Python"><a href="#初识Python" class="headerlink" title="初识Python"></a>初识Python</h2><blockquote><p><strong>温馨提示</strong>：2018年创建这个仓库的时候，关于Python语言基础这个部分的内容写得相对是比较粗糙，对粗学者可能不是那么友好。如果你正好是一名初学者，建议你移步到我的另一个仓库<a href="https://github.com/jackfrued/Python-for-Freshmen-2023">Python-for-Freshmen-2023</a>，这个仓库对初学者更加友好，对应的内容，大家也可以在我的知乎专栏“从零开始学Python”中找到，点击进入<a href="https://www.zhihu.com/column/c_1216656665569013760">传送门</a>。</p></blockquote><h3 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h3><h4 id="Python的历史"><a href="#Python的历史" class="headerlink" title="Python的历史"></a>Python的历史</h4><ol><li>1989年圣诞节：Guido von Rossum开始写Python语言的编译器。</li><li>1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，还有对列表、字典等核心数据类型，同时支持以模块为基础来构造应用程序。</li><li>1994年1月：Python 1.0正式发布。</li><li>2000年10月16日：Python 2.0发布，增加了完整的<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">垃圾回收</a>，提供了对<a href="https://zh.wikipedia.org/wiki/Unicode">Unicode</a>的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。</li><li>2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6&#x2F;2.7版本中。</li></ol><p>目前我使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以阅读名为<a href="http://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html">《Python简史》</a>的网络文章。</p><h4 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h4><p>Python的优点很多，简单的可以总结为以下几点。</p><ol><li>简单明了，学习曲线低，比很多编程语言都容易上手。</li><li>开放源代码，拥有强大的社区和生态圈，尤其是在数据分析和机器学习领域。</li><li>解释型语言，天生具有平台可移植性，代码可以工作于不同的操作系统。</li><li>对两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。</li><li>代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。</li></ol><p>Python的缺点主要集中在以下几点。</p><ol><li>执行效率稍低，对执行效率要求高的部分可以由其他语言（如：C、C++）编写。</li><li>代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被弱化。</li><li>在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。</li></ol><h4 id="Python的应用领域"><a href="#Python的应用领域" class="headerlink" title="Python的应用领域"></a>Python的应用领域</h4><p>目前Python在Web应用后端开发、云基础设施建设、DevOps、网络数据采集（爬虫）、自动化测试、数据分析、机器学习等领域都有着广泛的应用。</p><h3 id="安装Python解释器"><a href="#安装Python解释器" class="headerlink" title="安装Python解释器"></a>安装Python解释器</h3><p>想要开始Python编程之旅，首先得在自己使用的计算机上安装Python解释器环境，下面将以安装官方的Python解释器为例，讲解如何在不同的操作系统上安装Python环境。官方的Python解释器是用C语言实现的，也是使用最为广泛的Python解释器，通常称之为CPython。除此之外，Python解释器还有Java语言实现的Jython、C#语言实现的IronPython以及PyPy、Brython、Pyston等版本，有兴趣的读者可以自行了解。</p><h4 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h4><p>可以在<a href="https://www.python.org/">Python官方网站</a>下载到Python的Windows安装程序（exe文件），需要注意的是如果在Windows 7环境下安装Python 3.x，需要先安装Service Pack 1补丁包（可以通过一些工具软件自动安装系统补丁的功能来安装），安装过程建议勾选“Add Python 3.x to PATH”（将Python 3.x添加到PATH环境变量）并选择自定义安装，在设置“Optional Features”界面最好将“pip”、“tcl&#x2F;tk”、“Python test suite”等项全部勾选上。强烈建议选择自定义的安装路径并保证路径中没有中文。安装完成会看到“Setup was successful”的提示。如果稍后运行Python程序时，出现因为缺失一些动态链接库文件而导致Python解释器无法工作的问题，可以按照下面的方法加以解决。</p><p>如果系统显示api-ms-win-crt*.dll文件缺失，可以参照<a href="https://zhuanlan.zhihu.com/p/32087135">《api-ms-win-crt*.dll缺失原因分析和解决方法》</a>一文讲解的方法进行处理或者直接在<a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=48145">微软官网</a>下载Visual C++ Redistributable for Visual Studio 2015文件进行修复；如果是因为更新Windows的DirectX之后导致某些动态链接库文件缺失问题，可以下载一个<a href="https://dl.pconline.com.cn/download/360074-1.html">DirectX修复工具</a>进行修复。</p><h4 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h4><p>Linux环境自带了Python 2.x版本，但是如果要更新到3.x的版本，可以在<a href="https://www.python.org/">Python的官方网站</a>下载Python的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示（以CentOS为例）。</p><ol><li>安装依赖库（因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败）。</li></ol><pre class="language-Shell" data-language="Shell"><code class="language-Shell">yum -y install wget gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel</code></pre><ol start="2"><li>下载Python源代码并解压缩到指定目录。</li></ol><pre class="language-Shell" data-language="Shell"><code class="language-Shell">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.7.6&#x2F;Python-3.7.6.tar.xzxz -d Python-3.7.6.tar.xztar -xvf Python-3.7.6.tar</code></pre><ol start="3"><li>切换至Python源代码目录并执行下面的命令进行配置和安装。</li></ol><pre class="language-Shell" data-language="Shell"><code class="language-Shell">cd Python-3.7.6.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python37 --enable-optimizationsmake &amp;&amp; make install</code></pre><ol start="4"><li>修改用户主目录下名为.bash_profile的文件，配置PATH环境变量并使其生效。</li></ol><pre class="language-Shell" data-language="Shell"><code class="language-Shell">cd ~vim .bash_profile</code></pre><pre class="language-Shell" data-language="Shell"><code class="language-Shell"># ... 此处省略上面的代码 ...export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;python37&#x2F;bin# ... 此处省略下面的代码 ...</code></pre><ol start="5"><li>激活环境变量。</li></ol><pre class="language-Shell" data-language="Shell"><code class="language-Shell">source .bash_profile</code></pre><h4 id="macOS环境"><a href="#macOS环境" class="headerlink" title="macOS环境"></a>macOS环境</h4><p>macOS也自带了Python 2.x版本，可以通过<a href="https://www.python.org/">Python的官方网站</a>提供的安装文件（pkg文件）安装Python 3.x的版本。默认安装完成后，可以通过在终端执行<code>python</code>命令来启动2.x版本的Python解释器，启动3.x版本的Python解释器需要执行<code>python3</code>命令。</p><h3 id="运行Python程序"><a href="#运行Python程序" class="headerlink" title="运行Python程序"></a>运行Python程序</h3><h4 id="确认Python的版本"><a href="#确认Python的版本" class="headerlink" title="确认Python的版本"></a>确认Python的版本</h4><p>可以Windows的命令行提示符中键入下面的命令。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">python --version</code></pre><p>在Linux或macOS系统的终端中键入下面的命令。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">python3 --version</code></pre><p>当然也可以先输入<code>python</code>或<code>python3</code>进入交互式环境，再执行以下的代码检查Python的版本。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import sysprint(sys.version_info)print(sys.version)</code></pre><h4 id="编写Python源代码"><a href="#编写Python源代码" class="headerlink" title="编写Python源代码"></a>编写Python源代码</h4><p>可以用文本编辑工具（推荐使用<a href="https://www.sublimetext.com/">Sublime</a>、<a href="https://code.visualstudio.com/">Visual Studio Code</a>等高级文本编辑工具）编写Python源代码并用py作为后缀名保存该文件，代码内容如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">print(&#39;hello, world!&#39;)</code></pre><h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>切换到源代码所在的目录并执行下面的命令，看看屏幕上是否输出了”hello, world!”。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">python hello.py</code></pre><p>或</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">python3 hello.py</code></pre><h4 id="代码中的注释"><a href="#代码中的注释" class="headerlink" title="代码中的注释"></a>代码中的注释</h4><p>注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。</p><ol><li>单行注释 - 以#和空格开头的部分</li><li>多行注释 - 三个引号开头，三个引号结尾</li></ol><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;第一个Python程序 - hello, world!向伟大的Dennis M. Ritchie先生致敬Version: 0.1Author: 骆昊&quot;&quot;&quot;print(&#39;hello, world!&#39;)# print(&quot;你好, 世界！&quot;)</code></pre><h3 id="Python开发工具"><a href="#Python开发工具" class="headerlink" title="Python开发工具"></a>Python开发工具</h3><h4 id="IDLE-自带的集成开发工具"><a href="#IDLE-自带的集成开发工具" class="headerlink" title="IDLE - 自带的集成开发工具"></a>IDLE - 自带的集成开发工具</h4><p>IDLE是安装Python环境时自带的集成开发工具，如下图所示。但是由于IDLE的用户体验并不是那么好所以很少在实际开发中被采用。</p><p><img src="/./res/python-idle.png"></p><h4 id="IPython-更好的交互式编程工具"><a href="#IPython-更好的交互式编程工具" class="headerlink" title="IPython - 更好的交互式编程工具"></a>IPython - 更好的交互式编程工具</h4><p>IPython是一种基于Python的交互式解释器。相较于原生的Python交互式环境，IPython提供了更为强大的编辑和交互功能。可以通过Python的包管理工具pip安装IPython，具体的操作如下所示。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">pip install ipython</code></pre><p>或</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">pip3 install ipython</code></pre><p>安装成功后，可以通过下面的ipython命令启动IPython，如下图所示。</p><p><img src="/./res/python-ipython.png"></p><h4 id="Sublime-Text-高级文本编辑器"><a href="#Sublime-Text-高级文本编辑器" class="headerlink" title="Sublime Text - 高级文本编辑器"></a>Sublime Text - 高级文本编辑器</h4><p><img src="/./res/python-sublime.png"></p><ul><li><p>首先可以通过<a href="https://www.sublimetext.com/">官方网站</a>下载安装程序安装Sublime Text 3或Sublime Text 2。</p></li><li><p>安装包管理工具。</p><ol><li>通过快捷键Ctrl+&#96;或者在View菜单中选择Show Console打开控制台，输入下面的代码。</li></ol><ul><li>Sublime 3</li></ul><pre class="language-Python" data-language="Python"><code class="language-Python">import  urllib.request,os;pf&#x3D;&#39;Package Control.sublime-package&#39;;ipp&#x3D;sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib.request.urlopen(&#39;http:&#x2F;&#x2F;sublime.wbond.net&#x2F;&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read())</code></pre><ul><li>Sublime 2</li></ul><pre class="language-Python" data-language="Python"><code class="language-Python">import  urllib2,os;pf&#x3D;&#39;Package Control.sublime-package&#39;;ipp&#x3D;sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),&#39;wb&#39;).write(urllib2.urlopen(&#39;http:&#x2F;&#x2F;sublime.wbond.net&#x2F;&#39;+pf.replace(&#39; &#39;,&#39;%20&#39;)).read());print(&#39;Please restart Sublime Text to finish installation&#39;)</code></pre><ol start="2"><li>在浏览器中输入  <a href="https://sublime.wbond.net/Package%20Control.sublime-package">https://sublime.wbond.net/Package%20Control.sublime-package</a> 下载包管理工具的安装包，并找到安装Sublime目录下名为&quot;Installed Packages&quot;的目录，把刚才下载的文件放到这个文件加下，然后重启Sublime Text就搞定了。</li></ol></li><li><p>安装插件。通过Preference菜单的Package Control或快捷键Ctrl+Shift+P打开命令面板，在面板中输入Install Package就可以找到安装插件的工具，然后再查找需要的插件。我们推荐大家安装以下几个插件：</p><ul><li>SublimeCodeIntel - 代码自动补全工具插件。</li><li>Emmet - 前端开发代码模板插件。</li><li>Git - 版本控制工具插件。</li><li>Python PEP8 Autoformat - PEP8规范自动格式化插件。</li><li>ConvertToUTF8 - 将本地编码转换为UTF-8。</li></ul></li></ul><blockquote><p><strong>说明</strong>：事实上<a href="https://code.visualstudio.com/">Visual Studio Code</a>可能是更好的选择，它不用花钱并提供了更为完整和强大的功能，有兴趣的读者可以自行研究。</p></blockquote><h4 id="PyCharm-Python开发神器"><a href="#PyCharm-Python开发神器" class="headerlink" title="PyCharm - Python开发神器"></a>PyCharm - Python开发神器</h4><p>PyCharm的安装、配置和使用在<a href="../%E7%95%AA%E5%A4%96%E7%AF%87/%E7%8E%A9%E8%BD%ACPyCharm.md">《玩转PyCharm》</a>进行了介绍，有兴趣的读者可以选择阅读。</p><p><img src="/./res/python-pycharm.png"></p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li><p>在Python交互式环境中输入下面的代码并查看结果，请尝试将看到的内容翻译成中文。</p> <pre class="language-Python" data-language="Python"><code class="language-Python">import this</code></pre><blockquote><p><strong>说明</strong>：输入上面的代码，在Python的交互式环境中可以看到Tim Peter撰写的<a href="../Python%E4%B9%8B%E7%A6%85.md">“Python之禅”</a>，里面讲述的道理不仅仅适用于Python，也适用于其他编程语言。</p></blockquote></li><li><p>学习使用turtle在屏幕上绘制图形。</p><blockquote><p><strong>说明</strong>：turtle是Python内置的一个非常有趣的模块，特别适合对计算机程序设计进行初体验的小伙伴，它最早是Logo语言的一部分，Logo语言是Wally Feurzig和Seymour Papert在1966发明的编程语言。</p></blockquote> <pre class="language-Python" data-language="Python"><code class="language-Python">import turtleturtle.pensize(4)turtle.pencolor(&#39;red&#39;)turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.right(90)turtle.forward(100)turtle.mainloop()</code></pre><blockquote><p><strong>提示</strong>：本章提供的代码中还有画国旗和画小猪佩奇的代码，有兴趣的读者请自行研究。</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初识Python&quot;&gt;&lt;a href=&quot;#初识Python&quot; class=&quot;headerlink&quot; title=&quot;初识Python&quot;&gt;&lt;/a&gt;初识Python&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;温馨提示&lt;/strong&gt;：2018年创建这个仓库</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>02.语言元素</title>
    <link href="http://wstcly.xyz/2024/07/01/02.yu-yan-yuan-su/"/>
    <id>http://wstcly.xyz/2024/07/01/02.yu-yan-yuan-su/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:01.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h2><h4 id="指令和程序"><a href="#指令和程序" class="headerlink" title="指令和程序"></a>指令和程序</h4><p>计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们大多数时候使用的计算机，虽然它们的元器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于<a href="https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84">“冯·诺依曼结构”</a>的计算机。“冯·诺依曼结构”有两个关键点，一是指出要将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们平常使用的历法不一样，而按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关）。对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示1，低电压表示0），于是在“冯·诺依曼结构”的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">维基百科</a>或者<a href="https://baike.baidu.com/">百度百科</a>科普一下。</p><blockquote><p><strong>说明</strong>：近期关于<strong>量子计算机</strong>的研究已经被推倒了风口浪尖，量子计算机基于量子力学进行运算，使用量子瞬移的方式来传递信息。2018年6月，Intel宣布开发出新款量子芯片并通过了在接近绝对零度环境下的测试；2019年，IBM和Google都推出了自己的量子计算机。</p></blockquote><h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><p>在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多种类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。</p><ul><li>整型：Python中可以处理任意大小的整数（Python 2.x中有<code>int</code>和<code>long</code>两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如<code>0b100</code>，换算成十进制是4）、八进制（如<code>0o100</code>，换算成十进制是64）、十进制（<code>100</code>）和十六进制（<code>0x100</code>，换算成十进制是256）的表示法。</li><li>浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如<code>123.456</code>）之外还支持科学计数法（如<code>1.23456e2</code>）。</li><li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如<code>&#39;hello&#39;</code>和<code>&quot;hello&quot;</code>,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。</li><li>布尔型：布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如<code>3 &lt; 5</code>会产生布尔值<code>True</code>，而<code>2 == 1</code>会产生布尔值<code>False</code>）。</li><li>复数型：形如<code>3+5j</code>，跟数学上的复数表示一样，唯一不同的是虚部的<code>i</code>换成了<code>j</code>。实际上，这个类型并不常用，大家了解一下就可以了。</li></ul><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。</p><ul><li>硬性规则：<ul><li>变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。</li><li>大小写敏感（大写的<code>a</code>和小写的<code>A</code>是两个不同的变量）。</li><li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。</li></ul></li><li>PEP 8要求：<ul><li>用小写字母拼写，多个单词用下划线连接。</li><li>受保护的实例属性用单个下划线开头（后面会讲到）。</li><li>私有的实例属性用两个下划线开头（后面会讲到）。</li></ul></li></ul><p>当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到见名知意也是非常重要的。</p><h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><p>下面通过几个例子来说明变量的类型和变量使用。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;使用变量保存数据并进行加减乘除运算Version: 0.1Author: 骆昊&quot;&quot;&quot;a &#x3D; 321b &#x3D; 12print(a + b)    # 333print(a - b)    # 309print(a * b)    # 3852print(a &#x2F; b)    # 26.75</code></pre><p>在Python中可以使用<code>type</code>函数对变量的类型进行检查。程序设计中函数的概念跟数学上函数的概念是一致的，数学上的函数相信大家并不陌生，它包括了函数名、自变量和因变量。如果暂时不理解这个概念也不要紧，我们会在后续的章节中专门讲解函数的定义和使用。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;使用type()检查变量的类型Version: 0.1Author: 骆昊&quot;&quot;&quot;a &#x3D; 100b &#x3D; 12.345c &#x3D; 1 + 5jd &#x3D; &#39;hello, world&#39;e &#x3D; Trueprint(type(a))    # &lt;class &#39;int&#39;&gt;print(type(b))    # &lt;class &#39;float&#39;&gt;print(type(c))    # &lt;class &#39;complex&#39;&gt;print(type(d))    # &lt;class &#39;str&#39;&gt;print(type(e))    # &lt;class &#39;bool&#39;&gt;</code></pre><p>可以使用Python中内置的函数对变量类型进行转换。</p><ul><li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li><li><code>float()</code>：将一个字符串转换成浮点数。</li><li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li><li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li><li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。</li></ul><p>下面的代码通过键盘输入两个整数来实现对两个整数的算术运算。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;使用input()函数获取键盘输入(字符串)使用int()函数将输入的字符串转换成整数使用print()函数输出带占位符的字符串Version: 0.1Author: 骆昊&quot;&quot;&quot;a &#x3D; int(input(&#39;a &#x3D; &#39;))b &#x3D; int(input(&#39;b &#x3D; &#39;))print(&#39;%d + %d &#x3D; %d&#39; % (a, b, a + b))print(&#39;%d - %d &#x3D; %d&#39; % (a, b, a - b))print(&#39;%d * %d &#x3D; %d&#39; % (a, b, a * b))print(&#39;%d &#x2F; %d &#x3D; %f&#39; % (a, b, a &#x2F; b))print(&#39;%d &#x2F;&#x2F; %d &#x3D; %d&#39; % (a, b, a &#x2F;&#x2F; b))print(&#39;%d %% %d &#x3D; %d&#39; % (a, b, a % b))print(&#39;%d ** %d &#x3D; %d&#39; % (a, b, a ** b))</code></pre><blockquote><p><strong>说明</strong>：上面的print函数中输出的字符串使用了占位符语法，其中<code>%d</code>是整数的占位符，<code>%f</code>是小数的占位符，<code>%%</code>表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成<code>%%</code>），字符串之后的<code>%</code>后面跟的变量值会替换掉占位符然后输出到终端中，运行上面的程序，看看程序执行结果就明白啦。</p></blockquote><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，运算符的优先级指的是多个运算符同时出现时，先做什么运算然后再做什么运算。除了我们之前已经用过的赋值运算符和算术运算符，我们稍后会陆续讲到其他运算符的使用。</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>[]</code> <code>[:]</code></td><td>下标，切片</td></tr><tr><td><code>**</code></td><td>指数</td></tr><tr><td><code>~</code> <code>+</code> <code>-</code></td><td>按位取反, 正负号</td></tr><tr><td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td>乘，除，模，整除</td></tr><tr><td><code>+</code> <code>-</code></td><td>加，减</td></tr><tr><td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td><td>右移，左移</td></tr><tr><td><code>&amp;</code></td><td>按位与</td></tr><tr><td><code>^</code> <code>|</code></td><td>按位异或，按位或</td></tr><tr><td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr><tr><td><code>==</code> <code>!=</code></td><td>等于，不等于</td></tr><tr><td><code>is</code>  <code>is not</code></td><td>身份运算符</td></tr><tr><td><code>in</code> <code>not in</code></td><td>成员运算符</td></tr><tr><td><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr><tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> &#96;</td><td>&#x3D;<code> </code>^&#x3D;<code> </code>&gt;&gt;&#x3D;<code> </code>&lt;&lt;&#x3D;&#96;</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。</p></blockquote><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。下面的例子演示了赋值运算符和复合赋值运算符的使用。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;赋值运算符和复合赋值运算符Version: 0.1Author: 骆昊&quot;&quot;&quot;a &#x3D; 10b &#x3D; 3a +&#x3D; b        # 相当于：a &#x3D; a + ba *&#x3D; a + 2    # 相当于：a &#x3D; a * (a + 2)print(a)      # 算一下这里会输出什么</code></pre><h3 id="比较运算符和逻辑运算符"><a href="#比较运算符和逻辑运算符" class="headerlink" title="比较运算符和逻辑运算符"></a>比较运算符和逻辑运算符</h3><p>比较运算符有的地方也称为关系运算符，包括<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>，我相信没有什么好解释的，大家一看就能懂，唯一需要提醒的是比较相等用的是<code>==</code>，请注意这个地方是两个等号，因为<code>=</code>是赋值运算符，我们在上面刚刚讲到过，<code>==</code>才是比较相等的比较运算符。比较运算符会产生布尔值，要么是<code>True</code>要么是<code>False</code>。</p><p>逻辑运算符有三个，分别是<code>and</code>、<code>or</code>和<code>not</code>。<code>and</code>字面意思是“而且”，所以<code>and</code>运算符会连接两个布尔值，如果两个布尔值都是<code>True</code>，那么运算的结果就是<code>True</code>；左右两边的布尔值有一个是<code>False</code>，最终的运算结果就是<code>False</code>。相信大家已经想到了，如果<code>and</code>左边的布尔值是<code>False</code>，不管右边的布尔值是什么，最终的结果都是<code>False</code>，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在<code>and</code>运算符左边为<code>False</code>的情况下，右边的表达式根本不会执行。<code>or</code>字面意思是“或者”，所以<code>or</code>运算符也会连接两个布尔值，如果两个布尔值有任意一个是<code>True</code>，那么最终的结果就是<code>True</code>。当然，<code>or</code>运算符也是有短路功能的，在它左边的布尔值为<code>True</code>的情况下，右边的表达式根本不会执行。<code>not</code>运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，后面的布尔值如果是<code>True</code>运算结果就是<code>False</code>，而后面的布尔值如果是<code>False</code>则运算结果就是<code>True</code>。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;比较运算符和逻辑运算符的使用Version: 0.1Author: 骆昊&quot;&quot;&quot;flag0 &#x3D; 1 &#x3D;&#x3D; 1flag1 &#x3D; 3 &gt; 2flag2 &#x3D; 2 &lt; 1flag3 &#x3D; flag1 and flag2flag4 &#x3D; flag1 or flag2flag5 &#x3D; not (1 !&#x3D; 2)print(&#39;flag0 &#x3D;&#39;, flag0)    # flag0 &#x3D; Trueprint(&#39;flag1 &#x3D;&#39;, flag1)    # flag1 &#x3D; Trueprint(&#39;flag2 &#x3D;&#39;, flag2)    # flag2 &#x3D; Falseprint(&#39;flag3 &#x3D;&#39;, flag3)    # flag3 &#x3D; Falseprint(&#39;flag4 &#x3D;&#39;, flag4)    # flag4 &#x3D; Trueprint(&#39;flag5 &#x3D;&#39;, flag5)    # flag5 &#x3D; False</code></pre><blockquote><p><strong>说明</strong>：比较运算符的优先级高于赋值运算符，所以<code>flag0 = 1 == 1</code>先做<code>1 == 1</code>产生布尔值<code>True</code>，再将这个值赋值给变量<code>flag0</code>。<code>print</code>函数可以输出多个值，多个值之间可以用<code>,</code>进行分隔，输出的内容之间默认以空格分开。</p></blockquote><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：华氏温度转换为摄氏温度。"><a href="#练习1：华氏温度转换为摄氏温度。" class="headerlink" title="练习1：华氏温度转换为摄氏温度。"></a>练习1：华氏温度转换为摄氏温度。</h4><blockquote><p>提示：华氏温度到摄氏温度的转换公式为：$C&#x3D;(F - 32) \div 1.8$。</p></blockquote><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;将华氏温度转换为摄氏温度Version: 0.1Author: 骆昊&quot;&quot;&quot;f &#x3D; float(input(&#39;请输入华氏温度: &#39;))c &#x3D; (f - 32) &#x2F; 1.8print(&#39;%.1f华氏度 &#x3D; %.1f摄氏度&#39; % (f, c))</code></pre><blockquote><p><strong>说明</strong>：在使用<code>print</code>函数输出时，也可以对字符串内容进行格式化处理，上面<code>print</code>函数中的字符串<code>%.1f</code>是一个占位符，稍后会由一个<code>float</code>类型的变量值替换掉它。同理，如果字符串中有<code>%d</code>，后面可以用一个<code>int</code>类型的变量值替换掉它，而<code>%s</code>会被字符串的值替换掉。除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中<code>&#123;f:.1f&#125;</code>和<code>&#123;c:.1f&#125;</code>可以先看成是<code>&#123;f&#125;</code>和<code>&#123;c&#125;</code>，表示输出时会用变量<code>f</code>和变量<code>c</code>的值替换掉这两个占位符，后面的<code>:.1f</code>表示这是一个浮点数，小数点后保留1位有效数字。</p><pre class="language-Python" data-language="Python"><code class="language-Python">print(f&#39;&#123;f:.1f&#125;华氏度 &#x3D; &#123;c:.1f&#125;摄氏度&#39;)</code></pre></blockquote><h4 id="练习2：输入圆的半径计算计算周长和面积。"><a href="#练习2：输入圆的半径计算计算周长和面积。" class="headerlink" title="练习2：输入圆的半径计算计算周长和面积。"></a>练习2：输入圆的半径计算计算周长和面积。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;输入半径计算圆的周长和面积Version: 0.1Author: 骆昊&quot;&quot;&quot;radius &#x3D; float(input(&#39;请输入圆的半径: &#39;))perimeter &#x3D; 2 * 3.1416 * radiusarea &#x3D; 3.1416 * radius * radiusprint(&#39;周长: %.2f&#39; % perimeter)print(&#39;面积: %.2f&#39; % area)</code></pre><h4 id="练习3：输入年份判断是不是闰年。"><a href="#练习3：输入年份判断是不是闰年。" class="headerlink" title="练习3：输入年份判断是不是闰年。"></a>练习3：输入年份判断是不是闰年。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;输入年份 如果是闰年输出True 否则输出FalseVersion: 0.1Author: 骆昊&quot;&quot;&quot;year &#x3D; int(input(&#39;请输入年份: &#39;))# 如果代码太长写成一行不便于阅读 可以使用\对代码进行折行is_leap &#x3D; year % 4 &#x3D;&#x3D; 0 and year % 100 !&#x3D; 0 or \          year % 400 &#x3D;&#x3D; 0print(is_leap)</code></pre><blockquote><p><strong>说明</strong>：比较运算符会产生布尔值，而逻辑运算符<code>and</code>和<code>or</code>会对这些布尔值进行组合，最终也是得到一个布尔值，闰年输出<code>True</code>，平年输出<code>False</code>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;语言元素&quot;&gt;&lt;a href=&quot;#语言元素&quot; class=&quot;headerlink&quot; title=&quot;语言元素&quot;&gt;&lt;/a&gt;语言元素&lt;/h2&gt;&lt;h4 id=&quot;指令和程序&quot;&gt;&lt;a href=&quot;#指令和程序&quot; class=&quot;headerlink&quot; title=&quot;指令和程序&quot;&gt;</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>03.分支结构</title>
    <link href="http://wstcly.xyz/2024/07/01/03.fen-zhi-jie-gou/"/>
    <id>http://wstcly.xyz/2024/07/01/03.fen-zhi-jie-gou/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:02.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种代码结构通常称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后，我们要根据玩家得到分数来决定究竟是进入第二关，还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行。类似的场景还有很多，我们将这种结构称之为“分支结构”或“选择结构”。给大家一分钟的时间，你应该可以想到至少5个以上这样的例子，赶紧试一试。</p><h3 id="if语句的使用"><a href="#if语句的使用" class="headerlink" title="if语句的使用"></a>if语句的使用</h3><p>在Python中，要构造分支结构可以使用<code>if</code>、<code>elif</code>和<code>else</code>关键字。所谓<strong>关键字</strong>就是有特殊含义的单词，像<code>if</code>和<code>else</code>就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）。下面的例子中演示了如何构造一个分支结构。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;用户身份验证Version: 0.1Author: 骆昊&quot;&quot;&quot;username &#x3D; input(&#39;请输入用户名: &#39;)password &#x3D; input(&#39;请输入口令: &#39;)# 用户名是admin且密码是123456则身份验证成功否则身份验证失败if username &#x3D;&#x3D; &#39;admin&#39; and password &#x3D;&#x3D; &#39;123456&#39;:    print(&#39;身份验证成功!&#39;)else:    print(&#39;身份验证失败!&#39;)</code></pre><p>需要说明的是和C&#x2F;C++、Java等语言不同，Python中没有用花括号来构造代码块而是<strong>使用了缩进的方式来表示代码的层次结构</strong>，如果<code>if</code>条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了。换句话说<strong>连续的代码如果又保持了相同的缩进那么它们属于同一个代码块</strong>，相当于是一个执行的整体。<strong>缩进</strong>可以使用任意数量的空格，但<strong>通常使用4个空格</strong>，建议大家<strong>不要使用制表键</strong>或者<strong>设置你的代码编辑工具自动将制表键变成4个空格</strong>。</p><p>当然如果要构造出更多的分支，可以使用<code>if...elif...else...</code>结构或者嵌套的<code>if...else...</code>结构，下面的代码演示了如何利用多分支结构实现分段函数求值。</p><p><img src="/./res/formula_1.png" alt="$$f(x)=\begin{cases} 3x-5&amp;\text{(x&gt;1)}\\x+2&amp;\text{(-1}\leq\text{x}\leq\text{1)}\\5x+3&amp;\text {(x&lt;-1)}\end{cases}$$"></p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;分段函数求值        3x - 5  (x &gt; 1)f(x) &#x3D;  x + 2   (-1 &lt;&#x3D; x &lt;&#x3D; 1)        5x + 3  (x &lt; -1)Version: 0.1Author: 骆昊&quot;&quot;&quot;x &#x3D; float(input(&#39;x &#x3D; &#39;))if x &gt; 1:    y &#x3D; 3 * x - 5elif x &gt;&#x3D; -1:    y &#x3D; x + 2else:    y &#x3D; 5 * x + 3print(&#39;f(%.2f) &#x3D; %.2f&#39; % (x, y))</code></pre><p>当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在<code>if</code>的内部构造出一个新的分支结构，同理<code>elif</code>和<code>else</code>中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;分段函数求值3x - 5(x &gt; 1)f(x) &#x3D;x + 2(-1 &lt;&#x3D; x &lt;&#x3D; 1)5x + 3(x &lt; -1)Version: 0.1Author: 骆昊&quot;&quot;&quot;x &#x3D; float(input(&#39;x &#x3D; &#39;))if x &gt; 1:    y &#x3D; 3 * x - 5else:    if x &gt;&#x3D; -1:        y &#x3D; x + 2    else:        y &#x3D; 5 * x + 3print(&#39;f(%.2f) &#x3D; %.2f&#39; % (x, y))</code></pre><blockquote><p><strong>说明：</strong> 大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is better than nested.”，之所以提倡代码“扁平化”是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，所以能使用扁平化的结构时就不要使用嵌套。</p></blockquote><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：英制单位英寸与公制单位厘米互换。"><a href="#练习1：英制单位英寸与公制单位厘米互换。" class="headerlink" title="练习1：英制单位英寸与公制单位厘米互换。"></a>练习1：英制单位英寸与公制单位厘米互换。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;英制单位英寸和公制单位厘米互换Version: 0.1Author: 骆昊&quot;&quot;&quot;value &#x3D; float(input(&#39;请输入长度: &#39;))unit &#x3D; input(&#39;请输入单位: &#39;)if unit &#x3D;&#x3D; &#39;in&#39; or unit &#x3D;&#x3D; &#39;英寸&#39;:    print(&#39;%f英寸 &#x3D; %f厘米&#39; % (value, value * 2.54))elif unit &#x3D;&#x3D; &#39;cm&#39; or unit &#x3D;&#x3D; &#39;厘米&#39;:    print(&#39;%f厘米 &#x3D; %f英寸&#39; % (value, value &#x2F; 2.54))else:    print(&#39;请输入有效的单位&#39;)</code></pre><h4 id="练习2：百分制成绩转换为等级制成绩。"><a href="#练习2：百分制成绩转换为等级制成绩。" class="headerlink" title="练习2：百分制成绩转换为等级制成绩。"></a>练习2：百分制成绩转换为等级制成绩。</h4><blockquote><p><strong>要求</strong>：如果输入的成绩在90分以上（含90分）输出A；80分-90分（不含90分）输出B；70分-80分（不含80分）输出C；60分-70分（不含70分）输出D；60分以下输出E。</p></blockquote><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;百分制成绩转换为等级制成绩Version: 0.1Author: 骆昊&quot;&quot;&quot;score &#x3D; float(input(&#39;请输入成绩: &#39;))if score &gt;&#x3D; 90:    grade &#x3D; &#39;A&#39;elif score &gt;&#x3D; 80:    grade &#x3D; &#39;B&#39;elif score &gt;&#x3D; 70:    grade &#x3D; &#39;C&#39;elif score &gt;&#x3D; 60:    grade &#x3D; &#39;D&#39;else:    grade &#x3D; &#39;E&#39;print(&#39;对应的等级是:&#39;, grade)</code></pre><h4 id="练习3：输入三条边长，如果能构成三角形就计算周长和面积。"><a href="#练习3：输入三条边长，如果能构成三角形就计算周长和面积。" class="headerlink" title="练习3：输入三条边长，如果能构成三角形就计算周长和面积。"></a>练习3：输入三条边长，如果能构成三角形就计算周长和面积。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;判断输入的边长能否构成三角形，如果能则计算出三角形的周长和面积Version: 0.1Author: 骆昊&quot;&quot;&quot;a &#x3D; float(input(&#39;a &#x3D; &#39;))b &#x3D; float(input(&#39;b &#x3D; &#39;))c &#x3D; float(input(&#39;c &#x3D; &#39;))if a + b &gt; c and a + c &gt; b and b + c &gt; a:    print(&#39;周长: %f&#39; % (a + b + c))    p &#x3D; (a + b + c) &#x2F; 2    area &#x3D; (p * (p - a) * (p - b) * (p - c)) ** 0.5    print(&#39;面积: %f&#39; % (area))else:    print(&#39;不能构成三角形&#39;)</code></pre><blockquote><p><strong>说明：</strong> 上面使用的通过边长计算三角形面积的公式叫做<a href="https://zh.wikipedia.org/zh-hans/%E6%B5%B7%E4%BC%A6%E5%85%AC%E5%BC%8F">海伦公式</a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分支结构&quot;&gt;&lt;a href=&quot;#分支结构&quot; class=&quot;headerlink&quot; title=&quot;分支结构&quot;&gt;&lt;/a&gt;分支结构&lt;/h2&gt;&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.循环结构</title>
    <link href="http://wstcly.xyz/2024/07/01/04.xun-huan-jie-gou/"/>
    <id>http://wstcly.xyz/2024/07/01/04.xun-huan-jie-gou/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:03.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>我们在写程序的时候，一定会遇到需要重复执行某条或某些指令的场景。例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向移动的指令。在这个场景中，让机器人向球门方向移动就是一个需要重复的动作，当然这里还会用到上一课讲的分支结构来判断机器人是否持球以及是否进入射门范围。再举一个简单的例子，如果要实现每隔1秒中在屏幕上打印一次“hello, world”并持续打印一个小时，我们肯定不能够直接把<code>print(&#39;hello, world&#39;)</code>这句代码写3600遍，这里同样需要循环结构。</p><p>循环结构就是程序中控制某条或某些指令重复执行的结构。在Python中构造循环结构有两种做法，一种是<code>for-in</code>循环，一种是<code>while</code>循环。</p><h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h3><p>如果明确的知道循环执行的次数或者要对一个容器进行迭代（后面会讲到），那么我们推荐使用<code>for-in</code>循环，例如下面代码中计算1~100求和的结果（$\displaystyle \sum \limits_{n&#x3D;1}^{100}n$）。 </p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;用for循环实现1~100求和Version: 0.1Author: 骆昊&quot;&quot;&quot;sum &#x3D; 0for x in range(101):    sum +&#x3D; xprint(sum)</code></pre><p>需要说明的是上面代码中的<code>range(1, 101)</code>可以用来构造一个从1到100的范围，当我们把这样一个范围放到<code>for-in</code>循环中，就可以通过前面的循环变量<code>x</code>依次取出从1到100的整数。当然，<code>range</code>的用法非常灵活，下面给出了一个例子：</p><ul><li><code>range(101)</code>：可以用来产生0到100范围的整数，需要注意的是取不到101。</li><li><code>range(1, 101)</code>：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。</li><li><code>range(1, 101, 2)</code>：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。</li><li><code>range(100, 0, -2)</code>：可以用来产生100到1的偶数，其中-2是步长，即每次数字递减的值。</li></ul><p>知道了这一点，我们可以用下面的代码来实现1~100之间的偶数求和。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;用for循环实现1~100之间的偶数求和Version: 0.1Author: 骆昊&quot;&quot;&quot;sum &#x3D; 0for x in range(2, 101, 2):    sum +&#x3D; xprint(sum)</code></pre><p>当然，也可以通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;用for循环实现1~100之间的偶数求和Version: 0.1Author: 骆昊&quot;&quot;&quot;sum &#x3D; 0for x in range(1, 101):    if x % 2 &#x3D;&#x3D; 0:        sum +&#x3D; xprint(sum)</code></pre><blockquote><p><strong>说明</strong>：相较于上面直接跳过奇数的做法，下面这种做法很明显并不是很好的选择。</p></blockquote><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>如果要构造不知道具体循环次数的循环结构，我们推荐使用<code>while</code>循环。<code>while</code>循环通过一个能够产生或转换出<code>bool</code>值的表达式来控制循环，表达式的值为<code>True</code>则继续循环；表达式的值为<code>False</code>则结束循环。</p><p>下面我们通过一个“猜数字”的小游戏来看看如何使用<code>while</code>循环。猜数字游戏的规则是：计算机出一个1到100之间的随机数，玩家输入自己猜的数字，计算机给出对应的提示信息（大一点、小一点或猜对了），如果玩家猜中了数字，计算机提示用户一共猜了多少次，游戏结束，否则游戏继续。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;猜数字游戏Version: 0.1Author: 骆昊&quot;&quot;&quot;import randomanswer &#x3D; random.randint(1, 100)counter &#x3D; 0while True:    counter +&#x3D; 1    number &#x3D; int(input(&#39;请输入: &#39;))    if number &lt; answer:        print(&#39;大一点&#39;)    elif number &gt; answer:        print(&#39;小一点&#39;)    else:        print(&#39;恭喜你猜对了!&#39;)        breakprint(&#39;你总共猜了%d次&#39; % counter)if counter &gt; 7:    print(&#39;你的智商余额明显不足&#39;)</code></pre><p>上面的代码中使用了<code>break</code>关键字来提前终止循环，需要注意的是<code>break</code>只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了<code>break</code>之外，还有另一个关键字是<code>continue</code>，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。</p><p>和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;输出乘法口诀表(九九表)Version: 0.1Author: 骆昊&quot;&quot;&quot;for i in range(1, 10):    for j in range(1, i + 1):        print(&#39;%d*%d&#x3D;%d&#39; % (i, j, i * j), end&#x3D;&#39;\t&#39;)    print()</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：输入一个正整数判断是不是素数。"><a href="#练习1：输入一个正整数判断是不是素数。" class="headerlink" title="练习1：输入一个正整数判断是不是素数。"></a>练习1：输入一个正整数判断是不是素数。</h4><blockquote><p><strong>提示</strong>：素数指的是只能被1和自身整除的大于1的整数。</p></blockquote><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;输入一个正整数判断它是不是素数Version: 0.1Author: 骆昊Date: 2018-03-01&quot;&quot;&quot;from math import sqrtnum &#x3D; int(input(&#39;请输入一个正整数: &#39;))end &#x3D; int(sqrt(num))is_prime &#x3D; Truefor x in range(2, end + 1):    if num % x &#x3D;&#x3D; 0:        is_prime &#x3D; False        breakif is_prime and num !&#x3D; 1:    print(&#39;%d是素数&#39; % num)else:    print(&#39;%d不是素数&#39; % num)</code></pre><h4 id="练习2：输入两个正整数，计算它们的最大公约数和最小公倍数。"><a href="#练习2：输入两个正整数，计算它们的最大公约数和最小公倍数。" class="headerlink" title="练习2：输入两个正整数，计算它们的最大公约数和最小公倍数。"></a>练习2：输入两个正整数，计算它们的最大公约数和最小公倍数。</h4><blockquote><p><strong>提示</strong>：两个数的最大公约数是两个数的公共因子中最大的那个数；两个数的最小公倍数则是能够同时被两个数整除的最小的那个数。</p></blockquote><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;输入两个正整数计算它们的最大公约数和最小公倍数Version: 0.1Author: 骆昊Date: 2018-03-01&quot;&quot;&quot;x &#x3D; int(input(&#39;x &#x3D; &#39;))y &#x3D; int(input(&#39;y &#x3D; &#39;))# 如果x大于y就交换x和y的值if x &gt; y:    # 通过下面的操作将y的值赋给x, 将x的值赋给y    x, y &#x3D; y, x# 从两个数中较小的数开始做递减的循环for factor in range(x, 0, -1):    if x % factor &#x3D;&#x3D; 0 and y % factor &#x3D;&#x3D; 0:        print(&#39;%d和%d的最大公约数是%d&#39; % (x, y, factor))        print(&#39;%d和%d的最小公倍数是%d&#39; % (x, y, x * y &#x2F;&#x2F; factor))        break</code></pre><h4 id="练习3：打印如下所示的三角形图案。"><a href="#练习3：打印如下所示的三角形图案。" class="headerlink" title="练习3：打印如下所示的三角形图案。"></a>练习3：打印如下所示的三角形图案。</h4><pre class="language-none"><code class="language-none">***************</code></pre><pre class="language-none"><code class="language-none">    *   **  *** *********</code></pre><pre class="language-none"><code class="language-none">    *   ***  ***** ****************</code></pre><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;打印三角形图案Version: 0.1Author: 骆昊&quot;&quot;&quot;row &#x3D; int(input(&#39;请输入行数: &#39;))for i in range(row):    for _ in range(i + 1):        print(&#39;*&#39;, end&#x3D;&#39;&#39;)    print()for i in range(row):    for j in range(row):        if j &lt; row - i - 1:            print(&#39; &#39;, end&#x3D;&#39;&#39;)        else:            print(&#39;*&#39;, end&#x3D;&#39;&#39;)    print()for i in range(row):    for _ in range(row - i - 1):        print(&#39; &#39;, end&#x3D;&#39;&#39;)    for _ in range(2 * i + 1):        print(&#39;*&#39;, end&#x3D;&#39;&#39;)    print()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;循环结构&quot;&gt;&lt;a href=&quot;#循环结构&quot; class=&quot;headerlink&quot; title=&quot;循环结构&quot;&gt;&lt;/a&gt;循环结构&lt;/h2&gt;&lt;h3 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>05.构造程序逻辑</title>
    <link href="http://wstcly.xyz/2024/07/01/05.gou-zao-cheng-xu-luo-ji/"/>
    <id>http://wstcly.xyz/2024/07/01/05.gou-zao-cheng-xu-luo-ji/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:03.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构造程序逻辑"><a href="#构造程序逻辑" class="headerlink" title="构造程序逻辑"></a>构造程序逻辑</h2><p>学完前面的几个章节后，我觉得有必要在这里带大家做一些练习来巩固之前所学的知识，虽然迄今为止我们学习的内容只是Python的冰山一角，但是这些内容已经足够我们来构建程序中的逻辑。对于编程语言的初学者来说，在学习了Python的核心语言元素（变量、类型、运算符、表达式、分支结构、循环结构等）之后，必须做的一件事情就是尝试用所学知识去解决现实中的问题，换句话说就是锻炼自己把用人类自然语言描述的算法（解决问题的方法和步骤）翻译成Python代码的能力，而这件事情必须通过大量的练习才能达成。</p><p>我们在本章为大家整理了一些经典的案例和习题，希望通过这些例子，一方面帮助大家巩固之前所学的Python知识，另一方面帮助大家了解如何建立程序中的逻辑以及如何运用一些简单的算法解决现实中的问题。</p><h3 id="经典的例子"><a href="#经典的例子" class="headerlink" title="经典的例子"></a>经典的例子</h3><ol><li><p>寻找<strong>水仙花数</strong>。</p><blockquote><p><strong>说明</strong>：水仙花数也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个3位数，该数字每个位上数字的立方之和正好等于它本身，例如：$1^3 + 5^3+ 3^3&#x3D;153$。</p></blockquote><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;找出所有水仙花数Version: 0.1Author: 骆昊&quot;&quot;&quot;for num in range(100, 1000):    low &#x3D; num % 10    mid &#x3D; num &#x2F;&#x2F; 10 % 10    high &#x3D; num &#x2F;&#x2F; 100    if num &#x3D;&#x3D; low ** 3 + mid ** 3 + high ** 3:        print(num)</code></pre><p>在上面的代码中，我们通过整除和求模运算分别找出了一个三位数的个位、十位和百位，这种小技巧在实际开发中还是常用的。用类似的方法，我们还可以实现将一个正整数反转，例如：将12345变成54321，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;正整数的反转Version: 0.1Author: 骆昊&quot;&quot;&quot;num &#x3D; int(input(&#39;num &#x3D; &#39;))reversed_num &#x3D; 0while num &gt; 0:    reversed_num &#x3D; reversed_num * 10 + num % 10    num &#x2F;&#x2F;&#x3D; 10print(reversed_num)</code></pre></li><li><p><strong>百钱百鸡</strong>问题。</p><blockquote><p><strong>说明</strong>：百钱百鸡是我国古代数学家<a href="https://baike.baidu.com/item/%E5%BC%A0%E4%B8%98%E5%BB%BA/10246238">张丘建</a>在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现代文是：公鸡5元一只，母鸡3元一只，小鸡1元三只，用100块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？</p></blockquote><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;《百钱百鸡》问题Version: 0.1Author: 骆昊&quot;&quot;&quot;for x in range(0, 20):    for y in range(0, 33):        z &#x3D; 100 - x - y        if 5 * x + 3 * y + z &#x2F; 3 &#x3D;&#x3D; 100:            print(&#39;公鸡: %d只, 母鸡: %d只, 小鸡: %d只&#39; % (x, y, z))</code></pre><p>上面使用的方法叫做<strong>穷举法</strong>，也称为<strong>暴力搜索法</strong>，这种方法通过一项一项的列举备选解决方案中所有可能的候选项并检查每个候选项是否符合问题的描述，最终得到问题的解。这种方法看起来比较笨拙，但对于运算能力非常强大的计算机来说，通常都是一个可行的甚至是不错的选择，而且问题的解如果存在，这种方法一定能够找到它。</p></li><li><p><strong>CRAPS赌博游戏</strong>。</p><blockquote><p><strong>说明</strong>：CRAPS又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简单的规则是：玩家第一次摇骰子如果摇出了7点或11点，玩家胜；玩家第一次如果摇出2点、3点或12点，庄家胜；其他点数玩家继续摇骰子，如果玩家摇出了7点，庄家胜；如果玩家摇出了第一次摇的点数，玩家胜；其他点数，玩家继续要骰子，直到分出胜负。</p></blockquote><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;Craps赌博游戏我们设定玩家开始游戏时有1000元的赌注游戏结束的条件是玩家输光所有的赌注Version: 0.1Author: 骆昊&quot;&quot;&quot;from random import randintmoney &#x3D; 1000while money &gt; 0:    print(&#39;你的总资产为:&#39;, money)    needs_go_on &#x3D; False    while True:        debt &#x3D; int(input(&#39;请下注: &#39;))        if 0 &lt; debt &lt;&#x3D; money:            break    first &#x3D; randint(1, 6) + randint(1, 6)    print(&#39;玩家摇出了%d点&#39; % first)    if first &#x3D;&#x3D; 7 or first &#x3D;&#x3D; 11:        print(&#39;玩家胜!&#39;)        money +&#x3D; debt    elif first &#x3D;&#x3D; 2 or first &#x3D;&#x3D; 3 or first &#x3D;&#x3D; 12:        print(&#39;庄家胜!&#39;)        money -&#x3D; debt    else:        needs_go_on &#x3D; True    while needs_go_on:        needs_go_on &#x3D; False        current &#x3D; randint(1, 6) + randint(1, 6)        print(&#39;玩家摇出了%d点&#39; % current)        if current &#x3D;&#x3D; 7:            print(&#39;庄家胜&#39;)            money -&#x3D; debt        elif current &#x3D;&#x3D; first:            print(&#39;玩家胜&#39;)            money +&#x3D; debt        else:            needs_go_on &#x3D; Trueprint(&#39;你破产了, 游戏结束!&#39;)</code></pre></li></ol><p>###有用的练习 </p><ol><li><p>生成<strong>斐波那契数列</strong>的前20个数。</p><blockquote><p><strong>说明</strong>：斐波那契数列（Fibonacci sequence），又称黄金分割数列，是意大利数学家莱昂纳多·斐波那契（Leonardoda Fibonacci）在《计算之书》中提出一个在理想假设条件下兔子成长率的问题而引入的数列，所以这个数列也被戏称为&quot;兔子数列&quot;。斐波那契数列的特点是数列的前两个数都是1，从第三个数开始，每个数都是它前面两个数的和，形如：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …。斐波那契数列在现代物理、准晶体结构、化学等领域都有直接的应用。</p></blockquote></li><li><p>找出10000以内的<strong>完美数</strong>。</p><blockquote><p><strong>说明</strong>：完美数又称为完全数或完备数，它的所有的真因子（即除了自身以外的因子）的和（即因子函数）恰好等于它本身。例如：6（$6&#x3D;1+2+3$）和28（$28&#x3D;1+2+4+7+14$）就是完美数。完美数有很多神奇的特性，有兴趣的可以自行了解。</p></blockquote></li><li><p>输出<strong>100以内所有的素数</strong>。</p><blockquote><p><strong>说明</strong>：素数指的是只能被1和自身整除的正整数（不包括1）。</p></blockquote></li></ol><p>上面练习的参考答案在本章对应的代码目录中，如果需要帮助请读者自行查看参考答案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;构造程序逻辑&quot;&gt;&lt;a href=&quot;#构造程序逻辑&quot; class=&quot;headerlink&quot; title=&quot;构造程序逻辑&quot;&gt;&lt;/a&gt;构造程序逻辑&lt;/h2&gt;&lt;p&gt;学完前面的几个章节后，我觉得有必要在这里带大家做一些练习来巩固之前所学的知识，虽然迄今为止我们学习的内容只是</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>06.函数和模块的使用</title>
    <link href="http://wstcly.xyz/2024/07/01/06.han-shu-he-mo-kuai-de-shi-yong/"/>
    <id>http://wstcly.xyz/2024/07/01/06.han-shu-he-mo-kuai-de-shi-yong/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:01.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数和模块的使用"><a href="#函数和模块的使用" class="headerlink" title="函数和模块的使用"></a>函数和模块的使用</h2><p>在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。</p><p><img src="/./res/formula_3.png" alt="$$x_1 + x_2 + x_3 + x_4 = 8$$"></p><p>事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。</p><p><img src="/./res/formula_4.png" alt="$$C_M^N =\frac{M!}{N!(M-N)!}, \text{(M=7, N=3)} $$"></p><p>可以用Python的程序来计算出这个值，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;输入M和N计算C(M,N)Version: 0.1Author: 骆昊&quot;&quot;&quot;m &#x3D; int(input(&#39;m &#x3D; &#39;))n &#x3D; int(input(&#39;n &#x3D; &#39;))fm &#x3D; 1for num in range(1, m + 1):    fm *&#x3D; numfn &#x3D; 1for num in range(1, n + 1):    fn *&#x3D; numfm_n &#x3D; 1for num in range(1, m - n + 1):    fm_n *&#x3D; numprint(fm &#x2F;&#x2F; fn &#x2F;&#x2F; fm_n)</code></pre><h3 id="函数的作用"><a href="#函数的作用" class="headerlink" title="函数的作用"></a>函数的作用</h3><p>不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师<em>Martin Fowler</em>先生曾经说过：“<strong>代码有很多种坏味道，重复是最坏的一种！</strong>”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在Python中可以使用<code>def</code>关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过<code>return</code>关键字来返回一个值，这相当于数学上说的函数的因变量。</p><p>在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;输入M和N计算C(M,N)Version: 0.1Author: 骆昊&quot;&quot;&quot;def fac(num):    &quot;&quot;&quot;求阶乘&quot;&quot;&quot;    result &#x3D; 1    for n in range(1, num + 1):        result *&#x3D; n    return resultm &#x3D; int(input(&#39;m &#x3D; &#39;))n &#x3D; int(input(&#39;n &#x3D; &#39;))# 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数print(fac(m) &#x2F;&#x2F; fac(n) &#x2F;&#x2F; fac(m - n))</code></pre><blockquote><p><strong>说明：</strong> Python的<code>math</code>模块中其实已经有一个名为<code>factorial</code>函数实现了阶乘运算，事实上求阶乘并不用自己定义函数。下面的例子中，我们讲的函数在Python标准库已经实现过了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，<strong>实际开发中并不建议做这种低级的重复劳动</strong>。</p></blockquote><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数是绝大多数编程语言中都支持的一个代码的&quot;构建块&quot;，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">函数的重载</a>，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from random import randintdef roll_dice(n&#x3D;2):    &quot;&quot;&quot;摇色子&quot;&quot;&quot;    total &#x3D; 0    for _ in range(n):        total +&#x3D; randint(1, 6)    return totaldef add(a&#x3D;0, b&#x3D;0, c&#x3D;0):    &quot;&quot;&quot;三个数相加&quot;&quot;&quot;    return a + b + c# 如果没有指定参数那么使用默认值摇两颗色子print(roll_dice())# 摇三颗色子print(roll_dice(3))print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))# 传递参数时可以不按照设定的顺序进行传递print(add(c&#x3D;50, a&#x3D;100, b&#x3D;200))</code></pre><p>我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用<code>add</code>函数，这跟其他很多语言中函数重载的效果是一致的。</p><p>其实上面的<code>add</code>函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python"># 在参数名前面的*表示args是一个可变参数def add(*args):    total &#x3D; 0    for val in args:        total +&#x3D; val    return total# 在调用add函数时可以传入0个或多个参数print(add())print(add(1))print(add(1, 2))print(add(1, 2, 3))print(add(1, 3, 5, 7, 9))</code></pre><h3 id="用模块管理函数"><a href="#用模块管理函数" class="headerlink" title="用模块管理函数"></a>用模块管理函数</h3><p>对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def foo():    print(&#39;hello, world!&#39;)def foo():    print(&#39;goodbye, world!&#39;)# 下面的代码会输出什么呢？foo()</code></pre><p>当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为<code>foo</code>的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过<code>import</code>关键字导入指定的模块就可以区分到底要使用的是哪个模块中的<code>foo</code>函数，代码如下所示。</p><p><code>module1.py</code></p><pre class="language-Python" data-language="Python"><code class="language-Python">def foo():    print(&#39;hello, world!&#39;)</code></pre><p><code>module2.py</code></p><pre class="language-Python" data-language="Python"><code class="language-Python">def foo():    print(&#39;goodbye, world!&#39;)</code></pre><p><code>test.py</code></p><pre class="language-Python" data-language="Python"><code class="language-Python">from module1 import foo# 输出hello, world!foo()from module2 import foo# 输出goodbye, world!foo()</code></pre><p>也可以按照如下所示的方式来区分到底要使用哪一个<code>foo</code>函数。</p><p><code>test.py</code></p><pre class="language-Python" data-language="Python"><code class="language-Python">import module1 as m1import module2 as m2m1.foo()m2.foo()</code></pre><p>但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个<code>foo</code>，因为后导入的foo覆盖了之前导入的<code>foo</code>。</p><p><code>test.py</code></p><pre class="language-Python" data-language="Python"><code class="language-Python">from module1 import foofrom module2 import foo# 输出goodbye, world!foo()</code></pre><p><code>test.py</code></p><pre class="language-Python" data-language="Python"><code class="language-Python">from module2 import foofrom module1 import foo# 输出hello, world!foo()</code></pre><p>需要说明的是，如果我们导入的模块除了定义函数之外还有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是&quot;__main__&quot;。</p><p><code>module3.py</code></p><pre class="language-Python" data-language="Python"><code class="language-Python">def foo():    passdef bar():    pass# __name__是Python中一个隐含的变量它代表了模块的名字# 只有被Python解释器直接执行的模块的名字才是__main__if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    print(&#39;call foo()&#39;)    foo()    print(&#39;call bar()&#39;)    bar()</code></pre><p><code>test.py</code></p><pre class="language-Python" data-language="Python"><code class="language-Python">import module3# 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：实现计算求最大公约数和最小公倍数的函数。"><a href="#练习1：实现计算求最大公约数和最小公倍数的函数。" class="headerlink" title="练习1：实现计算求最大公约数和最小公倍数的函数。"></a>练习1：实现计算求最大公约数和最小公倍数的函数。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">def gcd(x, y):    &quot;&quot;&quot;求最大公约数&quot;&quot;&quot;    (x, y) &#x3D; (y, x) if x &gt; y else (x, y)    for factor in range(x, 0, -1):        if x % factor &#x3D;&#x3D; 0 and y % factor &#x3D;&#x3D; 0:            return factordef lcm(x, y):    &quot;&quot;&quot;求最小公倍数&quot;&quot;&quot;    return x * y &#x2F;&#x2F; gcd(x, y)</code></pre><h4 id="练习2：实现判断一个数是不是回文数的函数。"><a href="#练习2：实现判断一个数是不是回文数的函数。" class="headerlink" title="练习2：实现判断一个数是不是回文数的函数。"></a>练习2：实现判断一个数是不是回文数的函数。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">def is_palindrome(num):    &quot;&quot;&quot;判断一个数是不是回文数&quot;&quot;&quot;    temp &#x3D; num    total &#x3D; 0    while temp &gt; 0:        total &#x3D; total * 10 + temp % 10        temp &#x2F;&#x2F;&#x3D; 10    return total &#x3D;&#x3D; num</code></pre><h4 id="练习3：实现判断一个数是不是素数的函数。"><a href="#练习3：实现判断一个数是不是素数的函数。" class="headerlink" title="练习3：实现判断一个数是不是素数的函数。"></a>练习3：实现判断一个数是不是素数的函数。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">def is_prime(num):    &quot;&quot;&quot;判断一个数是不是素数&quot;&quot;&quot;    for factor in range(2, int(num ** 0.5) + 1):        if num % factor &#x3D;&#x3D; 0:            return False    return True if num !&#x3D; 1 else False</code></pre><h4 id="练习4：写一个程序判断输入的正整数是不是回文素数。"><a href="#练习4：写一个程序判断输入的正整数是不是回文素数。" class="headerlink" title="练习4：写一个程序判断输入的正整数是不是回文素数。"></a>练习4：写一个程序判断输入的正整数是不是回文素数。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    num &#x3D; int(input(&#39;请输入正整数: &#39;))    if is_palindrome(num) and is_prime(num):        print(&#39;%d是回文素数&#39; % num)</code></pre><blockquote><p><strong>注意</strong>：通过上面的程序可以看出，当我们<strong>将代码中重复出现的和相对独立的功能抽取成函数</strong>后，我们可以<strong>组合使用这些函数</strong>来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。</p></blockquote><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>最后，我们来讨论一下Python中有关变量作用域的问题。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def foo():    b &#x3D; &#39;hello&#39;    # Python中可以在函数内部再定义函数    def bar():        c &#x3D; True        print(a)        print(b)        print(c)    bar()    # print(c)  # NameError: name &#39;c&#39; is not definedif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    a &#x3D; 100    # print(b)  # NameError: name &#39;b&#39; is not defined    foo()</code></pre><p>上面的代码能够顺利的执行并且打印出100、hello和True，但我们注意到了，在<code>bar</code>函数的内部并没有定义<code>a</code>和<code>b</code>两个变量，那么<code>a</code>和<code>b</code>是从哪里来的。我们在上面代码的<code>if</code>分支中定义了一个变量<code>a</code>，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的<code>foo</code>函数中我们定义了变量<code>b</code>，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在<code>foo</code>函数的外部并不能访问到它；但对于<code>foo</code>函数内部的<code>bar</code>函数来说，变量<code>b</code>属于嵌套作用域，在<code>bar</code>函数中我们是可以访问到它的。<code>bar</code>函数中的变量<code>c</code>属于局部作用域，在<code>bar</code>函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些标识符，我们之前用过的<code>input</code>、<code>print</code>、<code>int</code>等都属于内置作用域。</p><p>再看看下面这段代码，我们希望通过函数调用修改全局变量<code>a</code>的值，但实际上下面的代码是做不到的。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def foo():    a &#x3D; 200    print(a)  # 200if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    a &#x3D; 100    foo()    print(a)  # 100</code></pre><p>在调用<code>foo</code>函数后，我们发现<code>a</code>的值仍然是100，这是因为当我们在函数<code>foo</code>中写<code>a = 200</code>的时候，是重新定义了一个名字为<code>a</code>的局部变量，它跟全局作用域的<code>a</code>并不是同一个变量，因为局部作用域中有了自己的变量<code>a</code>，因此<code>foo</code>函数不再搜索全局作用域中的<code>a</code>。如果我们希望在<code>foo</code>函数中修改全局作用域中的<code>a</code>，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def foo():    global a    a &#x3D; 200    print(a)  # 200if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    a &#x3D; 100    foo()    print(a)  # 200</code></pre><p>我们可以使用<code>global</code>关键字来指示<code>foo</code>函数中的变量<code>a</code>来自于全局作用域，如果全局作用域中没有<code>a</code>，那么下面一行的代码就会定义变量<code>a</code>并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用<code>nonlocal</code>关键字来指示变量来自于嵌套作用域，请大家自行试验。</p><p>在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">垃圾回收</a>。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对<a href="https://zh.wikipedia.org/zh-hans/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B">迪米特法则</a>的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在定义它的函数调用结束后依然可以使用它的值，这时候就需要使用<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">闭包</a>，这个我们在后续的内容中进行讲解。</p><blockquote><p><strong>说明：</strong> 很多人经常会将“闭包”和<a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">“匿名函数”</a>混为一谈，但实际上它们并不是一回事，如果想了解这个概念，可以看看<a href="https://zh.wikipedia.org/wiki/">维基百科</a>的解释或者<a href="https://www.zhihu.com/">知乎</a>上对这个概念的讨论。</p></blockquote><p>说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def main():    # Todo: Add your code here    passif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;函数和模块的使用&quot;&gt;&lt;a href=&quot;#函数和模块的使用&quot; class=&quot;headerlink&quot; title=&quot;函数和模块的使用&quot;&gt;&lt;/a&gt;函数和模块的使用&lt;/h2&gt;&lt;p&gt;在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>07.字符串和常用数据结构</title>
    <link href="http://wstcly.xyz/2024/07/01/07.zi-fu-chuan-he-chang-yong-shu-ju-jie-gou/"/>
    <id>http://wstcly.xyz/2024/07/01/07.zi-fu-chuan-he-chang-yong-shu-ju-jie-gou/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:02.203Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串和常用数据结构"><a href="#字符串和常用数据结构" class="headerlink" title="字符串和常用数据结构"></a>字符串和常用数据结构</h2><h3 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h3><p>第二次世界大战促使了现代电子计算机的诞生，最初计算机被应用于导弹弹道的计算，而在计算机诞生后的很多年时间里，计算机处理的信息基本上都是数值型的信息。世界上的第一台电子计算机叫ENIAC（电子数值积分计算机），诞生于美国的宾夕法尼亚大学，每秒钟能够完成约5000次浮点运算。随着时间的推移，虽然数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机处理得更多的数据可能都是以文本的方式存在的，如果我们希望通过Python程序操作这些文本信息，就必须要先了解字符串类型以及与它相关的知识。</p><p>所谓<strong>字符串</strong>，就是由零个或多个字符组成的有限序列，一般记为<img src="/./res/formula_5.png" alt="$${\displaystyle s=a_{1}a_{2}\dots a_{n}(0\leq n \leq \infty)}$$">。在Python程序中，如果我们把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。</p><pre class="language-Python" data-language="Python"><code class="language-Python">s1 &#x3D; &#39;hello, world!&#39;s2 &#x3D; &quot;hello, world!&quot;# 以三个双引号或单引号开头的字符串可以折行s3 &#x3D; &quot;&quot;&quot;hello, world!&quot;&quot;&quot;print(s1, s2, s3, end&#x3D;&#39;&#39;)</code></pre><p>可以在字符串中使用<code>\</code>（反斜杠）来表示转义，也就是说<code>\</code>后面的字符不再是它原来的意义，例如：<code>\n</code>不是代表反斜杠和字符n，而是表示换行；而<code>\t</code>也不是代表反斜杠和字符t，而是表示制表符。所以如果想在字符串中表示<code>&#39;</code>要写成<code>\&#39;</code>，同理想表示<code>\</code>要写成<code>\\</code>。可以运行下面的代码看看会输出什么。</p><pre class="language-Python" data-language="Python"><code class="language-Python">s1 &#x3D; &#39;\&#39;hello, world!\&#39;&#39;s2 &#x3D; &#39;\n\\hello, world!\\\n&#39;print(s1, s2, end&#x3D;&#39;&#39;)</code></pre><p>在<code>\</code>后面还可以跟一个八进制或者十六进制数来表示字符，例如<code>\141</code>和<code>\x61</code>都代表小写字母<code>a</code>，前者是八进制的表示法，后者是十六进制的表示法。也可以在<code>\</code>后面跟Unicode字符编码来表示字符，例如<code>\u9a86\u660a</code>代表的是中文“骆昊”。运行下面的代码，看看输出了什么。</p><pre class="language-Python" data-language="Python"><code class="language-Python">s1 &#x3D; &#39;\141\142\143\x61\x62\x63&#39;s2 &#x3D; &#39;\u9a86\u660a&#39;print(s1, s2)</code></pre><p>如果不希望字符串中的<code>\</code>表示转义，我们可以通过在字符串的最前面加上字母<code>r</code>来加以说明，再看看下面的代码又会输出什么。</p><pre class="language-Python" data-language="Python"><code class="language-Python">s1 &#x3D; r&#39;\&#39;hello, world!\&#39;&#39;s2 &#x3D; r&#39;\n\\hello, world!\\\n&#39;print(s1, s2, end&#x3D;&#39;&#39;)</code></pre><p>Python为字符串类型提供了非常丰富的运算符，我们可以使用<code>+</code>运算符来实现字符串的拼接，可以使用<code>*</code>运算符来重复一个字符串的内容，可以使用<code>in</code>和<code>not in</code>来判断一个字符串是否包含另外一个字符串（成员运算），我们也可以用<code>[]</code>和<code>[:]</code>运算符从字符串取出某个字符或某些字符（切片运算），代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">s1 &#x3D; &#39;hello &#39; * 3print(s1) # hello hello hello s2 &#x3D; &#39;world&#39;s1 +&#x3D; s2print(s1) # hello hello hello worldprint(&#39;ll&#39; in s1) # Trueprint(&#39;good&#39; in s1) # Falsestr2 &#x3D; &#39;abc123456&#39;# 从字符串中取出指定位置的字符(下标运算)print(str2[2]) # c# 字符串切片(从指定的开始索引到指定的结束索引)print(str2[2:5]) # c12print(str2[2:]) # c123456print(str2[2::2]) # c246print(str2[::2]) # ac246print(str2[::-1]) # 654321cbaprint(str2[-3:-1]) # 45</code></pre><p>在Python中，我们还可以通过一系列的方法来完成对字符串的处理，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">str1 &#x3D; &#39;hello, world!&#39;# 通过内置函数len计算字符串的长度print(len(str1)) # 13# 获得字符串首字母大写的拷贝print(str1.capitalize()) # Hello, world!# 获得字符串每个单词首字母大写的拷贝print(str1.title()) # Hello, World!# 获得字符串变大写后的拷贝print(str1.upper()) # HELLO, WORLD!# 从字符串中查找子串所在位置print(str1.find(&#39;or&#39;)) # 8print(str1.find(&#39;shit&#39;)) # -1# 与find类似但找不到子串时会引发异常# print(str1.index(&#39;or&#39;))# print(str1.index(&#39;shit&#39;))# 检查字符串是否以指定的字符串开头print(str1.startswith(&#39;He&#39;)) # Falseprint(str1.startswith(&#39;hel&#39;)) # True# 检查字符串是否以指定的字符串结尾print(str1.endswith(&#39;!&#39;)) # True# 将字符串以指定的宽度居中并在两侧填充指定的字符print(str1.center(50, &#39;*&#39;))# 将字符串以指定的宽度靠右放置左侧填充指定的字符print(str1.rjust(50, &#39; &#39;))str2 &#x3D; &#39;abc123456&#39;# 检查字符串是否由数字构成print(str2.isdigit())  # False# 检查字符串是否以字母构成print(str2.isalpha())  # False# 检查字符串是否以数字和字母构成print(str2.isalnum())  # Truestr3 &#x3D; &#39;  jackfrued@126.com &#39;print(str3)# 获得字符串修剪左右两侧空格之后的拷贝print(str3.strip())</code></pre><p>我们之前讲过，可以用下面的方式来格式化输出字符串。</p><pre class="language-Python" data-language="Python"><code class="language-Python">a, b &#x3D; 5, 10print(&#39;%d * %d &#x3D; %d&#39; % (a, b, a * b))</code></pre><p>当然，我们也可以用字符串提供的方法来完成字符串的格式，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">a, b &#x3D; 5, 10print(&#39;&#123;0&#125; * &#123;1&#125; &#x3D; &#123;2&#125;&#39;.format(a, b, a * b))</code></pre><p>Python 3.6以后，格式化字符串还有更为简洁的书写方式，就是在字符串前加上字母<code>f</code>，我们可以使用下面的语法糖来简化上面的代码。</p><pre class="language-Python" data-language="Python"><code class="language-Python">a, b &#x3D; 5, 10print(f&#39;&#123;a&#125; * &#123;b&#125; &#x3D; &#123;a * b&#125;&#39;)</code></pre><p>除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。</p><h3 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h3><p>不知道大家是否注意到，刚才我们讲到的字符串类型（<code>str</code>）和之前我们讲到的数值类型（<code>int</code>和<code>float</code>）有一些区别。数值类型是标量类型，也就是说这种类型的对象没有可以访问的内部结构；而字符串类型是一种结构化的、非标量类型，所以才会有一系列的属性和方法。接下来我们要介绍的列表（<code>list</code>），也是一种结构化的、非标量类型，它是值的有序序列，每个值都可以通过索引进行标识，定义列表可以将列表的元素放在<code>[]</code>中，多个元素用<code>,</code>进行分隔，可以使用<code>for</code>循环对列表元素进行遍历，也可以使用<code>[]</code>或<code>[:]</code>运算符取出列表中的一个或多个元素。</p><p>下面的代码演示了如何定义列表、如何遍历列表以及列表的下标运算。</p><pre class="language-Python" data-language="Python"><code class="language-Python">list1 &#x3D; [1, 3, 5, 7, 100]print(list1) # [1, 3, 5, 7, 100]# 乘号表示列表元素的重复list2 &#x3D; [&#39;hello&#39;] * 3print(list2) # [&#39;hello&#39;, &#39;hello&#39;, &#39;hello&#39;]# 计算列表长度(元素个数)print(len(list1)) # 5# 下标(索引)运算print(list1[0]) # 1print(list1[4]) # 100# print(list1[5])  # IndexError: list index out of rangeprint(list1[-1]) # 100print(list1[-3]) # 5list1[2] &#x3D; 300print(list1) # [1, 3, 300, 7, 100]# 通过循环用下标遍历列表元素for index in range(len(list1)):    print(list1[index])# 通过for循环遍历列表元素for elem in list1:    print(elem)# 通过enumerate函数处理列表之后再遍历可以同时获得元素索引和值for index, elem in enumerate(list1):    print(index, elem)</code></pre><p>下面的代码演示了如何向列表中添加元素以及如何从列表中移除元素。</p><pre class="language-Python" data-language="Python"><code class="language-Python">list1 &#x3D; [1, 3, 5, 7, 100]# 添加元素list1.append(200)list1.insert(1, 400)# 合并两个列表# list1.extend([1000, 2000])list1 +&#x3D; [1000, 2000]print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]print(len(list1)) # 9# 先通过成员运算判断元素是否在列表中，如果存在就删除该元素if 3 in list1:list1.remove(3)if 1234 in list1:    list1.remove(1234)print(list1) # [1, 400, 5, 7, 100, 200, 1000, 2000]# 从指定的位置删除元素list1.pop(0)list1.pop(len(list1) - 1)print(list1) # [400, 5, 7, 100, 200, 1000]# 清空列表元素list1.clear()print(list1) # []</code></pre><p>和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">fruits &#x3D; [&#39;grape&#39;, &#39;apple&#39;, &#39;strawberry&#39;, &#39;waxberry&#39;]fruits +&#x3D; [&#39;pitaya&#39;, &#39;pear&#39;, &#39;mango&#39;]# 列表切片fruits2 &#x3D; fruits[1:4]print(fruits2) # apple strawberry waxberry# 可以通过完整切片操作来复制列表fruits3 &#x3D; fruits[:]print(fruits3) # [&#39;grape&#39;, &#39;apple&#39;, &#39;strawberry&#39;, &#39;waxberry&#39;, &#39;pitaya&#39;, &#39;pear&#39;, &#39;mango&#39;]fruits4 &#x3D; fruits[-3:-1]print(fruits4) # [&#39;pitaya&#39;, &#39;pear&#39;]# 可以通过反向切片操作来获得倒转后的列表的拷贝fruits5 &#x3D; fruits[::-1]print(fruits5) # [&#39;mango&#39;, &#39;pear&#39;, &#39;pitaya&#39;, &#39;waxberry&#39;, &#39;strawberry&#39;, &#39;apple&#39;, &#39;grape&#39;]</code></pre><p>下面的代码实现了对列表的排序操作。</p><pre class="language-Python" data-language="Python"><code class="language-Python">list1 &#x3D; [&#39;orange&#39;, &#39;apple&#39;, &#39;zoo&#39;, &#39;internationalization&#39;, &#39;blueberry&#39;]list2 &#x3D; sorted(list1)# sorted函数返回列表排序后的拷贝不会修改传入的列表# 函数的设计就应该像sorted函数一样尽可能不产生副作用list3 &#x3D; sorted(list1, reverse&#x3D;True)# 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序list4 &#x3D; sorted(list1, key&#x3D;len)print(list1)print(list2)print(list3)print(list4)# 给列表对象发出排序消息直接在列表对象上进行排序list1.sort(reverse&#x3D;True)print(list1)</code></pre><h3 id="生成式和生成器"><a href="#生成式和生成器" class="headerlink" title="生成式和生成器"></a>生成式和生成器</h3><p>我们还可以使用列表的生成式语法来创建列表，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">f &#x3D; [x for x in range(1, 10)]print(f)f &#x3D; [x + y for x in &#39;ABCDE&#39; for y in &#39;1234567&#39;]print(f)# 用列表的生成表达式语法创建列表容器# 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间f &#x3D; [x ** 2 for x in range(1, 1000)]print(sys.getsizeof(f))  # 查看对象占用内存的字节数print(f)# 请注意下面的代码创建的不是一个列表而是一个生成器对象# 通过生成器可以获取到数据但它不占用额外的空间存储数据# 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)f &#x3D; (x ** 2 for x in range(1, 1000))print(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间print(f)for val in f:    print(val)</code></pre><p>除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过<code>yield</code>关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波拉切数列</a>的生成器。所谓斐波拉切数列可以通过下面<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92">递归</a>的方法来进行定义：</p><p><img src="/./res/formula_6.png" alt="$${\displaystyle F_{0}=0}$$"></p><p><img src="/./res/formula_7.png" alt="$${\displaystyle F_{1}=1}$$"></p><p><img src="/./res/formula_8.png" alt="$${\displaystyle F_{n}=F_{n-1}+F_{n-2}}({n}\geq{2})$$"></p><p><img src="/./res/fibonacci-blocks.png"></p><pre class="language-Python" data-language="Python"><code class="language-Python">def fib(n):    a, b &#x3D; 0, 1    for _ in range(n):        a, b &#x3D; b, a + b        yield adef main():    for val in fib(20):        print(val)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h3 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h3><p>Python中的元组与列表类似也是一种容器数据类型，可以用一个变量（对象）来存储多个数据，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。</p><pre class="language-Python" data-language="Python"><code class="language-Python"># 定义元组t &#x3D; (&#39;骆昊&#39;, 38, True, &#39;四川成都&#39;)print(t)# 获取元组中的元素print(t[0])print(t[3])# 遍历元组中的值for member in t:    print(member)# 重新给元组赋值# t[0] &#x3D; &#39;王大锤&#39;  # TypeError# 变量t重新引用了新的元组原来的元组将被垃圾回收t &#x3D; (&#39;王大锤&#39;, 20, True, &#39;云南昆明&#39;)print(t)# 将元组转换成列表person &#x3D; list(t)print(person)# 列表是可以修改它的元素的person[0] &#x3D; &#39;李小龙&#39;person[1] &#x3D; 25print(person)# 将列表转换成元组fruits_list &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;]fruits_tuple &#x3D; tuple(fruits_list)print(fruits_tuple)</code></pre><p>这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？</p><ol><li>元组中的元素是无法修改的，事实上我们在项目中尤其是<a href="https://zh.wikipedia.org/zh-hans/%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a>环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。</li><li>元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间，下图是我的macOS系统上测试的结果。</li></ol><p><img src="/./res/ipython-timeit.png"></p><h3 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h3><p>Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。</p><p><img src="/./res/python-set.png"></p><p>可以按照下面代码所示的方式来创建和使用集合。</p><pre class="language-Python" data-language="Python"><code class="language-Python"># 创建集合的字面量语法set1 &#x3D; &#123;1, 2, 3, 3, 3, 2&#125;print(set1)print(&#39;Length &#x3D;&#39;, len(set1))# 创建集合的构造器语法(面向对象部分会进行详细讲解)set2 &#x3D; set(range(1, 10))set3 &#x3D; set((1, 2, 3, 3, 2, 1))print(set2, set3)# 创建集合的推导式语法(推导式也可以用于推导集合)set4 &#x3D; &#123;num for num in range(1, 100) if num % 3 &#x3D;&#x3D; 0 or num % 5 &#x3D;&#x3D; 0&#125;print(set4)</code></pre><p>向集合添加元素和从集合删除元素。</p><pre class="language-Python" data-language="Python"><code class="language-Python">set1.add(4)set1.add(5)set2.update([11, 12])set2.discard(5)if 4 in set2:    set2.remove(4)print(set1, set2)print(set3.pop())print(set3)</code></pre><p>集合的成员、交集、并集、差集等运算。</p><pre class="language-Python" data-language="Python"><code class="language-Python"># 集合的交集、并集、差集、对称差运算print(set1 &amp; set2)# print(set1.intersection(set2))print(set1 | set2)# print(set1.union(set2))print(set1 - set2)# print(set1.difference(set2))print(set1 ^ set2)# print(set1.symmetric_difference(set2))# 判断子集和超集print(set2 &lt;&#x3D; set1)# print(set2.issubset(set1))print(set3 &lt;&#x3D; set1)# print(set3.issubset(set1))print(set1 &gt;&#x3D; set2)# print(set1.issuperset(set2))print(set1 &gt;&#x3D; set3)# print(set1.issuperset(set3))</code></pre><blockquote><p><strong>说明：</strong> Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如<code>&amp;</code>运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。</p></blockquote><h3 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h3><p>字典是另一种可变容器模型，Python中的字典跟我们生活中使用的字典是一样一样的，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。</p><pre class="language-Python" data-language="Python"><code class="language-Python"># 创建字典的字面量语法scores &#x3D; &#123;&#39;骆昊&#39;: 95, &#39;白元芳&#39;: 78, &#39;狄仁杰&#39;: 82&#125;print(scores)# 创建字典的构造器语法items1 &#x3D; dict(one&#x3D;1, two&#x3D;2, three&#x3D;3, four&#x3D;4)# 通过zip函数将两个序列压成字典items2 &#x3D; dict(zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], &#39;123&#39;))# 创建字典的推导式语法items3 &#x3D; &#123;num: num ** 2 for num in range(1, 10)&#125;print(items1, items2, items3)# 通过键可以获取字典中对应的值print(scores[&#39;骆昊&#39;])print(scores[&#39;狄仁杰&#39;])# 对字典中所有键值对进行遍历for key in scores:    print(f&#39;&#123;key&#125;: &#123;scores[key]&#125;&#39;)# 更新字典中的元素scores[&#39;白元芳&#39;] &#x3D; 65scores[&#39;诸葛王朗&#39;] &#x3D; 71scores.update(冷面&#x3D;67, 方启鹤&#x3D;85)print(scores)if &#39;武则天&#39; in scores:    print(scores[&#39;武则天&#39;])print(scores.get(&#39;武则天&#39;))# get方法也是通过键获取对应的值但是可以设置默认值print(scores.get(&#39;武则天&#39;, 60))# 删除字典中的元素print(scores.popitem())print(scores.popitem())print(scores.pop(&#39;骆昊&#39;, 100))# 清空字典scores.clear()print(scores)</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：在屏幕上显示跑马灯文字。"><a href="#练习1：在屏幕上显示跑马灯文字。" class="headerlink" title="练习1：在屏幕上显示跑马灯文字。"></a>练习1：在屏幕上显示跑马灯文字。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">import osimport timedef main():    content &#x3D; &#39;北京欢迎你为你开天辟地…………&#39;    while True:        # 清理屏幕上的输出        os.system(&#39;cls&#39;)  # os.system(&#39;clear&#39;)        print(content)        # 休眠200毫秒        time.sleep(0.2)        content &#x3D; content[1:] + content[0]if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。"><a href="#练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。" class="headerlink" title="练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。"></a>练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">import randomdef generate_code(code_len&#x3D;4):    &quot;&quot;&quot;    生成指定长度的验证码    :param code_len: 验证码的长度(默认4个字符)    :return: 由大小写英文字母和数字构成的随机验证码    &quot;&quot;&quot;    all_chars &#x3D; &#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;    last_pos &#x3D; len(all_chars) - 1    code &#x3D; &#39;&#39;    for _ in range(code_len):        index &#x3D; random.randint(0, last_pos)        code +&#x3D; all_chars[index]    return code</code></pre><h4 id="练习3：设计一个函数返回给定文件名的后缀名。"><a href="#练习3：设计一个函数返回给定文件名的后缀名。" class="headerlink" title="练习3：设计一个函数返回给定文件名的后缀名。"></a>练习3：设计一个函数返回给定文件名的后缀名。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">def get_suffix(filename, has_dot&#x3D;False):    &quot;&quot;&quot;    获取文件名的后缀名    :param filename: 文件名    :param has_dot: 返回的后缀名是否需要带点    :return: 文件的后缀名    &quot;&quot;&quot;    pos &#x3D; filename.rfind(&#39;.&#39;)    if 0 &lt; pos &lt; len(filename) - 1:        index &#x3D; pos if has_dot else pos + 1        return filename[index:]    else:        return &#39;&#39;</code></pre><h4 id="练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。"><a href="#练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。" class="headerlink" title="练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。"></a>练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">def max2(x):    m1, m2 &#x3D; (x[0], x[1]) if x[0] &gt; x[1] else (x[1], x[0])    for index in range(2, len(x)):        if x[index] &gt; m1:            m2 &#x3D; m1            m1 &#x3D; x[index]        elif x[index] &gt; m2:            m2 &#x3D; x[index]    return m1, m2</code></pre><h4 id="练习5：计算指定的年月日是这一年的第几天。"><a href="#练习5：计算指定的年月日是这一年的第几天。" class="headerlink" title="练习5：计算指定的年月日是这一年的第几天。"></a>练习5：计算指定的年月日是这一年的第几天。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">def is_leap_year(year):    &quot;&quot;&quot;    判断指定的年份是不是闰年    :param year: 年份    :return: 闰年返回True平年返回False    &quot;&quot;&quot;    return year % 4 &#x3D;&#x3D; 0 and year % 100 !&#x3D; 0 or year % 400 &#x3D;&#x3D; 0def which_day(year, month, date):    &quot;&quot;&quot;    计算传入的日期是这一年的第几天    :param year: 年    :param month: 月    :param date: 日    :return: 第几天    &quot;&quot;&quot;    days_of_month &#x3D; [        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]    ][is_leap_year(year)]    total &#x3D; 0    for index in range(month - 1):        total +&#x3D; days_of_month[index]    return total + datedef main():    print(which_day(1980, 11, 28))    print(which_day(1981, 12, 31))    print(which_day(2018, 1, 1))    print(which_day(2016, 3, 1))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="练习6：打印杨辉三角。"><a href="#练习6：打印杨辉三角。" class="headerlink" title="练习6：打印杨辉三角。"></a>练习6：打印<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2">杨辉三角</a>。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">def main():    num &#x3D; int(input(&#39;Number of rows: &#39;))    yh &#x3D; [[]] * num    for row in range(len(yh)):        yh[row] &#x3D; [None] * (row + 1)        for col in range(len(yh[row])):            if col &#x3D;&#x3D; 0 or col &#x3D;&#x3D; row:                yh[row][col] &#x3D; 1            else:                yh[row][col] &#x3D; yh[row - 1][col] + yh[row - 1][col - 1]            print(yh[row][col], end&#x3D;&#39;\t&#39;)        print()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><h4 id="案例1：双色球选号。"><a href="#案例1：双色球选号。" class="headerlink" title="案例1：双色球选号。"></a>案例1：双色球选号。</h4><pre class="language-Python" data-language="Python"><code class="language-Python">from random import randrange, randint, sampledef display(balls):    &quot;&quot;&quot;    输出列表中的双色球号码    &quot;&quot;&quot;    for index, ball in enumerate(balls):        if index &#x3D;&#x3D; len(balls) - 1:            print(&#39;|&#39;, end&#x3D;&#39; &#39;)        print(&#39;%02d&#39; % ball, end&#x3D;&#39; &#39;)    print()def random_select():    &quot;&quot;&quot;    随机选择一组号码    &quot;&quot;&quot;    red_balls &#x3D; [x for x in range(1, 34)]    selected_balls &#x3D; []    selected_balls &#x3D; sample(red_balls, 6)    selected_balls.sort()    selected_balls.append(randint(1, 16))    return selected_ballsdef main():    n &#x3D; int(input(&#39;机选几注: &#39;))    for _ in range(n):        display(random_select())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明：</strong> 上面使用random模块的sample函数来实现从列表中选择不重复的n个元素。</p></blockquote><h4 id="综合案例2：约瑟夫环问题。"><a href="#综合案例2：约瑟夫环问题。" class="headerlink" title="综合案例2：约瑟夫环问题。"></a>综合案例2：<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98">约瑟夫环问题</a>。</h4><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;《幸运的基督徒》有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。&quot;&quot;&quot;def main():    persons &#x3D; [True] * 30    counter, index, number &#x3D; 0, 0, 0    while counter &lt; 15:        if persons[index]:            number +&#x3D; 1            if number &#x3D;&#x3D; 9:                persons[index] &#x3D; False                counter +&#x3D; 1                number &#x3D; 0        index +&#x3D; 1        index %&#x3D; 30    for person in persons:        print(&#39;基&#39; if person else &#39;非&#39;, end&#x3D;&#39;&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="综合案例3：井字棋游戏。"><a href="#综合案例3：井字棋游戏。" class="headerlink" title="综合案例3：井字棋游戏。"></a>综合案例3：<a href="https://zh.wikipedia.org/wiki/%E4%BA%95%E5%AD%97%E6%A3%8B">井字棋</a>游戏。</h4><pre class="language-Python" data-language="Python"><code class="language-Python">import osdef print_board(board):    print(board[&#39;TL&#39;] + &#39;|&#39; + board[&#39;TM&#39;] + &#39;|&#39; + board[&#39;TR&#39;])    print(&#39;-+-+-&#39;)    print(board[&#39;ML&#39;] + &#39;|&#39; + board[&#39;MM&#39;] + &#39;|&#39; + board[&#39;MR&#39;])    print(&#39;-+-+-&#39;)    print(board[&#39;BL&#39;] + &#39;|&#39; + board[&#39;BM&#39;] + &#39;|&#39; + board[&#39;BR&#39;])def main():    init_board &#x3D; &#123;        &#39;TL&#39;: &#39; &#39;, &#39;TM&#39;: &#39; &#39;, &#39;TR&#39;: &#39; &#39;,        &#39;ML&#39;: &#39; &#39;, &#39;MM&#39;: &#39; &#39;, &#39;MR&#39;: &#39; &#39;,        &#39;BL&#39;: &#39; &#39;, &#39;BM&#39;: &#39; &#39;, &#39;BR&#39;: &#39; &#39;    &#125;    begin &#x3D; True    while begin:        curr_board &#x3D; init_board.copy()        begin &#x3D; False        turn &#x3D; &#39;x&#39;        counter &#x3D; 0        os.system(&#39;clear&#39;)        print_board(curr_board)        while counter &lt; 9:            move &#x3D; input(&#39;轮到%s走棋, 请输入位置: &#39; % turn)            if curr_board[move] &#x3D;&#x3D; &#39; &#39;:                counter +&#x3D; 1                curr_board[move] &#x3D; turn                if turn &#x3D;&#x3D; &#39;x&#39;:                    turn &#x3D; &#39;o&#39;                else:                    turn &#x3D; &#39;x&#39;            os.system(&#39;clear&#39;)            print_board(curr_board)        choice &#x3D; input(&#39;再玩一局?(yes|no)&#39;)        begin &#x3D; choice &#x3D;&#x3D; &#39;yes&#39;if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明：</strong> 最后这个案例来自<a href="https://item.jd.com/11943853.html">《Python编程快速上手:让繁琐工作自动化》</a>一书（这本书对有编程基础想迅速使用Python将日常工作自动化的人来说还是不错的选择），对代码做了一点点的调整。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符串和常用数据结构&quot;&gt;&lt;a href=&quot;#字符串和常用数据结构&quot; class=&quot;headerlink&quot; title=&quot;字符串和常用数据结构&quot;&gt;&lt;/a&gt;字符串和常用数据结构&lt;/h2&gt;&lt;h3 id=&quot;使用字符串&quot;&gt;&lt;a href=&quot;#使用字符串&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>08.面向对象编程基础</title>
    <link href="http://wstcly.xyz/2024/07/01/08.mian-xiang-dui-xiang-bian-cheng-ji-chu/"/>
    <id>http://wstcly.xyz/2024/07/01/08.mian-xiang-dui-xiang-bian-cheng-ji-chu/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:02.983Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h2><p>活在当下的程序员应该都听过&quot;面向对象编程&quot;一词，也经常有人问能不能用一句话解释下什么是&quot;面向对象编程&quot;，我们先来看看比较正式的说法。</p><p>&quot;把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。&quot;</p><p>这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于<a href="https://www.zhihu.com/">知乎</a>。</p><p><img src="/./res/oop-zhihu.png"></p><blockquote><p><strong>说明：</strong> 以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。</p></blockquote><p>之前我们说过&quot;<strong>程序是指令的集合</strong>&quot;，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，&quot;每个人都应该学习编程&quot;这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，&quot;<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA">软件危机</a>&quot;、&quot;<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">软件工程</a>&quot;等一系列的概念开始在行业中出现。</p><p>当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的&quot;<a href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9">银弹</a>&quot;，真正让软件开发者看到希望的是上世纪70年代诞生的<a href="https://zh.wikipedia.org/wiki/Smalltalk">Smalltalk</a>编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的<a href="https://zh.wikipedia.org/wiki/Simula">Simula</a>语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。</p><blockquote><p><strong>说明：</strong> 当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python也不例外。</p></blockquote><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。</p><p><img src="/./res/object-feature.png"></p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>在Python中可以使用<code>class</code>关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">class Student(object):    # __init__是一个特殊方法用于在创建对象时进行初始化操作    # 通过这个方法我们可以为学生对象绑定name和age两个属性    def __init__(self, name, age):        self.name &#x3D; name        self.age &#x3D; age    def study(self, course_name):        print(&#39;%s正在学习%s.&#39; % (self.name, course_name))    # PEP 8要求标识符的名字用全小写多个单词用下划线连接    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)    def watch_movie(self):        if self.age &lt; 18:            print(&#39;%s只能观看《熊出没》.&#39; % self.name)        else:            print(&#39;%s正在观看岛国爱情大电影.&#39; % self.name)</code></pre><blockquote><p><strong>说明：</strong> 写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。</p></blockquote><h3 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h3><p>当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def main():    # 创建学生对象并指定姓名和年龄    stu1 &#x3D; Student(&#39;骆昊&#39;, 38)    # 给对象发study消息    stu1.study(&#39;Python程序设计&#39;)    # 给对象发watch_av消息    stu1.watch_movie()    stu2 &#x3D; Student(&#39;王大锤&#39;, 15)    stu2.study(&#39;思想品德&#39;)    stu2.watch_movie()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h3 id="访问可见性问题"><a href="#访问可见性问题" class="headerlink" title="访问可见性问题"></a>访问可见性问题</h3><p>对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给<code>Student</code>对象绑定的<code>name</code>和<code>age</code>属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。</p><pre class="language-Python" data-language="Python"><code class="language-Python">class Test:    def __init__(self, foo):        self.__foo &#x3D; foo    def __bar(self):        print(self.__foo)        print(&#39;__bar&#39;)def main():    test &#x3D; Test(&#39;hello&#39;)    # AttributeError: &#39;Test&#39; object has no attribute &#39;__bar&#39;    test.__bar()    # AttributeError: &#39;Test&#39; object has no attribute &#39;__foo&#39;    print(test.__foo)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    main()</code></pre><p>但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是&quot;<strong>We are all consenting adults here</strong>&quot;。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。</p><pre class="language-Python" data-language="Python"><code class="language-Python">class Test:    def __init__(self, foo):        self.__foo &#x3D; foo    def __bar(self):        print(self.__foo)        print(&#39;__bar&#39;)def main():    test &#x3D; Test(&#39;hello&#39;)    test._Test__bar()    print(test._Test__foo)if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    main()</code></pre><p>在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的<a href="http://blog.csdn.net/jackfrued/article/details/79521404">《Python - 那些年我们踩过的那些坑》</a>文章中的讲解。</p><h3 id="面向对象的支柱"><a href="#面向对象的支柱" class="headerlink" title="面向对象的支柱"></a>面向对象的支柱</h3><p>面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是&quot;隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口&quot;。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：定义一个类描述数字时钟。"><a href="#练习1：定义一个类描述数字时钟。" class="headerlink" title="练习1：定义一个类描述数字时钟。"></a>练习1：定义一个类描述数字时钟。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">from time import sleepclass Clock(object):    &quot;&quot;&quot;数字时钟&quot;&quot;&quot;    def __init__(self, hour&#x3D;0, minute&#x3D;0, second&#x3D;0):        &quot;&quot;&quot;初始化方法        :param hour: 时        :param minute: 分        :param second: 秒        &quot;&quot;&quot;        self._hour &#x3D; hour        self._minute &#x3D; minute        self._second &#x3D; second    def run(self):        &quot;&quot;&quot;走字&quot;&quot;&quot;        self._second +&#x3D; 1        if self._second &#x3D;&#x3D; 60:            self._second &#x3D; 0            self._minute +&#x3D; 1            if self._minute &#x3D;&#x3D; 60:                self._minute &#x3D; 0                self._hour +&#x3D; 1                if self._hour &#x3D;&#x3D; 24:                    self._hour &#x3D; 0    def show(self):        &quot;&quot;&quot;显示时间&quot;&quot;&quot;        return &#39;%02d:%02d:%02d&#39; % \               (self._hour, self._minute, self._second)def main():    clock &#x3D; Clock(23, 59, 58)    while True:        print(clock.show())        sleep(1)        clock.run()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。"><a href="#练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。" class="headerlink" title="练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。"></a>练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。</h4><p>参考答案：</p><pre class="language-Python" data-language="Python"><code class="language-Python">from math import sqrtclass Point(object):    def __init__(self, x&#x3D;0, y&#x3D;0):        &quot;&quot;&quot;初始化方法                :param x: 横坐标        :param y: 纵坐标        &quot;&quot;&quot;        self.x &#x3D; x        self.y &#x3D; y    def move_to(self, x, y):        &quot;&quot;&quot;移动到指定位置                :param x: 新的横坐标        &quot;param y: 新的纵坐标        &quot;&quot;&quot;        self.x &#x3D; x        self.y &#x3D; y    def move_by(self, dx, dy):        &quot;&quot;&quot;移动指定的增量                :param dx: 横坐标的增量        &quot;param dy: 纵坐标的增量        &quot;&quot;&quot;        self.x +&#x3D; dx        self.y +&#x3D; dy    def distance_to(self, other):        &quot;&quot;&quot;计算与另一个点的距离                :param other: 另一个点        &quot;&quot;&quot;        dx &#x3D; self.x - other.x        dy &#x3D; self.y - other.y        return sqrt(dx ** 2 + dy ** 2)    def __str__(self):        return &#39;(%s, %s)&#39; % (str(self.x), str(self.y))def main():    p1 &#x3D; Point(3, 5)    p2 &#x3D; Point()    print(p1)    print(p2)    p2.move_by(-1, 2)    print(p2)    print(p1.distance_to(p2))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明：</strong> 本章中的插图来自于Grady Booch等著作的<a href="https://item.jd.com/20476561918.html">《面向对象分析与设计》</a>一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面向对象编程基础&quot;&gt;&lt;a href=&quot;#面向对象编程基础&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程基础&quot;&gt;&lt;/a&gt;面向对象编程基础&lt;/h2&gt;&lt;p&gt;活在当下的程序员应该都听过&amp;quot;面向对象编程&amp;quot;一词，也经常有人问能不能用一句</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>09.面向对象进阶</title>
    <link href="http://wstcly.xyz/2024/07/01/09.mian-xiang-dui-xiang-jin-jie/"/>
    <id>http://wstcly.xyz/2024/07/01/09.mian-xiang-dui-xiang-jin-jie/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:02.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h2><p>在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。</p><h3 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h3><p>之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">class Person(object):    def __init__(self, name, age):        self._name &#x3D; name        self._age &#x3D; age    # 访问器 - getter方法    @property    def name(self):        return self._name    # 访问器 - getter方法    @property    def age(self):        return self._age    # 修改器 - setter方法    @age.setter    def age(self, age):        self._age &#x3D; age    def play(self):        if self._age &lt;&#x3D; 16:            print(&#39;%s正在玩飞行棋.&#39; % self._name)        else:            print(&#39;%s正在玩斗地主.&#39; % self._name)def main():    person &#x3D; Person(&#39;王大锤&#39;, 12)    person.play()    person.age &#x3D; 22    person.play()    # person.name &#x3D; &#39;白元芳&#39;  # AttributeError: can&#39;t set attributeif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h3 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="__slots__魔法"></a>__slots__魔法</h3><p>我们讲到这里，不知道大家是否已经意识到，Python是一门<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80">动态语言</a>。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p><pre class="language-Python" data-language="Python"><code class="language-Python">class Person(object):    # 限定Person对象只能绑定_name, _age和_gender属性    __slots__ &#x3D; (&#39;_name&#39;, &#39;_age&#39;, &#39;_gender&#39;)    def __init__(self, name, age):        self._name &#x3D; name        self._age &#x3D; age    @property    def name(self):        return self._name    @property    def age(self):        return self._age    @age.setter    def age(self, age):        self._age &#x3D; age    def play(self):        if self._age &lt;&#x3D; 16:            print(&#39;%s正在玩飞行棋.&#39; % self._name)        else:            print(&#39;%s正在玩斗地主.&#39; % self._name)def main():    person &#x3D; Person(&#39;王大锤&#39;, 22)    person.play()    person._gender &#x3D; &#39;男&#39;    # AttributeError: &#39;Person&#39; object has no attribute &#39;_is_gay&#39;    # person._is_gay &#x3D; True</code></pre><h3 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h3><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from math import sqrtclass Triangle(object):    def __init__(self, a, b, c):        self._a &#x3D; a        self._b &#x3D; b        self._c &#x3D; c    @staticmethod    def is_valid(a, b, c):        return a + b &gt; c and b + c &gt; a and a + c &gt; b    def perimeter(self):        return self._a + self._b + self._c    def area(self):        half &#x3D; self.perimeter() &#x2F; 2        return sqrt(half * (half - self._a) *                    (half - self._b) * (half - self._c))def main():    a, b, c &#x3D; 3, 4, 5    # 静态方法和类方法都是通过给类发消息来调用的    if Triangle.is_valid(a, b, c):        t &#x3D; Triangle(a, b, c)        print(t.perimeter())        # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数        # print(Triangle.perimeter(t))        print(t.area())        # print(Triangle.area(t))    else:        print(&#39;无法构成三角形.&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from time import time, localtime, sleepclass Clock(object):    &quot;&quot;&quot;数字时钟&quot;&quot;&quot;    def __init__(self, hour&#x3D;0, minute&#x3D;0, second&#x3D;0):        self._hour &#x3D; hour        self._minute &#x3D; minute        self._second &#x3D; second    @classmethod    def now(cls):        ctime &#x3D; localtime(time())        return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)    def run(self):        &quot;&quot;&quot;走字&quot;&quot;&quot;        self._second +&#x3D; 1        if self._second &#x3D;&#x3D; 60:            self._second &#x3D; 0            self._minute +&#x3D; 1            if self._minute &#x3D;&#x3D; 60:                self._minute &#x3D; 0                self._hour +&#x3D; 1                if self._hour &#x3D;&#x3D; 24:                    self._hour &#x3D; 0    def show(self):        &quot;&quot;&quot;显示时间&quot;&quot;&quot;        return &#39;%02d:%02d:%02d&#39; % \               (self._hour, self._minute, self._second)def main():    # 通过类方法创建对象并获取系统时间    clock &#x3D; Clock.now()    while True:        print(clock.show())        sleep(1)        clock.run()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。</p><ul><li>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li><li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li><li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li></ul><p>我们可以使用一种叫做<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80">UML</a>（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读<a href="https://e.jd.com/30392949.html">《UML面向对象设计基础》</a>一书。</p><p><img src="/./res/uml-components.png"></p><p><img src="/./res/uml-example.png"></p><p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。</p><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p>刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为<a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99">里氏替换原则</a>。下面我们先看一个继承的例子。</p><pre class="language-Python" data-language="Python"><code class="language-Python">class Person(object):    &quot;&quot;&quot;人&quot;&quot;&quot;    def __init__(self, name, age):        self._name &#x3D; name        self._age &#x3D; age    @property    def name(self):        return self._name    @property    def age(self):        return self._age    @age.setter    def age(self, age):        self._age &#x3D; age    def play(self):        print(&#39;%s正在愉快的玩耍.&#39; % self._name)    def watch_av(self):        if self._age &gt;&#x3D; 18:            print(&#39;%s正在观看爱情动作片.&#39; % self._name)        else:            print(&#39;%s只能观看《熊出没》.&#39; % self._name)class Student(Person):    &quot;&quot;&quot;学生&quot;&quot;&quot;    def __init__(self, name, age, grade):        super().__init__(name, age)        self._grade &#x3D; grade    @property    def grade(self):        return self._grade    @grade.setter    def grade(self, grade):        self._grade &#x3D; grade    def study(self, course):        print(&#39;%s的%s正在学习%s.&#39; % (self._grade, self._name, course))class Teacher(Person):    &quot;&quot;&quot;老师&quot;&quot;&quot;    def __init__(self, name, age, title):        super().__init__(name, age)        self._title &#x3D; title    @property    def title(self):        return self._title    @title.setter    def title(self, title):        self._title &#x3D; title    def teach(self, course):        print(&#39;%s%s正在讲%s.&#39; % (self._name, self._title, course))def main():    stu &#x3D; Student(&#39;王大锤&#39;, 15, &#39;初三&#39;)    stu.study(&#39;数学&#39;)    stu.watch_av()    t &#x3D; Teacher(&#39;骆昊&#39;, 38, &#39;砖家&#39;)    t.teach(&#39;Python程序设计&#39;)    t.watch_av()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from abc import ABCMeta, abstractmethodclass Pet(object, metaclass&#x3D;ABCMeta):    &quot;&quot;&quot;宠物&quot;&quot;&quot;    def __init__(self, nickname):        self._nickname &#x3D; nickname    @abstractmethod    def make_voice(self):        &quot;&quot;&quot;发出声音&quot;&quot;&quot;        passclass Dog(Pet):    &quot;&quot;&quot;狗&quot;&quot;&quot;    def make_voice(self):        print(&#39;%s: 汪汪汪...&#39; % self._nickname)class Cat(Pet):    &quot;&quot;&quot;猫&quot;&quot;&quot;    def make_voice(self):        print(&#39;%s: 喵...喵...&#39; % self._nickname)def main():    pets &#x3D; [Dog(&#39;旺财&#39;), Cat(&#39;凯蒂&#39;), Dog(&#39;大黄&#39;)]    for pet in pets:        pet.make_voice()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>在上面的代码中，我们将<code>Pet</code>类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过<code>abc</code>模块的<code>ABCMeta</code>元类和<code>abstractmethod</code>包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，<code>Dog</code>和<code>Cat</code>两个子类分别对<code>Pet</code>类中的<code>make_voice</code>抽象方法进行了重写并给出了不同的实现版本，当我们在<code>main</code>函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。</p><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><h4 id="案例1：奥特曼打小怪兽。"><a href="#案例1：奥特曼打小怪兽。" class="headerlink" title="案例1：奥特曼打小怪兽。"></a>案例1：奥特曼打小怪兽。</h4><pre class="language-Python" data-language="Python"><code class="language-Python">from abc import ABCMeta, abstractmethodfrom random import randint, randrangeclass Fighter(object, metaclass&#x3D;ABCMeta):    &quot;&quot;&quot;战斗者&quot;&quot;&quot;    # 通过__slots__魔法限定对象可以绑定的成员变量    __slots__ &#x3D; (&#39;_name&#39;, &#39;_hp&#39;)    def __init__(self, name, hp):        &quot;&quot;&quot;初始化方法        :param name: 名字        :param hp: 生命值        &quot;&quot;&quot;        self._name &#x3D; name        self._hp &#x3D; hp    @property    def name(self):        return self._name    @property    def hp(self):        return self._hp    @hp.setter    def hp(self, hp):        self._hp &#x3D; hp if hp &gt;&#x3D; 0 else 0    @property    def alive(self):        return self._hp &gt; 0    @abstractmethod    def attack(self, other):        &quot;&quot;&quot;攻击        :param other: 被攻击的对象        &quot;&quot;&quot;        passclass Ultraman(Fighter):    &quot;&quot;&quot;奥特曼&quot;&quot;&quot;    __slots__ &#x3D; (&#39;_name&#39;, &#39;_hp&#39;, &#39;_mp&#39;)    def __init__(self, name, hp, mp):        &quot;&quot;&quot;初始化方法        :param name: 名字        :param hp: 生命值        :param mp: 魔法值        &quot;&quot;&quot;        super().__init__(name, hp)        self._mp &#x3D; mp    def attack(self, other):        other.hp -&#x3D; randint(15, 25)    def huge_attack(self, other):        &quot;&quot;&quot;究极必杀技(打掉对方至少50点或四分之三的血)        :param other: 被攻击的对象        :return: 使用成功返回True否则返回False        &quot;&quot;&quot;        if self._mp &gt;&#x3D; 50:            self._mp -&#x3D; 50            injury &#x3D; other.hp * 3 &#x2F;&#x2F; 4            injury &#x3D; injury if injury &gt;&#x3D; 50 else 50            other.hp -&#x3D; injury            return True        else:            self.attack(other)            return False    def magic_attack(self, others):        &quot;&quot;&quot;魔法攻击        :param others: 被攻击的群体        :return: 使用魔法成功返回True否则返回False        &quot;&quot;&quot;        if self._mp &gt;&#x3D; 20:            self._mp -&#x3D; 20            for temp in others:                if temp.alive:                    temp.hp -&#x3D; randint(10, 15)            return True        else:            return False    def resume(self):        &quot;&quot;&quot;恢复魔法值&quot;&quot;&quot;        incr_point &#x3D; randint(1, 10)        self._mp +&#x3D; incr_point        return incr_point    def __str__(self):        return &#39;~~~%s奥特曼~~~\n&#39; % self._name + \            &#39;生命值: %d\n&#39; % self._hp + \            &#39;魔法值: %d\n&#39; % self._mpclass Monster(Fighter):    &quot;&quot;&quot;小怪兽&quot;&quot;&quot;    __slots__ &#x3D; (&#39;_name&#39;, &#39;_hp&#39;)    def attack(self, other):        other.hp -&#x3D; randint(10, 20)    def __str__(self):        return &#39;~~~%s小怪兽~~~\n&#39; % self._name + \            &#39;生命值: %d\n&#39; % self._hpdef is_any_alive(monsters):    &quot;&quot;&quot;判断有没有小怪兽是活着的&quot;&quot;&quot;    for monster in monsters:        if monster.alive &gt; 0:            return True    return Falsedef select_alive_one(monsters):    &quot;&quot;&quot;选中一只活着的小怪兽&quot;&quot;&quot;    monsters_len &#x3D; len(monsters)    while True:        index &#x3D; randrange(monsters_len)        monster &#x3D; monsters[index]        if monster.alive &gt; 0:            return monsterdef display_info(ultraman, monsters):    &quot;&quot;&quot;显示奥特曼和小怪兽的信息&quot;&quot;&quot;    print(ultraman)    for monster in monsters:        print(monster, end&#x3D;&#39;&#39;)def main():    u &#x3D; Ultraman(&#39;骆昊&#39;, 1000, 120)    m1 &#x3D; Monster(&#39;狄仁杰&#39;, 250)    m2 &#x3D; Monster(&#39;白元芳&#39;, 500)    m3 &#x3D; Monster(&#39;王大锤&#39;, 750)    ms &#x3D; [m1, m2, m3]    fight_round &#x3D; 1    while u.alive and is_any_alive(ms):        print(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;第%02d回合&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39; % fight_round)        m &#x3D; select_alive_one(ms)  # 选中一只小怪兽        skill &#x3D; randint(1, 10)   # 通过随机数选择使用哪种技能        if skill &lt;&#x3D; 6:  # 60%的概率使用普通攻击            print(&#39;%s使用普通攻击打了%s.&#39; % (u.name, m.name))            u.attack(m)            print(&#39;%s的魔法值恢复了%d点.&#39; % (u.name, u.resume()))        elif skill &lt;&#x3D; 9:  # 30%的概率使用魔法攻击(可能因魔法值不足而失败)            if u.magic_attack(ms):                print(&#39;%s使用了魔法攻击.&#39; % u.name)            else:                print(&#39;%s使用魔法失败.&#39; % u.name)        else:  # 10%的概率使用究极必杀技(如果魔法值不足则使用普通攻击)            if u.huge_attack(m):                print(&#39;%s使用究极必杀技虐了%s.&#39; % (u.name, m.name))            else:                print(&#39;%s使用普通攻击打了%s.&#39; % (u.name, m.name))                print(&#39;%s的魔法值恢复了%d点.&#39; % (u.name, u.resume()))        if m.alive &gt; 0:  # 如果选中的小怪兽没有死就回击奥特曼            print(&#39;%s回击了%s.&#39; % (m.name, u.name))            m.attack(u)        display_info(u, ms)  # 每个回合结束后显示奥特曼和小怪兽的信息        fight_round +&#x3D; 1    print(&#39;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;战斗结束!&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#39;)    if u.alive &gt; 0:        print(&#39;%s奥特曼胜利!&#39; % u.name)    else:        print(&#39;小怪兽胜利!&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="案例2：扑克游戏。"><a href="#案例2：扑克游戏。" class="headerlink" title="案例2：扑克游戏。"></a>案例2：扑克游戏。</h4><pre class="language-Python" data-language="Python"><code class="language-Python">import randomclass Card(object):    &quot;&quot;&quot;一张牌&quot;&quot;&quot;    def __init__(self, suite, face):        self._suite &#x3D; suite        self._face &#x3D; face    @property    def face(self):        return self._face    @property    def suite(self):        return self._suite    def __str__(self):        if self._face &#x3D;&#x3D; 1:            face_str &#x3D; &#39;A&#39;        elif self._face &#x3D;&#x3D; 11:            face_str &#x3D; &#39;J&#39;        elif self._face &#x3D;&#x3D; 12:            face_str &#x3D; &#39;Q&#39;        elif self._face &#x3D;&#x3D; 13:            face_str &#x3D; &#39;K&#39;        else:            face_str &#x3D; str(self._face)        return &#39;%s%s&#39; % (self._suite, face_str)        def __repr__(self):        return self.__str__()class Poker(object):    &quot;&quot;&quot;一副牌&quot;&quot;&quot;    def __init__(self):        self._cards &#x3D; [Card(suite, face)                        for suite in &#39;♠♥♣♦&#39;                       for face in range(1, 14)]        self._current &#x3D; 0    @property    def cards(self):        return self._cards    def shuffle(self):        &quot;&quot;&quot;洗牌(随机乱序)&quot;&quot;&quot;        self._current &#x3D; 0        random.shuffle(self._cards)    @property    def next(self):        &quot;&quot;&quot;发牌&quot;&quot;&quot;        card &#x3D; self._cards[self._current]        self._current +&#x3D; 1        return card    @property    def has_next(self):        &quot;&quot;&quot;还有没有牌&quot;&quot;&quot;        return self._current &lt; len(self._cards)class Player(object):    &quot;&quot;&quot;玩家&quot;&quot;&quot;    def __init__(self, name):        self._name &#x3D; name        self._cards_on_hand &#x3D; []    @property    def name(self):        return self._name    @property    def cards_on_hand(self):        return self._cards_on_hand    def get(self, card):        &quot;&quot;&quot;摸牌&quot;&quot;&quot;        self._cards_on_hand.append(card)    def arrange(self, card_key):        &quot;&quot;&quot;玩家整理手上的牌&quot;&quot;&quot;        self._cards_on_hand.sort(key&#x3D;card_key)# 排序规则-先根据花色再根据点数排序def get_key(card):    return (card.suite, card.face)def main():    p &#x3D; Poker()    p.shuffle()    players &#x3D; [Player(&#39;东邪&#39;), Player(&#39;西毒&#39;), Player(&#39;南帝&#39;), Player(&#39;北丐&#39;)]    for _ in range(13):        for player in players:            player.get(p.next)    for player in players:        print(player.name + &#39;:&#39;, end&#x3D;&#39; &#39;)        player.arrange(get_key)        print(player.cards_on_hand)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明：</strong> 大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。</p></blockquote><h4 id="案例3：工资结算系统。"><a href="#案例3：工资结算系统。" class="headerlink" title="案例3：工资结算系统。"></a>案例3：工资结算系统。</h4><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;某公司有三种类型的员工 分别是部门经理、程序员和销售员需要设计一个工资结算系统 根据提供的员工信息来计算月薪部门经理的月薪是每月固定15000元程序员的月薪按本月工作时间计算 每小时150元销售员的月薪是1200元的底薪加上销售额5%的提成&quot;&quot;&quot;from abc import ABCMeta, abstractmethodclass Employee(object, metaclass&#x3D;ABCMeta):    &quot;&quot;&quot;员工&quot;&quot;&quot;    def __init__(self, name):        &quot;&quot;&quot;        初始化方法        :param name: 姓名        &quot;&quot;&quot;        self._name &#x3D; name    @property    def name(self):        return self._name    @abstractmethod    def get_salary(self):        &quot;&quot;&quot;        获得月薪        :return: 月薪        &quot;&quot;&quot;        passclass Manager(Employee):    &quot;&quot;&quot;部门经理&quot;&quot;&quot;    def get_salary(self):        return 15000.0class Programmer(Employee):    &quot;&quot;&quot;程序员&quot;&quot;&quot;    def __init__(self, name, working_hour&#x3D;0):        super().__init__(name)        self._working_hour &#x3D; working_hour    @property    def working_hour(self):        return self._working_hour    @working_hour.setter    def working_hour(self, working_hour):        self._working_hour &#x3D; working_hour if working_hour &gt; 0 else 0    def get_salary(self):        return 150.0 * self._working_hourclass Salesman(Employee):    &quot;&quot;&quot;销售员&quot;&quot;&quot;    def __init__(self, name, sales&#x3D;0):        super().__init__(name)        self._sales &#x3D; sales    @property    def sales(self):        return self._sales    @sales.setter    def sales(self, sales):        self._sales &#x3D; sales if sales &gt; 0 else 0    def get_salary(self):        return 1200.0 + self._sales * 0.05def main():    emps &#x3D; [        Manager(&#39;刘备&#39;), Programmer(&#39;诸葛亮&#39;),        Manager(&#39;曹操&#39;), Salesman(&#39;荀彧&#39;),        Salesman(&#39;吕布&#39;), Programmer(&#39;张辽&#39;),        Programmer(&#39;赵云&#39;)    ]    for emp in emps:        if isinstance(emp, Programmer):            emp.working_hour &#x3D; int(input(&#39;请输入%s本月工作时间: &#39; % emp.name))        elif isinstance(emp, Salesman):            emp.sales &#x3D; float(input(&#39;请输入%s本月销售额: &#39; % emp.name))        # 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态)        print(&#39;%s本月工资为: ￥%s元&#39; %              (emp.name, emp.get_salary()))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;面向对象进阶&quot;&gt;&lt;a href=&quot;#面向对象进阶&quot; class=&quot;headerlink&quot; title=&quot;面向对象进阶&quot;&gt;&lt;/a&gt;面向对象进阶&lt;/h2&gt;&lt;p&gt;在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>10.图形用户界面和游戏开发</title>
    <link href="http://wstcly.xyz/2024/07/01/10.tu-xing-yong-hu-jie-mian-he-you-xi-kai-fa/"/>
    <id>http://wstcly.xyz/2024/07/01/10.tu-xing-yong-hu-jie-mian-he-you-xi-kai-fa/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:01.860Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图形用户界面和游戏开发"><a href="#图形用户界面和游戏开发" class="headerlink" title="图形用户界面和游戏开发"></a>图形用户界面和游戏开发</h2><h3 id="基于tkinter模块的GUI"><a href="#基于tkinter模块的GUI" class="headerlink" title="基于tkinter模块的GUI"></a>基于tkinter模块的GUI</h3><p>GUI是图形用户界面的缩写，图形化的用户界面对使用过计算机的人来说应该都不陌生，在此也无需进行赘述。Python默认的GUI开发模块是tkinter（在Python 3以前的版本中名为Tkinter），从这个名字就可以看出它是基于Tk的，Tk是一个工具包，最初是为Tcl设计的，后来被移植到很多其他的脚本语言中，它提供了跨平台的GUI控件。当然Tk并不是最新和最好的选择，也没有功能特别强大的GUI控件，事实上，开发GUI应用并不是Python最擅长的工作，如果真的需要使用Python开发GUI应用，wxPython、PyQt、PyGTK等模块都是不错的选择。</p><p>基本上使用tkinter来开发GUI应用需要以下5个步骤：</p><ol><li>导入tkinter模块中我们需要的东西。</li><li>创建一个顶层窗口对象并用它来承载整个GUI应用。</li><li>在顶层窗口对象上添加GUI组件。</li><li>通过代码将这些GUI组件的功能组织起来。</li><li>进入主事件循环(main loop)。</li></ol><p>下面的代码演示了如何使用tkinter做一个简单的GUI应用。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import tkinterimport tkinter.messageboxdef main():    flag &#x3D; True    # 修改标签上的文字    def change_label_text():        nonlocal flag        flag &#x3D; not flag        color, msg &#x3D; (&#39;red&#39;, &#39;Hello, world!&#39;)\            if flag else (&#39;blue&#39;, &#39;Goodbye, world!&#39;)        label.config(text&#x3D;msg, fg&#x3D;color)    # 确认退出    def confirm_to_quit():        if tkinter.messagebox.askokcancel(&#39;温馨提示&#39;, &#39;确定要退出吗?&#39;):            top.quit()    # 创建顶层窗口    top &#x3D; tkinter.Tk()    # 设置窗口大小    top.geometry(&#39;240x160&#39;)    # 设置窗口标题    top.title(&#39;小游戏&#39;)    # 创建标签对象并添加到顶层窗口    label &#x3D; tkinter.Label(top, text&#x3D;&#39;Hello, world!&#39;, font&#x3D;&#39;Arial -32&#39;, fg&#x3D;&#39;red&#39;)    label.pack(expand&#x3D;1)    # 创建一个装按钮的容器    panel &#x3D; tkinter.Frame(top)    # 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数    button1 &#x3D; tkinter.Button(panel, text&#x3D;&#39;修改&#39;, command&#x3D;change_label_text)    button1.pack(side&#x3D;&#39;left&#39;)    button2 &#x3D; tkinter.Button(panel, text&#x3D;&#39;退出&#39;, command&#x3D;confirm_to_quit)    button2.pack(side&#x3D;&#39;right&#39;)    panel.pack(side&#x3D;&#39;bottom&#39;)    # 开启主事件循环    tkinter.mainloop()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>需要说明的是，GUI应用通常是事件驱动式的，之所以要进入主事件循环就是要监听鼠标、键盘等各种事件的发生并执行对应的代码对事件进行处理，因为事件会持续的发生，所以需要这样的一个循环一直运行着等待下一个事件的发生。另一方面，Tk为控件的摆放提供了三种布局管理器，通过布局管理器可以对控件进行定位，这三种布局管理器分别是：Placer（开发者提供控件的大小和摆放位置）、Packer（自动将控件填充到合适的位置）和Grid（基于网格坐标来摆放控件），此处不进行赘述。</p><h3 id="使用Pygame进行游戏开发"><a href="#使用Pygame进行游戏开发" class="headerlink" title="使用Pygame进行游戏开发"></a>使用Pygame进行游戏开发</h3><p>Pygame是一个开源的Python模块，专门用于多媒体应用（如电子游戏）的开发，其中包含对图像、声音、视频、事件、碰撞等的支持。Pygame建立在<a href="https://zh.wikipedia.org/wiki/SDL">SDL</a>的基础上，SDL是一套跨平台的多媒体开发库，用C语言实现，被广泛的应用于游戏、模拟器、播放器等的开发。而Pygame让游戏开发者不再被底层语言束缚，可以更多的关注游戏的功能和逻辑。</p><p>下面我们来完成一个简单的小游戏，游戏的名字叫“大球吃小球”，当然完成这个游戏并不是重点，学会使用Pygame也不是重点，最重要的我们要在这个过程中体会如何使用前面讲解的面向对象程序设计，学会用这种编程思想去解决现实中的问题。</p><h4 id="制作游戏窗口"><a href="#制作游戏窗口" class="headerlink" title="制作游戏窗口"></a>制作游戏窗口</h4><pre class="language-Python" data-language="Python"><code class="language-Python">import pygamedef main():    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen &#x3D; pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption(&#39;大球吃小球&#39;)    running &#x3D; True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type &#x3D;&#x3D; pygame.QUIT:                running &#x3D; Falseif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="在窗口中绘图"><a href="#在窗口中绘图" class="headerlink" title="在窗口中绘图"></a>在窗口中绘图</h4><p>可以通过pygame中draw模块的函数在窗口上绘图，可以绘制的图形包括：线条、矩形、多边形、圆、椭圆、圆弧等。需要说明的是，屏幕坐标系是将屏幕左上角设置为坐标原点<code>(0, 0)</code>，向右是x轴的正向，向下是y轴的正向，在表示位置或者设置尺寸的时候，我们默认的单位都是<a href="https://zh.wikipedia.org/wiki/%E5%83%8F%E7%B4%A0">像素</a>。所谓像素就是屏幕上的一个点，你可以用浏览图片的软件试着将一张图片放大若干倍，就可以看到这些点。pygame中表示颜色用的是色光<a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E8%89%B2">三原色</a>表示法，即通过一个元组或列表来指定颜色的RGB值，每个值都在0~255之间，因为是每种原色都用一个8位（bit）的值来表示，三种颜色相当于一共由24位构成，这也就是常说的“24位颜色表示法”。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import pygamedef main():    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen &#x3D; pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption(&#39;大球吃小球&#39;)    # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组)    screen.fill((242, 242, 242))    # 绘制一个圆(参数分别是: 屏幕, 颜色, 圆心位置, 半径, 0表示填充圆)    pygame.draw.circle(screen, (255, 0, 0,), (100, 100), 30, 0)    # 刷新当前窗口(渲染窗口将绘制的图像呈现出来)    pygame.display.flip()    running &#x3D; True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type &#x3D;&#x3D; pygame.QUIT:                running &#x3D; Falseif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="加载图像"><a href="#加载图像" class="headerlink" title="加载图像"></a>加载图像</h4><p>如果需要直接加载图像到窗口上，可以使用pygame中image模块的函数来加载图像，再通过之前获得的窗口对象的<code>blit</code>方法渲染图像，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import pygamedef main():    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen &#x3D; pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption(&#39;大球吃小球&#39;)    # 设置窗口的背景色(颜色是由红绿蓝三原色构成的元组)    screen.fill((255, 255, 255))    # 通过指定的文件名加载图像    ball_image &#x3D; pygame.image.load(&#39;.&#x2F;res&#x2F;ball.png&#39;)    # 在窗口上渲染图像    screen.blit(ball_image, (50, 50))    # 刷新当前窗口(渲染窗口将绘制的图像呈现出来)    pygame.display.flip()    running &#x3D; True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type &#x3D;&#x3D; pygame.QUIT:                running &#x3D; Falseif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="实现动画效果"><a href="#实现动画效果" class="headerlink" title="实现动画效果"></a>实现动画效果</h4><p>说到<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E7%94%BB">动画</a>这个词大家都不会陌生，事实上要实现动画效果，本身的原理也非常简单，就是将不连续的图片连续的播放，只要每秒钟达到了一定的帧数，那么就可以做出比较流畅的动画效果。如果要让上面代码中的小球动起来，可以将小球的位置用变量来表示，并在循环中修改小球的位置再刷新整个窗口即可。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import pygamedef main():    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen &#x3D; pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption(&#39;大球吃小球&#39;)    # 定义变量来表示小球在屏幕上的位置    x, y &#x3D; 50, 50    running &#x3D; True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type &#x3D;&#x3D; pygame.QUIT:                running &#x3D; False        screen.fill((255, 255, 255))        pygame.draw.circle(screen, (255, 0, 0,), (x, y), 30, 0)        pygame.display.flip()        # 每隔50毫秒就改变小球的位置再刷新窗口        pygame.time.delay(50)        x, y &#x3D; x + 5, y + 5if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><p>通常一个游戏中会有很多对象出现，而这些对象之间的“碰撞”在所难免，比如炮弹击中了飞机、箱子撞到了地面等。碰撞检测在绝大多数的游戏中都是一个必须得处理的至关重要的问题，pygame的sprite（动画精灵）模块就提供了对碰撞检测的支持，这里我们暂时不介绍sprite模块提供的功能，因为要检测两个小球有没有碰撞其实非常简单，只需要检查球心的距离有没有小于两个球的半径之和。为了制造出更多的小球，我们可以通过对鼠标事件的处理，在点击鼠标的位置创建颜色、大小和移动速度都随机的小球，当然要做到这一点，我们可以把之前学习到的面向对象的知识应用起来。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from enum import Enum, uniquefrom math import sqrtfrom random import randintimport pygame@uniqueclass Color(Enum):    &quot;&quot;&quot;颜色&quot;&quot;&quot;    RED &#x3D; (255, 0, 0)    GREEN &#x3D; (0, 255, 0)    BLUE &#x3D; (0, 0, 255)    BLACK &#x3D; (0, 0, 0)    WHITE &#x3D; (255, 255, 255)    GRAY &#x3D; (242, 242, 242)    @staticmethod    def random_color():        &quot;&quot;&quot;获得随机颜色&quot;&quot;&quot;        r &#x3D; randint(0, 255)        g &#x3D; randint(0, 255)        b &#x3D; randint(0, 255)        return (r, g, b)class Ball(object):    &quot;&quot;&quot;球&quot;&quot;&quot;    def __init__(self, x, y, radius, sx, sy, color&#x3D;Color.RED):        &quot;&quot;&quot;初始化方法&quot;&quot;&quot;        self.x &#x3D; x        self.y &#x3D; y        self.radius &#x3D; radius        self.sx &#x3D; sx        self.sy &#x3D; sy        self.color &#x3D; color        self.alive &#x3D; True    def move(self, screen):        &quot;&quot;&quot;移动&quot;&quot;&quot;        self.x +&#x3D; self.sx        self.y +&#x3D; self.sy        if self.x - self.radius &lt;&#x3D; 0 or \                self.x + self.radius &gt;&#x3D; screen.get_width():            self.sx &#x3D; -self.sx        if self.y - self.radius &lt;&#x3D; 0 or \                self.y + self.radius &gt;&#x3D; screen.get_height():            self.sy &#x3D; -self.sy    def eat(self, other):        &quot;&quot;&quot;吃其他球&quot;&quot;&quot;        if self.alive and other.alive and self !&#x3D; other:            dx, dy &#x3D; self.x - other.x, self.y - other.y            distance &#x3D; sqrt(dx ** 2 + dy ** 2)            if distance &lt; self.radius + other.radius \                    and self.radius &gt; other.radius:                other.alive &#x3D; False                self.radius &#x3D; self.radius + int(other.radius * 0.146)    def draw(self, screen):        &quot;&quot;&quot;在窗口上绘制球&quot;&quot;&quot;        pygame.draw.circle(screen, self.color,                           (self.x, self.y), self.radius, 0)</code></pre><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><p>可以在事件循环中对鼠标事件进行处理，通过事件对象的<code>type</code>属性可以判定事件类型，再通过<code>pos</code>属性就可以获得鼠标点击的位置。如果要处理键盘事件也是在这个地方，做法与处理鼠标事件类似。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def main():    # 定义用来装所有球的容器    balls &#x3D; []    # 初始化导入的pygame中的模块    pygame.init()    # 初始化用于显示的窗口并设置窗口尺寸    screen &#x3D; pygame.display.set_mode((800, 600))    # 设置当前窗口的标题    pygame.display.set_caption(&#39;大球吃小球&#39;)    running &#x3D; True    # 开启一个事件循环处理发生的事件    while running:        # 从消息队列中获取事件并对事件进行处理        for event in pygame.event.get():            if event.type &#x3D;&#x3D; pygame.QUIT:                running &#x3D; False            # 处理鼠标事件的代码            if event.type &#x3D;&#x3D; pygame.MOUSEBUTTONDOWN and event.button &#x3D;&#x3D; 1:                # 获得点击鼠标的位置                x, y &#x3D; event.pos                radius &#x3D; randint(10, 100)                sx, sy &#x3D; randint(-10, 10), randint(-10, 10)                color &#x3D; Color.random_color()                # 在点击鼠标的位置创建一个球(大小、速度和颜色随机)                ball &#x3D; Ball(x, y, radius, sx, sy, color)                # 将球添加到列表容器中                balls.append(ball)        screen.fill((255, 255, 255))        # 取出容器中的球 如果没被吃掉就绘制 被吃掉了就移除        for ball in balls:            if ball.alive:                ball.draw(screen)            else:                balls.remove(ball)        pygame.display.flip()        # 每隔50毫秒就改变球的位置再刷新窗口        pygame.time.delay(50)        for ball in balls:            ball.move(screen)            # 检查球有没有吃到其他的球            for other in balls:                ball.eat(other)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>上面的两段代码合在一起，我们就完成了“大球吃小球”的游戏（如下图所示），准确的说它算不上一个游戏，但是做一个小游戏的基本知识我们已经通过这个例子告诉大家了，有了这些知识已经可以开始你的小游戏开发之旅了。其实上面的代码中还有很多值得改进的地方，比如刷新窗口以及让球移动起来的代码并不应该放在事件循环中，等学习了多线程的知识后，用一个后台线程来处理这些事可能是更好的选择。如果希望获得更好的用户体验，我们还可以在游戏中加入背景音乐以及在球与球发生碰撞时播放音效，利用pygame的mixer和music模块，我们可以很容易的做到这一点，大家可以自行了解这方面的知识。事实上，想了解更多的关于pygame的知识，最好的教程是<a href="https://www.pygame.org/news">pygame的官方网站</a>，如果英语没毛病就可以赶紧去看看啦。 如果想开发<a href="https://zh.wikipedia.org/wiki/3D%E6%B8%B8%E6%88%8F">3D游戏</a>，pygame就显得力不从心了，对3D游戏开发如果有兴趣的读者不妨看看<a href="https://www.panda3d.org/">Panda3D</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图形用户界面和游戏开发&quot;&gt;&lt;a href=&quot;#图形用户界面和游戏开发&quot; class=&quot;headerlink&quot; title=&quot;图形用户界面和游戏开发&quot;&gt;&lt;/a&gt;图形用户界面和游戏开发&lt;/h2&gt;&lt;h3 id=&quot;基于tkinter模块的GUI&quot;&gt;&lt;a href=&quot;#基于</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>100.Python面试题实录</title>
    <link href="http://wstcly.xyz/2024/07/01/100.python-mian-shi-ti-shi-lu/"/>
    <id>http://wstcly.xyz/2024/07/01/100.python-mian-shi-ti-shi-lu/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:04.008Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python面试题实录"><a href="#Python面试题实录" class="headerlink" title="Python面试题实录"></a>Python面试题实录</h2><blockquote><p><strong>温馨提示</strong>：请访问我的另一个项目<a href="https://github.com/jackfrued/Python-Interview-Bible">“Python面试宝典”</a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python面试题实录&quot;&gt;&lt;a href=&quot;#Python面试题实录&quot; class=&quot;headerlink&quot; title=&quot;Python面试题实录&quot;&gt;&lt;/a&gt;Python面试题实录&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;温馨提示&lt;/strong&gt;</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>11.文件和异常</title>
    <link href="http://wstcly.xyz/2024/07/01/11.wen-jian-he-yi-chang/"/>
    <id>http://wstcly.xyz/2024/07/01/11.wen-jian-he-yi-chang/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:01.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件和异常"><a href="#文件和异常" class="headerlink" title="文件和异常"></a>文件和异常</h2><p>实际开发中常常会遇到对数据进行<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">持久化</a>操作的场景，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到“文件”这个词，可能需要先科普一下关于<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">文件系统</a>的知识，但是这里我们并不浪费笔墨介绍这个概念，请大家自行通过维基百科进行了解。</p><p>在Python中实现文件的读写操作其实非常简单，通过Python内置的<code>open</code>函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。</p><table><thead><tr><th>操作模式</th><th>具体含义</th></tr></thead><tbody><tr><td><code>&#39;r&#39;</code></td><td>读取 （默认）</td></tr><tr><td><code>&#39;w&#39;</code></td><td>写入（会先截断之前的内容）</td></tr><tr><td><code>&#39;x&#39;</code></td><td>写入，如果文件已经存在会产生异常</td></tr><tr><td><code>&#39;a&#39;</code></td><td>追加，将内容写入到已有文件的末尾</td></tr><tr><td><code>&#39;b&#39;</code></td><td>二进制模式</td></tr><tr><td><code>&#39;t&#39;</code></td><td>文本模式（默认）</td></tr><tr><td><code>&#39;+&#39;</code></td><td>更新（既可以读又可以写）</td></tr></tbody></table><p>下面这张图来自于<a href="http://www.runoob.com/">菜鸟教程</a>网站，它展示了如果根据应用程序的需要来设置操作模式。</p><p><img src="/./res/file-open-mode.png"></p><h3 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h3><p>读取文本文件时，需要在使用<code>open</code>函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为<code>&#39;r&#39;</code>（如果不指定，默认值也是<code>&#39;r&#39;</code>），然后通过<code>encoding</code>参数指定编码（如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def main():    f &#x3D; open(&#39;致橡树.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)    print(f.read())    f.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>请注意上面的代码，如果<code>open</code>函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def main():    f &#x3D; None    try:        f &#x3D; open(&#39;致橡树.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;)        print(f.read())    except FileNotFoundError:        print(&#39;无法打开指定的文件!&#39;)    except LookupError:        print(&#39;指定了未知的编码!&#39;)    except UnicodeDecodeError:        print(&#39;读取文件时解码错误!&#39;)    finally:        if f:            f.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>在Python中，我们可以将那些在运行时可能会出现状况的代码放在<code>try</code>代码块中，在<code>try</code>代码块的后面可以跟上一个或多个<code>except</code>来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发<code>FileNotFoundError</code>，指定了未知的编码会引发<code>LookupError</code>，而如果读取文件时无法按指定方式解码会引发<code>UnicodeDecodeError</code>，我们在<code>try</code>后面跟上了三个<code>except</code>分别处理这三种不同的异常状况。最后我们使用<code>finally</code>代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于<code>finally</code>块的代码不论程序正常还是异常都会执行到（甚至是调用了<code>sys</code>模块的<code>exit</code>函数退出Python环境，<code>finally</code>块都会被执行，因为<code>exit</code>函数实质上是引发了<code>SystemExit</code>异常），因此我们通常把<code>finally</code>块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在<code>finally</code>代码块中关闭文件对象释放资源，也可以使用上下文语法，通过<code>with</code>关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def main():    try:        with open(&#39;致橡树.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:            print(f.read())    except FileNotFoundError:        print(&#39;无法打开指定的文件!&#39;)    except LookupError:        print(&#39;指定了未知的编码!&#39;)    except UnicodeDecodeError:        print(&#39;读取文件时解码错误!&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>除了使用文件对象的<code>read</code>方法读取文件之外，还可以使用<code>for-in</code>循环逐行读取或者用<code>readlines</code>方法将文件按行读取到一个列表容器中，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import timedef main():    # 一次性读取整个文件内容    with open(&#39;致橡树.txt&#39;, &#39;r&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:        print(f.read())    # 通过for-in循环逐行读取    with open(&#39;致橡树.txt&#39;, mode&#x3D;&#39;r&#39;) as f:        for line in f:            print(line, end&#x3D;&#39;&#39;)            time.sleep(0.5)    print()    # 读取文件按行读取到列表中    with open(&#39;致橡树.txt&#39;) as f:        lines &#x3D; f.readlines()    print(lines)    if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>要将文本信息写入文件文件也非常简单，在使用<code>open</code>函数时指定好文件名并将文件模式设置为<code>&#39;w&#39;</code>即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为<code>&#39;a&#39;</code>。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1-9999之间的素数分别写入三个文件中（1-99之间的素数保存在a.txt中，100-999之间的素数保存在b.txt中，1000-9999之间的素数保存在c.txt中）。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from math import sqrtdef is_prime(n):    &quot;&quot;&quot;判断素数的函数&quot;&quot;&quot;    assert n &gt; 0    for factor in range(2, int(sqrt(n)) + 1):        if n % factor &#x3D;&#x3D; 0:            return False    return True if n !&#x3D; 1 else Falsedef main():    filenames &#x3D; (&#39;a.txt&#39;, &#39;b.txt&#39;, &#39;c.txt&#39;)    fs_list &#x3D; []    try:        for filename in filenames:            fs_list.append(open(filename, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;))        for number in range(1, 10000):            if is_prime(number):                if number &lt; 100:                    fs_list[0].write(str(number) + &#39;\n&#39;)                elif number &lt; 1000:                    fs_list[1].write(str(number) + &#39;\n&#39;)                else:                    fs_list[2].write(str(number) + &#39;\n&#39;)    except IOError as ex:        print(ex)        print(&#39;写文件时发生错误!&#39;)    finally:        for fs in fs_list:            fs.close()    print(&#39;操作完成!&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h3 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h3><p>知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def main():    try:        with open(&#39;guido.jpg&#39;, &#39;rb&#39;) as fs1:            data &#x3D; fs1.read()            print(type(data))  # &lt;class &#39;bytes&#39;&gt;        with open(&#39;吉多.jpg&#39;, &#39;wb&#39;) as fs2:            fs2.write(data)    except FileNotFoundError as e:        print(&#39;指定的文件无法打开.&#39;)    except IOError as e:        print(&#39;读写文件时出现错误.&#39;)    print(&#39;程序执行结束.&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h3 id="读写JSON文件"><a href="#读写JSON文件" class="headerlink" title="读写JSON文件"></a>读写JSON文件</h3><p>通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考<a href="http://json.org/">JSON的官方网站</a>，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。</p><pre class="language-JSON" data-language="JSON"><code class="language-JSON">&#123;    &quot;name&quot;: &quot;骆昊&quot;,    &quot;age&quot;: 38,    &quot;qq&quot;: 957658,    &quot;friends&quot;: [&quot;王大锤&quot;, &quot;白元芳&quot;],    &quot;cars&quot;: [        &#123;&quot;brand&quot;: &quot;BYD&quot;, &quot;max_speed&quot;: 180&#125;,        &#123;&quot;brand&quot;: &quot;Audi&quot;, &quot;max_speed&quot;: 280&#125;,        &#123;&quot;brand&quot;: &quot;Benz&quot;, &quot;max_speed&quot;: 320&#125;    ]&#125;</code></pre><p>可能大家已经注意到了，上面的JSON跟Python中的字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对应关系的，如下面两张表所示。</p><table><thead><tr><th>JSON</th><th>Python</th></tr></thead><tbody><tr><td>object</td><td>dict</td></tr><tr><td>array</td><td>list</td></tr><tr><td>string</td><td>str</td></tr><tr><td>number (int &#x2F; real)</td><td>int &#x2F; float</td></tr><tr><td>true &#x2F; false</td><td>True &#x2F; False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><table><thead><tr><th>Python</th><th>JSON</th></tr></thead><tbody><tr><td>dict</td><td>object</td></tr><tr><td>list, tuple</td><td>array</td></tr><tr><td>str</td><td>string</td></tr><tr><td>int, float, int- &amp; float-derived Enums</td><td>number</td></tr><tr><td>True &#x2F; False</td><td>true &#x2F; false</td></tr><tr><td>None</td><td>null</td></tr></tbody></table><p>我们使用Python中的json模块就可以将字典或列表以JSON格式保存到文件中，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import jsondef main():    mydict &#x3D; &#123;        &#39;name&#39;: &#39;骆昊&#39;,        &#39;age&#39;: 38,        &#39;qq&#39;: 957658,        &#39;friends&#39;: [&#39;王大锤&#39;, &#39;白元芳&#39;],        &#39;cars&#39;: [            &#123;&#39;brand&#39;: &#39;BYD&#39;, &#39;max_speed&#39;: 180&#125;,            &#123;&#39;brand&#39;: &#39;Audi&#39;, &#39;max_speed&#39;: 280&#125;,            &#123;&#39;brand&#39;: &#39;Benz&#39;, &#39;max_speed&#39;: 320&#125;        ]    &#125;    try:        with open(&#39;data.json&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as fs:            json.dump(mydict, fs)    except IOError as e:        print(e)    print(&#39;保存数据完成!&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>json模块主要有四个比较重要的函数，分别是：</p><ul><li><code>dump</code> - 将Python对象按照JSON格式序列化到文件中</li><li><code>dumps</code> - 将Python对象处理成JSON格式的字符串</li><li><code>load</code> - 将文件中的JSON数据反序列化成对象</li><li><code>loads</code> - 将字符串的内容反序列化成Python对象</li></ul><p>这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书<a href="https://zh.wikipedia.org/">维基百科</a>上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。</p><p>目前绝大多数网络数据服务（或称之为网络API）都是基于<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">HTTP协议</a>提供JSON格式的数据，关于HTTP协议的相关知识，可以看看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP协议入门》</a>，如果想了解国内的网络数据服务，可以看看<a href="https://www.juhe.cn/">聚合数据</a>和<a href="http://www.avatardata.cn/">阿凡达数据</a>等网站，国外的可以看看<a href="http://apis.io/">{API}Search</a>网站。下面的例子演示了如何使用<a href="http://docs.python-requests.org/zh_CN/latest/">requests</a>模块（封装得足够好的第三方网络访问模块）访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题，这个例子使用了<a href="https://www.tianapi.com/">天行数据</a>提供的国内新闻数据接口，其中的APIKey需要自己到该网站申请。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import requestsimport jsondef main():    resp &#x3D; requests.get(&#39;http:&#x2F;&#x2F;api.tianapi.com&#x2F;guonei&#x2F;?key&#x3D;APIKey&amp;num&#x3D;10&#39;)    data_model &#x3D; json.loads(resp.text)    for news in data_model[&#39;newslist&#39;]:        print(news[&#39;title&#39;])if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>在Python中要实现序列化和反序列化除了使用json模块之外，还可以使用pickle和shelve模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于Python异常机制的知识，可以看看segmentfault上面的文章<a href="https://segmentfault.com/a/1190000007736783">《总结：Python中的异常处理》</a>，这篇文章不仅介绍了Python中异常机制的使用，还总结了一系列的最佳实践，很值得一读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文件和异常&quot;&gt;&lt;a href=&quot;#文件和异常&quot; class=&quot;headerlink&quot; title=&quot;文件和异常&quot;&gt;&lt;/a&gt;文件和异常&lt;/h2&gt;&lt;p&gt;实际开发中常常会遇到对数据进行&lt;a href=&quot;https://baike.baidu.com/item/%E6%9</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>12.字符串和正则表达式</title>
    <link href="http://wstcly.xyz/2024/07/01/12.zi-fu-chuan-he-zheng-ze-biao-da-shi/"/>
    <id>http://wstcly.xyz/2024/07/01/12.zi-fu-chuan-he-zheng-ze-biao-da-shi/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:01.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><h3 id="正则表达式相关知识"><a href="#正则表达式相关知识" class="headerlink" title="正则表达式相关知识"></a>正则表达式相关知识</h3><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。</p><p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p><p>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫<a href="https://deerchao.net/tutorials/regex/regex.htm">《正则表达式30分钟入门教程》</a>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p><table><thead><tr><th>符号</th><th>解释</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符</td><td>b.t</td><td>可以匹配bat &#x2F; but &#x2F; b#t &#x2F; b1t等</td></tr><tr><td>\w</td><td>匹配字母&#x2F;数字&#x2F;下划线</td><td>b\wt</td><td>可以匹配bat &#x2F; b1t &#x2F; b_t等<br>但不能匹配b#t</td></tr><tr><td>\s</td><td>匹配空白字符（包括\r、\n、\t等）</td><td>love\syou</td><td>可以匹配love you</td></tr><tr><td>\d</td><td>匹配数字</td><td>\d\d</td><td>可以匹配01 &#x2F; 23 &#x2F; 99等</td></tr><tr><td>\b</td><td>匹配单词的边界</td><td>\bThe\b</td><td></td></tr><tr><td>^</td><td>匹配字符串的开始</td><td>^The</td><td>可以匹配The开头的字符串</td></tr><tr><td>$</td><td>匹配字符串的结束</td><td>.exe$</td><td>可以匹配.exe结尾的字符串</td></tr><tr><td>\W</td><td>匹配非字母&#x2F;数字&#x2F;下划线</td><td>b\Wt</td><td>可以匹配b#t &#x2F; b@t等<br>但不能匹配but &#x2F; b1t &#x2F; b_t等</td></tr><tr><td>\S</td><td>匹配非空白字符</td><td>love\Syou</td><td>可以匹配love#you等<br>但不能匹配love you</td></tr><tr><td>\D</td><td>匹配非数字</td><td>\d\D</td><td>可以匹配9a &#x2F; 3# &#x2F; 0F等</td></tr><tr><td>\B</td><td>匹配非单词边界</td><td>\Bio\B</td><td></td></tr><tr><td>[]</td><td>匹配来自字符集的任意单一字符</td><td>[aeiou]</td><td>可以匹配任一元音字母字符</td></tr><tr><td>[^]</td><td>匹配不在字符集中的任意单一字符</td><td>[^aeiou]</td><td>可以匹配任一非元音字母字符</td></tr><tr><td>*</td><td>匹配0次或多次</td><td>\w*</td><td></td></tr><tr><td>+</td><td>匹配1次或多次</td><td>\w+</td><td></td></tr><tr><td>?</td><td>匹配0次或1次</td><td>\w?</td><td></td></tr><tr><td>{N}</td><td>匹配N次</td><td>\w{3}</td><td></td></tr><tr><td>{M,}</td><td>匹配至少M次</td><td>\w{3,}</td><td></td></tr><tr><td>{M,N}</td><td>匹配至少M次至多N次</td><td>\w{3,6}</td><td></td></tr><tr><td>|</td><td>分支</td><td>foo|bar</td><td>可以匹配foo或者bar</td></tr><tr><td>(?#)</td><td>注释</td><td></td><td></td></tr><tr><td>(exp)</td><td>匹配exp并捕获到自动命名的组中</td><td></td><td></td></tr><tr><td>(?&lt;name&gt;exp)</td><td>匹配exp并捕获到名为name的组中</td><td></td><td></td></tr><tr><td>(?:exp)</td><td>匹配exp但是不捕获匹配的文本</td><td></td><td></td></tr><tr><td>(?&#x3D;exp)</td><td>匹配exp前面的位置</td><td>\b\w+(?&#x3D;ing)</td><td>可以匹配I’m dancing中的danc</td></tr><tr><td>(?&lt;&#x3D;exp)</td><td>匹配exp后面的位置</td><td>(?&lt;&#x3D;\bdanc)\w+\b</td><td>可以匹配I love dancing and reading中的第一个ing</td></tr><tr><td>(?!exp)</td><td>匹配后面不是exp的位置</td><td></td><td></td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td><td></td><td></td></tr><tr><td>*?</td><td>重复任意次，但尽可能少重复</td><td>a.*b<br>a.*?b</td><td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td></tr><tr><td>+?</td><td>重复1次或多次，但尽可能少重复</td><td></td><td></td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,N}?</td><td>重复M到N次，但尽可能少重复</td><td></td><td></td></tr><tr><td>{M,}?</td><td>重复M次以上，但尽可能少重复</td><td></td><td></td></tr></tbody></table><blockquote><p><strong>说明：</strong> 如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。</p></blockquote><h3 id="Python对正则表达式的支持"><a href="#Python对正则表达式的支持" class="headerlink" title="Python对正则表达式的支持"></a>Python对正则表达式的支持</h3><p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>compile(pattern, flags&#x3D;0)</td><td>编译正则表达式返回正则表达式对象</td></tr><tr><td>match(pattern, string, flags&#x3D;0)</td><td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td></tr><tr><td>search(pattern, string, flags&#x3D;0)</td><td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td></tr><tr><td>split(pattern, string, maxsplit&#x3D;0, flags&#x3D;0)</td><td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td></tr><tr><td>sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)</td><td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td></tr><tr><td>fullmatch(pattern, string, flags&#x3D;0)</td><td>match函数的完全匹配（从字符串开头到结尾）版本</td></tr><tr><td>findall(pattern, string, flags&#x3D;0)</td><td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td></tr><tr><td>finditer(pattern, string, flags&#x3D;0)</td><td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td></tr><tr><td>purge()</td><td>清除隐式编译的正则表达式的缓存</td></tr><tr><td>re.I &#x2F; re.IGNORECASE</td><td>忽略大小写匹配标记</td></tr><tr><td>re.M &#x2F; re.MULTILINE</td><td>多行匹配标记</td></tr></tbody></table><blockquote><p><strong>说明：</strong> 上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p></blockquote><p>下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。</p><h4 id="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"><a href="#例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。" class="headerlink" title="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"></a>例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。</h4><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;验证输入用户名和QQ号是否有效并给出对应的提示信息要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0&quot;&quot;&quot;import redef main():    username &#x3D; input(&#39;请输入用户名: &#39;)    qq &#x3D; input(&#39;请输入QQ号: &#39;)    # match函数的第一个参数是正则表达式字符串或正则表达式对象    # 第二个参数是要跟正则表达式做匹配的字符串对象    m1 &#x3D; re.match(r&#39;^[0-9a-zA-Z_]&#123;6,20&#125;$&#39;, username)    if not m1:        print(&#39;请输入有效的用户名.&#39;)    m2 &#x3D; re.match(r&#39;^[1-9]\d&#123;4,11&#125;$&#39;, qq)    if not m2:        print(&#39;请输入有效的QQ号.&#39;)    if m1 and m2:        print(&#39;你输入的信息是有效的!&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>提示：</strong> 上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。</p></blockquote><h4 id="例子2：从一段文字中提取出国内手机号码。"><a href="#例子2：从一段文字中提取出国内手机号码。" class="headerlink" title="例子2：从一段文字中提取出国内手机号码。"></a>例子2：从一段文字中提取出国内手机号码。</h4><p>下面这张图是截止到2017年底，国内三家运营商推出的手机号段。</p><p><img src="/./res/tel-start-number.png"></p><pre class="language-Python" data-language="Python"><code class="language-Python">import redef main():    # 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字    pattern &#x3D; re.compile(r&#39;(?&lt;&#x3D;\D)1[34578]\d&#123;9&#125;(?&#x3D;\D)&#39;)    sentence &#x3D; &#39;&#39;&#39;    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，    不是15600998765，也是110或119，王大锤的手机号才是15600998765。    &#39;&#39;&#39;    # 查找所有匹配并保存到一个列表中    mylist &#x3D; re.findall(pattern, sentence)    print(mylist)    print(&#39;--------华丽的分隔线--------&#39;)    # 通过迭代器取出匹配对象并获得匹配的内容    for temp in pattern.finditer(sentence):        print(temp.group())    print(&#39;--------华丽的分隔线--------&#39;)    # 通过search函数指定搜索位置找出所有匹配    m &#x3D; pattern.search(sentence)    while m:        print(m.group())        m &#x3D; pattern.search(sentence, m.end())if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明：</strong> 上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：<code>(?&lt;=\D)(1[38]\d&#123;9&#125;|14[57]\d&#123;8&#125;|15[0-35-9]\d&#123;8&#125;|17[678]\d&#123;8&#125;)(?=\D)</code>，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p></blockquote><h4 id="例子3：替换字符串中的不良内容"><a href="#例子3：替换字符串中的不良内容" class="headerlink" title="例子3：替换字符串中的不良内容"></a>例子3：替换字符串中的不良内容</h4><pre class="language-Python" data-language="Python"><code class="language-Python">import redef main():    sentence &#x3D; &#39;你丫是傻叉吗? 我操你大爷的. Fuck you.&#39;    purified &#x3D; re.sub(&#39;[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔&#39;,                      &#39;*&#39;, sentence, flags&#x3D;re.IGNORECASE)    print(purified)  # 你丫是*吗? 我*你大爷的. * you.if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明：</strong> re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用<a href="http://www.runoob.com/python/python-operators.html#ysf5">按位或运算符</a>进行叠加，如<code>flags=re.I | re.M</code>。</p></blockquote><h4 id="例子4：拆分长字符串"><a href="#例子4：拆分长字符串" class="headerlink" title="例子4：拆分长字符串"></a>例子4：拆分长字符串</h4><pre class="language-Python" data-language="Python"><code class="language-Python">import redef main():    poem &#x3D; &#39;窗前明月光，疑是地上霜。举头望明月，低头思故乡。&#39;    sentence_list &#x3D; re.split(r&#39;[，。, .]&#39;, poem)    while &#39;&#39; in sentence_list:        sentence_list.remove(&#39;&#39;)    print(sentence_list)  # [&#39;窗前明月光&#39;, &#39;疑是地上霜&#39;, &#39;举头望明月&#39;, &#39;低头思故乡&#39;]if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择<a href="https://www.crummy.com/software/BeautifulSoup/">Beautiful Soup</a>或<a href="http://lxml.de/">Lxml</a>来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用正则表达式&quot;&gt;&lt;a href=&quot;#使用正则表达式&quot; class=&quot;headerlink&quot; title=&quot;使用正则表达式&quot;&gt;&lt;/a&gt;使用正则表达式&lt;/h2&gt;&lt;h3 id=&quot;正则表达式相关知识&quot;&gt;&lt;a href=&quot;#正则表达式相关知识&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>13.进程和线程</title>
    <link href="http://wstcly.xyz/2024/07/01/13.jin-cheng-he-xian-cheng/"/>
    <id>http://wstcly.xyz/2024/07/01/13.jin-cheng-he-xian-cheng/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:02.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。</p><p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。</p><p><img src="/./res/macos-monitor.png"></p><p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。</p><p>Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。</p><h3 id="Python中的多进程"><a href="#Python中的多进程" class="headerlink" title="Python中的多进程"></a>Python中的多进程</h3><p>Unix和Linux操作系统上提供了<code>fork()</code>系统调用来创建进程，调用<code>fork()</code>函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。<code>fork()</code>函数非常特殊它会返回两次，父进程中可以通过<code>fork()</code>函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了<code>fork()</code>函数。由于Windows系统没有<code>fork()</code>调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的<code>Process</code>类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（<code>Pool</code>）、用于进程间通信的队列（<code>Queue</code>）和管道（<code>Pipe</code>）等。</p><p>下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from random import randintfrom time import time, sleepdef download_task(filename):    print(&#39;开始下载%s...&#39; % filename)    time_to_download &#x3D; randint(5, 10)    sleep(time_to_download)    print(&#39;%s下载完成! 耗费了%d秒&#39; % (filename, time_to_download))def main():    start &#x3D; time()    download_task(&#39;Python从入门到住院.pdf&#39;)    download_task(&#39;Peking Hot.avi&#39;)    end &#x3D; time()    print(&#39;总共耗费了%.2f秒.&#39; % (end - start))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>下面是运行程序得到的一次运行结果。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">开始下载Python从入门到住院.pdf...Python从入门到住院.pdf下载完成! 耗费了6秒开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒总共耗费了13.01秒.</code></pre><p>从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from multiprocessing import Processfrom os import getpidfrom random import randintfrom time import time, sleepdef download_task(filename):    print(&#39;启动下载进程，进程号[%d].&#39; % getpid())    print(&#39;开始下载%s...&#39; % filename)    time_to_download &#x3D; randint(5, 10)    sleep(time_to_download)    print(&#39;%s下载完成! 耗费了%d秒&#39; % (filename, time_to_download))def main():    start &#x3D; time()    p1 &#x3D; Process(target&#x3D;download_task, args&#x3D;(&#39;Python从入门到住院.pdf&#39;, ))    p1.start()    p2 &#x3D; Process(target&#x3D;download_task, args&#x3D;(&#39;Peking Hot.avi&#39;, ))    p2.start()    p1.join()    p2.join()    end &#x3D; time()    print(&#39;总共耗费了%.2f秒.&#39; % (end - start))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>在上面的代码中，我们通过<code>Process</code>类创建了进程对象，通过<code>target</code>参数我们传入一个函数来表示进程启动后要执行的代码，后面的<code>args</code>是一个元组，它代表了传递给函数的参数。<code>Process</code>对象的<code>start</code>方法用来启动进程，而<code>join</code>方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">启动下载进程，进程号[1530].开始下载Python从入门到住院.pdf...启动下载进程，进程号[1531].开始下载Peking Hot.avi...Peking Hot.avi下载完成! 耗费了7秒Python从入门到住院.pdf下载完成! 耗费了10秒总共耗费了10.01秒.</code></pre><p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from multiprocessing import Processfrom time import sleepcounter &#x3D; 0def sub_task(string):    global counter    while counter &lt; 10:        print(string, end&#x3D;&#39;&#39;, flush&#x3D;True)        counter +&#x3D; 1        sleep(0.01)        def main():    Process(target&#x3D;sub_task, args&#x3D;(&#39;Ping&#39;, )).start()    Process(target&#x3D;sub_task, args&#x3D;(&#39;Pong&#39;, )).start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个<code>counter</code>变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的<code>Queue</code>类，它是可以被多个进程共享的队列，底层是通过管道和<a href="">信号量（semaphore）</a>机制来实现的，有兴趣的读者可以自己尝试一下。</p><h3 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h3><p>在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from random import randintfrom threading import Threadfrom time import time, sleepdef download(filename):    print(&#39;开始下载%s...&#39; % filename)    time_to_download &#x3D; randint(5, 10)    sleep(time_to_download)    print(&#39;%s下载完成! 耗费了%d秒&#39; % (filename, time_to_download))def main():    start &#x3D; time()    t1 &#x3D; Thread(target&#x3D;download, args&#x3D;(&#39;Python从入门到住院.pdf&#39;,))    t1.start()    t2 &#x3D; Thread(target&#x3D;download, args&#x3D;(&#39;Peking Hot.avi&#39;,))    t2.start()    t1.join()    t2.join()    end &#x3D; time()    print(&#39;总共耗费了%.3f秒&#39; % (end - start))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>我们可以直接使用threading模块的<code>Thread</code>类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承<code>Thread</code>类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from random import randintfrom threading import Threadfrom time import time, sleepclass DownloadTask(Thread):    def __init__(self, filename):        super().__init__()        self._filename &#x3D; filename    def run(self):        print(&#39;开始下载%s...&#39; % self._filename)        time_to_download &#x3D; randint(5, 10)        sleep(time_to_download)        print(&#39;%s下载完成! 耗费了%d秒&#39; % (self._filename, time_to_download))def main():    start &#x3D; time()    t1 &#x3D; DownloadTask(&#39;Python从入门到住院.pdf&#39;)    t1.start()    t2 &#x3D; DownloadTask(&#39;Peking Hot.avi&#39;)    t2.start()    t1.join()    t2.join()    end &#x3D; time()    print(&#39;总共耗费了%.2f秒.&#39; % (end - start))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from time import sleepfrom threading import Threadclass Account(object):    def __init__(self):        self._balance &#x3D; 0    def deposit(self, money):        # 计算存款后的余额        new_balance &#x3D; self._balance + money        # 模拟受理存款业务需要0.01秒的时间        sleep(0.01)        # 修改账户余额        self._balance &#x3D; new_balance    @property    def balance(self):        return self._balanceclass AddMoneyThread(Thread):    def __init__(self, account, money):        super().__init__()        self._account &#x3D; account        self._money &#x3D; money    def run(self):        self._account.deposit(self._money)def main():    account &#x3D; Account()    threads &#x3D; []    # 创建100个存款的线程向同一个账户中存钱    for _ in range(100):        t &#x3D; AddMoneyThread(account, 1)        threads.append(t)        t.start()    # 等所有存款的线程都执行完毕    for t in threads:        t.join()    print(&#39;账户余额为: ￥%d元&#39; % account.balance)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到<code>new_balance = self._balance + money</code>这行代码，多个线程得到的账户余额都是初始状态下的<code>0</code>，所以都是<code>0</code>上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from time import sleepfrom threading import Thread, Lockclass Account(object):    def __init__(self):        self._balance &#x3D; 0        self._lock &#x3D; Lock()    def deposit(self, money):        # 先获取锁才能执行后续的代码        self._lock.acquire()        try:            new_balance &#x3D; self._balance + money            sleep(0.01)            self._balance &#x3D; new_balance        finally:            # 在finally中执行释放锁的操作保证正常异常锁都能释放            self._lock.release()    @property    def balance(self):        return self._balanceclass AddMoneyThread(Thread):    def __init__(self, account, money):        super().__init__()        self._account &#x3D; account        self._money &#x3D; money    def run(self):        self._account.deposit(self._money)def main():    account &#x3D; Account()    threads &#x3D; []    for _ in range(100):        t &#x3D; AddMoneyThread(account, 1)        threads.append(t)        t.start()    for t in threads:        t.join()    print(&#39;账户余额为: ￥%d元&#39; % account.balance)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。</p><h3 id="多进程还是多线程"><a href="#多进程还是多线程" class="headerlink" title="多进程还是多线程"></a>多进程还是多线程</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。</p><p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。</p><p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I&#x2F;O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到过Python中有嵌入C&#x2F;C++代码的机制。</p><p>除了计算密集型任务，其他的涉及到网络、存储介质I&#x2F;O的任务都可以视为I&#x2F;O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I&#x2F;O操作完成（因为I&#x2F;O的速度远远低于CPU和内存的速度）。对于I&#x2F;O密集型任务，如果启动多任务，就可以减少I&#x2F;O等待时间从而让CPU高效率的运转。有一大类的任务都属于I&#x2F;O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。</p><blockquote><p><strong>说明：</strong> 上面的内容和例子来自于<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰官方网站的《Python教程》</a>，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。</p></blockquote><h3 id="单线程-异步I-O"><a href="#单线程-异步I-O" class="headerlink" title="单线程+异步I&#x2F;O"></a>单线程+异步I&#x2F;O</h3><p>现代操作系统对I&#x2F;O操作的改进中最为重要的就是支持异步I&#x2F;O。如果充分利用操作系统提供的异步I&#x2F;O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I&#x2F;O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下并发编程的一种流行方案。</p><p>在Python语言中，单线程+异步I&#x2F;O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，在后续的课程中会进行讲解。</p><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="例子1：将耗时间的任务放到线程中以获得更好的用户体验。"><a href="#例子1：将耗时间的任务放到线程中以获得更好的用户体验。" class="headerlink" title="例子1：将耗时间的任务放到线程中以获得更好的用户体验。"></a>例子1：将耗时间的任务放到线程中以获得更好的用户体验。</h4><p>如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import timeimport tkinterimport tkinter.messageboxdef download():    # 模拟下载任务需要花费10秒钟时间    time.sleep(10)    tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;下载完成!&#39;)def show_about():    tkinter.messagebox.showinfo(&#39;关于&#39;, &#39;作者: 骆昊(v1.0)&#39;)def main():    top &#x3D; tkinter.Tk()    top.title(&#39;单线程&#39;)    top.geometry(&#39;200x150&#39;)    top.wm_attributes(&#39;-topmost&#39;, True)    panel &#x3D; tkinter.Frame(top)    button1 &#x3D; tkinter.Button(panel, text&#x3D;&#39;下载&#39;, command&#x3D;download)    button1.pack(side&#x3D;&#39;left&#39;)    button2 &#x3D; tkinter.Button(panel, text&#x3D;&#39;关于&#39;, command&#x3D;show_about)    button2.pack(side&#x3D;&#39;right&#39;)    panel.pack(side&#x3D;&#39;bottom&#39;)    tkinter.mainloop()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import timeimport tkinterimport tkinter.messageboxfrom threading import Threaddef main():    class DownloadTaskHandler(Thread):        def run(self):            time.sleep(10)            tkinter.messagebox.showinfo(&#39;提示&#39;, &#39;下载完成!&#39;)            # 启用下载按钮            button1.config(state&#x3D;tkinter.NORMAL)    def download():        # 禁用下载按钮        button1.config(state&#x3D;tkinter.DISABLED)        # 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行)        # 在线程中处理耗时间的下载任务        DownloadTaskHandler(daemon&#x3D;True).start()    def show_about():        tkinter.messagebox.showinfo(&#39;关于&#39;, &#39;作者: 骆昊(v1.0)&#39;)    top &#x3D; tkinter.Tk()    top.title(&#39;单线程&#39;)    top.geometry(&#39;200x150&#39;)    top.wm_attributes(&#39;-topmost&#39;, 1)    panel &#x3D; tkinter.Frame(top)    button1 &#x3D; tkinter.Button(panel, text&#x3D;&#39;下载&#39;, command&#x3D;download)    button1.pack(side&#x3D;&#39;left&#39;)    button2 &#x3D; tkinter.Button(panel, text&#x3D;&#39;关于&#39;, command&#x3D;show_about)    button2.pack(side&#x3D;&#39;right&#39;)    panel.pack(side&#x3D;&#39;bottom&#39;)    tkinter.mainloop()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="例子2：使用多进程对复杂任务进行“分而治之”。"><a href="#例子2：使用多进程对复杂任务进行“分而治之”。" class="headerlink" title="例子2：使用多进程对复杂任务进行“分而治之”。"></a>例子2：使用多进程对复杂任务进行“分而治之”。</h4><p>我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from time import timedef main():    total &#x3D; 0    number_list &#x3D; [x for x in range(1, 100000001)]    start &#x3D; time()    for number in number_list:        total +&#x3D; number    print(total)    end &#x3D; time()    print(&#39;Execution time: %.3fs&#39; % (end - start))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from multiprocessing import Process, Queuefrom random import randintfrom time import timedef task_handler(curr_list, result_queue):    total &#x3D; 0    for number in curr_list:        total +&#x3D; number    result_queue.put(total)def main():    processes &#x3D; []    number_list &#x3D; [x for x in range(1, 100000001)]    result_queue &#x3D; Queue()    index &#x3D; 0    # 启动8个进程将数据切片后进行运算    for _ in range(8):        p &#x3D; Process(target&#x3D;task_handler,                    args&#x3D;(number_list[index:index + 12500000], result_queue))        index +&#x3D; 12500000        processes.append(p)        p.start()    # 开始记录所有进程执行完成花费的时间    start &#x3D; time()    for p in processes:        p.join()    # 合并执行结果    total &#x3D; 0    while not result_queue.empty():        total +&#x3D; result_queue.get()    print(total)    end &#x3D; time()    print(&#39;Execution time: &#39;, (end - start), &#39;s&#39;, sep&#x3D;&#39;&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过<code>multiprocessing.managers</code>模块中提供的管理器将<code>Queue</code>对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进程和线程&quot;&gt;&lt;a href=&quot;#进程和线程&quot; class=&quot;headerlink&quot; title=&quot;进程和线程&quot;&gt;&lt;/a&gt;进程和线程&lt;/h2&gt;&lt;p&gt;今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>14.网络编程入门和网络应用开发</title>
    <link href="http://wstcly.xyz/2024/07/01/14.wang-luo-bian-cheng-ru-men-he-wang-luo-ying-yong-kai-fa/"/>
    <id>http://wstcly.xyz/2024/07/01/14.wang-luo-bian-cheng-ru-men-he-wang-luo-ying-yong-kai-fa/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:02.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="网络编程入门"><a href="#网络编程入门" class="headerlink" title="网络编程入门"></a>网络编程入门</h2><h3 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h3><p>计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个“复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读Andrew S.Tanenbaum老师的经典之作《计算机网络》或Kurose和Ross老师合著的《计算机网络:自顶向下方法》来了解计算机网络的相关知识。</p><h4 id="计算机网络发展史"><a href="#计算机网络发展史" class="headerlink" title="计算机网络发展史"></a>计算机网络发展史</h4><ol><li><p>1960s - 美国国防部ARPANET项目问世，奠定了分组交换网络的基础。</p><p><img src="/./res/arpanet.png"></p></li><li><p>1980s - 国际标准化组织（ISO）发布OSI&#x2F;RM，奠定了网络技术标准化的基础。</p><p><img src="/./res/osimodel.png"></p></li><li><p>1990s - 英国人<a href="https://zh.wikipedia.org/wiki/%E6%8F%90%E5%A7%86%C2%B7%E6%9F%8F%E5%85%A7%E8%8C%B2-%E6%9D%8E">蒂姆·伯纳斯-李</a>发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速被普及。</p><p>在没有浏览器的年代，上网是这样的。</p><p><img src="/./res/before-browser.jpg"></p><p>有了浏览器以后，上网是这样的。</p><p><img src="/./res/after-browser.jpg"></p></li></ol><h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h4><p>实现网络通信的基础是网络通信协议，这些协议通常是由<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84">互联网工程任务组</a> （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP&#x2F;IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP&#x2F;IP模型。与国际标准化组织发布的OSI&#x2F;RM这个七层模型不同，TCP&#x2F;IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。</p><p><img src="/./res/TCP-IP-model.png"></p><p>IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个<a href="https://zh.wikipedia.org/zh-hans/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网（LAN）</a>中的内部IP地址，通过<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">网络地址转换（NAT）服务</a>我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8">路由器</a>”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。</p><p>TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情：</p><ol><li>数据不传丢不传错（利用握手、校验和重传机制可以实现）。</li><li>流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。</li><li>拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。</li></ol><h4 id="网络应用模式"><a href="#网络应用模式" class="headerlink" title="网络应用模式"></a>网络应用模式</h4><ol><li>C&#x2F;S模式和B&#x2F;S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。</li><li>去中心化的网络应用模式。不管是B&#x2F;S还是C&#x2F;S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。</li></ol><h3 id="基于HTTP协议的网络资源访问"><a href="#基于HTTP协议的网络资源访问" class="headerlink" title="基于HTTP协议的网络资源访问"></a>基于HTTP协议的网络资源访问</h3><h4 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h4><p>HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2">万维网</a>数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收<a href="https://zh.wikipedia.org/wiki/HTML">HTML</a>页面的方法，通过HTTP或者<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE">HTTPS</a>（超文本传输安全协议）请求的资源由URI（<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E8%B3%87%E6%BA%90%E6%A8%99%E8%AD%98%E7%AC%A6">统一资源标识符</a>）来标识。关于HTTP的更多内容，我们推荐阅读阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html">《HTTP 协议入门》</a>，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。</p><h4 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h4><p><strong>JSON</strong>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和<a href="https://zh.wikipedia.org/wiki/XML">XML</a>一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。</p><p>XML的例子：</p><pre class="language-XML" data-language="XML"><code class="language-XML">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;message&gt;&lt;from&gt;Alice&lt;&#x2F;from&gt;&lt;to&gt;Bob&lt;&#x2F;to&gt;&lt;content&gt;Will you marry me?&lt;&#x2F;content&gt;&lt;&#x2F;message&gt;</code></pre><p>JSON的例子：</p><pre class="language-JSON" data-language="JSON"><code class="language-JSON">&#123;    &quot;from&quot;: &quot;Alice&quot;,    &quot;to&quot;: &quot;Bob&quot;,    &quot;content&quot;: &quot;Will you marry me?&quot;&#125;</code></pre><h4 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h4><p>requests是一个基于HTTP协议来使用网络的第三库，其<a href="http://cn.python-requests.org/zh_CN/latest/">官方网站</a>有这样的一句介绍它的话：“Requests是唯一的一个<strong>非转基因</strong>的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了<a href="https://www.tianapi.com/">天行数据</a>提供的网络API。</p><p>我们可以先通过pip安装requests及其依赖库。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">pip install requests</code></pre><p>如果使用PyCharm作为开发工具，可以直接在代码中书写<code>import requests</code>，然后通过代码修复功能来自动下载安装requests。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from time import timefrom threading import Threadimport requests# 继承Thread类创建自定义的线程类class DownloadHanlder(Thread):    def __init__(self, url):        super().__init__()        self.url &#x3D; url    def run(self):        filename &#x3D; self.url[self.url.rfind(&#39;&#x2F;&#39;) + 1:]        resp &#x3D; requests.get(self.url)        with open(&#39;&#x2F;Users&#x2F;Hao&#x2F;&#39; + filename, &#39;wb&#39;) as f:            f.write(resp.content)def main():    # 通过requests模块的get函数获取网络资源    # 下面的代码中使用了天行数据接口提供的网络API    # 要使用该数据接口需要在天行数据的网站上注册    # 然后用自己的Key替换掉下面代码的中APIKey即可    resp &#x3D; requests.get(        &#39;http:&#x2F;&#x2F;api.tianapi.com&#x2F;meinv&#x2F;?key&#x3D;APIKey&amp;num&#x3D;10&#39;)    # 将服务器返回的JSON格式的数据解析为字典    data_model &#x3D; resp.json()    for mm_dict in data_model[&#39;newslist&#39;]:        url &#x3D; mm_dict[&#39;picUrl&#39;]        # 通过多线程的方式实现图片下载        DownloadHanlder(url).start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h3 id="基于传输层协议的套接字编程"><a href="#基于传输层协议的套接字编程" class="headerlink" title="基于传输层协议的套接字编程"></a>基于传输层协议的套接字编程</h3><p>套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80">C语言</a>写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。</p><h4 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h4><p>所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。</p><p>下面的代码实现了一个提供时间日期的服务器。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from socket import socket, SOCK_STREAM, AF_INETfrom datetime import datetimedef main():    # 1.创建套接字对象并指定使用哪种传输服务    # family&#x3D;AF_INET - IPv4地址    # family&#x3D;AF_INET6 - IPv6地址    # type&#x3D;SOCK_STREAM - TCP套接字    # type&#x3D;SOCK_DGRAM - UDP套接字    # type&#x3D;SOCK_RAW - 原始套接字    server &#x3D; socket(family&#x3D;AF_INET, type&#x3D;SOCK_STREAM)    # 2.绑定IP地址和端口(端口用于区分不同的服务)    # 同一时间在同一个端口上只能绑定一个服务否则报错    server.bind((&#39;192.168.1.2&#39;, 6789))    # 3.开启监听 - 监听客户端连接到服务器    # 参数512可以理解为连接队列的大小    server.listen(512)    print(&#39;服务器启动开始监听...&#39;)    while True:        # 4.通过循环接收客户端的连接并作出相应的处理(提供服务)        # accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行        # accept方法返回一个元组其中的第一个元素是客户端对象        # 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)        client, addr &#x3D; server.accept()        print(str(addr) + &#39;连接到了服务器.&#39;)        # 5.发送数据        client.send(str(datetime.now()).encode(&#39;utf-8&#39;))        # 6.断开连接        client.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">telnet 192.168.1.2 6789</code></pre><p><img src="/./res/telnet.png"></p><p>当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from socket import socketdef main():    # 1.创建套接字对象默认使用IPv4和TCP协议    client &#x3D; socket()    # 2.连接到服务器(需要指定IP地址和端口)    client.connect((&#39;192.168.1.2&#39;, 6789))    # 3.从服务器接收数据    print(client.recv(1024).decode(&#39;utf-8&#39;))    client.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>需要注意的是，上面的服务器并没有使用多线程或者异步I&#x2F;O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。</p><p>服务器端代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">from socket import socket, SOCK_STREAM, AF_INETfrom base64 import b64encodefrom json import dumpsfrom threading import Threaddef main():        # 自定义线程类    class FileTransferHandler(Thread):        def __init__(self, cclient):            super().__init__()            self.cclient &#x3D; cclient        def run(self):            my_dict &#x3D; &#123;&#125;            my_dict[&#39;filename&#39;] &#x3D; &#39;guido.jpg&#39;            # JSON是纯文本不能携带二进制数据            # 所以图片的二进制数据要处理成base64编码            my_dict[&#39;filedata&#39;] &#x3D; data            # 通过dumps函数将字典处理成JSON字符串            json_str &#x3D; dumps(my_dict)            # 发送JSON字符串            self.cclient.send(json_str.encode(&#39;utf-8&#39;))            self.cclient.close()    # 1.创建套接字对象并指定使用哪种传输服务    server &#x3D; socket()    # 2.绑定IP地址和端口(区分不同的服务)    server.bind((&#39;192.168.1.2&#39;, 5566))    # 3.开启监听 - 监听客户端连接到服务器    server.listen(512)    print(&#39;服务器启动开始监听...&#39;)    with open(&#39;guido.jpg&#39;, &#39;rb&#39;) as f:        # 将二进制数据处理成base64再解码成字符串        data &#x3D; b64encode(f.read()).decode(&#39;utf-8&#39;)    while True:        client, addr &#x3D; server.accept()        # 启动一个线程来处理客户端的请求        FileTransferHandler(client).start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>客户端代码：</p><pre class="language-Python" data-language="Python"><code class="language-Python">from socket import socketfrom json import loadsfrom base64 import b64decodedef main():    client &#x3D; socket()    client.connect((&#39;192.168.1.2&#39;, 5566))    # 定义一个保存二进制数据的对象    in_data &#x3D; bytes()    # 由于不知道服务器发送的数据有多大每次接收1024字节    data &#x3D; client.recv(1024)    while data:        # 将收到的数据拼接起来        in_data +&#x3D; data        data &#x3D; client.recv(1024)    # 将收到的二进制数据解码成JSON字符串并转换成字典    # loads函数的作用就是将JSON字符串转成字典对象    my_dict &#x3D; loads(in_data.decode(&#39;utf-8&#39;))    filename &#x3D; my_dict[&#39;filename&#39;]    filedata &#x3D; my_dict[&#39;filedata&#39;].encode(&#39;utf-8&#39;)    with open(&#39;&#x2F;Users&#x2F;Hao&#x2F;&#39; + filename, &#39;wb&#39;) as f:        # 将base64格式的数据解码成二进制数据并写入文件        f.write(b64decode(filedata))    print(&#39;图片已保存.&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“&#x2F;”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态。<a href="https://zh.wikipedia.org/wiki/Base64">维基百科</a>上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。</p><blockquote><p><strong>说明：</strong> 上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。</p></blockquote><h4 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h4><p>传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。</p><h3 id="网络应用开发"><a href="#网络应用开发" class="headerlink" title="网络应用开发"></a>网络应用开发</h3><h4 id="发送电子邮件"><a href="#发送电子邮件" class="headerlink" title="发送电子邮件"></a>发送电子邮件</h4><p>在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。</p><p>就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。</p><p>下面的代码演示了如何在Python发送邮件。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextdef main():    # 请自行修改下面的邮件发送者和接收者    sender &#x3D; &#39;abcdefg@126.com&#39;    receivers &#x3D; [&#39;uvwxyz@qq.com&#39;, &#39;uvwxyz@126.com&#39;]    message &#x3D; MIMEText(&#39;用Python发送邮件的示例代码.&#39;, &#39;plain&#39;, &#39;utf-8&#39;)    message[&#39;From&#39;] &#x3D; Header(&#39;王大锤&#39;, &#39;utf-8&#39;)    message[&#39;To&#39;] &#x3D; Header(&#39;骆昊&#39;, &#39;utf-8&#39;)    message[&#39;Subject&#39;] &#x3D; Header(&#39;示例代码实验邮件&#39;, &#39;utf-8&#39;)    smtper &#x3D; SMTP(&#39;smtp.126.com&#39;)    # 请自行修改下面的登录口令    smtper.login(sender, &#39;secretpass&#39;)    smtper.sendmail(sender, receivers, message.as_string())    print(&#39;邮件发送完成!&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from smtplib import SMTPfrom email.header import Headerfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.mime.multipart import MIMEMultipartimport urllibdef main():    # 创建一个带附件的邮件消息对象    message &#x3D; MIMEMultipart()        # 创建文本内容    text_content &#x3D; MIMEText(&#39;附件中有本月数据请查收&#39;, &#39;plain&#39;, &#39;utf-8&#39;)    message[&#39;Subject&#39;] &#x3D; Header(&#39;本月数据&#39;, &#39;utf-8&#39;)    # 将文本内容添加到邮件消息对象中    message.attach(text_content)    # 读取文件并将文件作为附件添加到邮件消息对象中    with open(&#39;&#x2F;Users&#x2F;Hao&#x2F;Desktop&#x2F;hello.txt&#39;, &#39;rb&#39;) as f:        txt &#x3D; MIMEText(f.read(), &#39;base64&#39;, &#39;utf-8&#39;)        txt[&#39;Content-Type&#39;] &#x3D; &#39;text&#x2F;plain&#39;        txt[&#39;Content-Disposition&#39;] &#x3D; &#39;attachment; filename&#x3D;hello.txt&#39;        message.attach(txt)    # 读取文件并将文件作为附件添加到邮件消息对象中    with open(&#39;&#x2F;Users&#x2F;Hao&#x2F;Desktop&#x2F;汇总数据.xlsx&#39;, &#39;rb&#39;) as f:        xls &#x3D; MIMEText(f.read(), &#39;base64&#39;, &#39;utf-8&#39;)        xls[&#39;Content-Type&#39;] &#x3D; &#39;application&#x2F;vnd.ms-excel&#39;        xls[&#39;Content-Disposition&#39;] &#x3D; &#39;attachment; filename&#x3D;month-data.xlsx&#39;        message.attach(xls)        # 创建SMTP对象    smtper &#x3D; SMTP(&#39;smtp.126.com&#39;)    # 开启安全连接    # smtper.starttls()    sender &#x3D; &#39;abcdefg@126.com&#39;    receivers &#x3D; [&#39;uvwxyz@qq.com&#39;]    # 登录到SMTP服务器    # 请注意此处不是使用密码而是邮件客户端授权码进行登录    # 对此有疑问的读者可以联系自己使用的邮件服务器客服    smtper.login(sender, &#39;secretpass&#39;)    # 发送邮件    smtper.sendmail(sender, receivers, message.as_string())    # 与邮件服务器断开连接    smtper.quit()    print(&#39;发送完成!&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><h4 id="发送短信"><a href="#发送短信" class="headerlink" title="发送短信"></a>发送短信</h4><p>发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了<a href="http://www.ihuyi.com/">互亿无线</a>短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import urllib.parseimport http.clientimport jsondef main():    host  &#x3D; &quot;106.ihuyi.com&quot;    sms_send_uri &#x3D; &quot;&#x2F;webservice&#x2F;sms.php?method&#x3D;Submit&quot;    # 下面的参数需要填入自己注册的账号和对应的密码    params &#x3D; urllib.parse.urlencode(&#123;&#39;account&#39;: &#39;你自己的账号&#39;, &#39;password&#39; : &#39;你自己的密码&#39;, &#39;content&#39;: &#39;您的验证码是：147258。请不要把验证码泄露给其他人。&#39;, &#39;mobile&#39;: &#39;接收者的手机号&#39;, &#39;format&#39;:&#39;json&#39; &#125;)    print(params)    headers &#x3D; &#123;&#39;Content-type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;, &#39;Accept&#39;: &#39;text&#x2F;plain&#39;&#125;    conn &#x3D; http.client.HTTPConnection(host, port&#x3D;80, timeout&#x3D;30)    conn.request(&#39;POST&#39;, sms_send_uri, params, headers)    response &#x3D; conn.getresponse()    response_str &#x3D; response.read()    jsonstr &#x3D; response_str.decode(&#39;utf-8&#39;)    print(json.loads(jsonstr))    conn.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;网络编程入门&quot;&gt;&lt;a href=&quot;#网络编程入门&quot; class=&quot;headerlink&quot; title=&quot;网络编程入门&quot;&gt;&lt;/a&gt;网络编程入门&lt;/h2&gt;&lt;h3 id=&quot;计算机网络基础&quot;&gt;&lt;a href=&quot;#计算机网络基础&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>15.图像和办公文档处理</title>
    <link href="http://wstcly.xyz/2024/07/01/15.tu-xiang-he-ban-gong-wen-dang-chu-li/"/>
    <id>http://wstcly.xyz/2024/07/01/15.tu-xiang-he-ban-gong-wen-dang-chu-li/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:02.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图像和办公文档处理"><a href="#图像和办公文档处理" class="headerlink" title="图像和办公文档处理"></a>图像和办公文档处理</h2><p>用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作。</p><h3 id="操作图像"><a href="#操作图像" class="headerlink" title="操作图像"></a>操作图像</h3><h4 id="计算机图像相关知识"><a href="#计算机图像相关知识" class="headerlink" title="计算机图像相关知识"></a>计算机图像相关知识</h4><ol><li><p>颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是被我们称为美术三原色的东西，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。</p><table><thead><tr><th align="center">名称</th><th align="center">RGBA值</th><th align="center">名称</th><th align="center">RGBA值</th></tr></thead><tbody><tr><td align="center">White</td><td align="center">(255, 255, 255, 255)</td><td align="center">Red</td><td align="center">(255, 0, 0, 255)</td></tr><tr><td align="center">Green</td><td align="center">(0, 255, 0, 255)</td><td align="center">Blue</td><td align="center">(0, 0, 255, 255)</td></tr><tr><td align="center">Gray</td><td align="center">(128, 128, 128, 255)</td><td align="center">Yellow</td><td align="center">(255, 255, 0, 255)</td></tr><tr><td align="center">Black</td><td align="center">(0, 0, 0, 255)</td><td align="center">Purple</td><td align="center">(128, 0, 128, 255)</td></tr></tbody></table></li><li><p>像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。</p></li></ol><h4 id="用Pillow操作图像"><a href="#用Pillow操作图像" class="headerlink" title="用Pillow操作图像"></a>用Pillow操作图像</h4><p>Pillow是由从著名的Python图像处理库PIL发展出来的一个分支，通过Pillow可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装Pillow。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">pip install pillow</code></pre><p>Pillow中最为重要的是Image类，读取和处理图像都要通过这个类来完成。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt;&gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;)&gt;&gt;&gt; image.format, image.size, image.mode(&#39;JPEG&#39;, (500, 750), &#39;RGB&#39;)&gt;&gt;&gt; image.show()</code></pre><p><img src="/./res/image-show.png"></p><ol><li><p>剪裁图像</p><pre class="language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;)&gt;&gt;&gt; rect &#x3D; 80, 20, 310, 360&gt;&gt;&gt; image.crop(rect).show()</code></pre><p><img src="/./res/image-crop.png"></p></li><li><p>生成缩略图</p><pre class="language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;)&gt;&gt;&gt; size &#x3D; 128, 128&gt;&gt;&gt; image.thumbnail(size)&gt;&gt;&gt; image.show()</code></pre><p><img src="/./res/image-thumbnail.png"></p></li><li><p>缩放和黏贴图像</p><pre class="language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; image1 &#x3D; Image.open(&#39;.&#x2F;res&#x2F;luohao.png&#39;)&gt;&gt;&gt; image2 &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;)&gt;&gt;&gt; rect &#x3D; 80, 20, 310, 360&gt;&gt;&gt; guido_head &#x3D; image2.crop(rect)&gt;&gt;&gt; width, height &#x3D; guido_head.size&gt;&gt;&gt; image1.paste(guido_head.resize((int(width &#x2F; 1.5), int(height &#x2F; 1.5))), (172, 40))</code></pre><p><img src="/./res/image-paste.png"></p></li><li><p>旋转和翻转</p><pre class="language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.png&#39;)&gt;&gt;&gt; image.rotate(180).show()&gt;&gt;&gt; image.transpose(Image.FLIP_LEFT_RIGHT).show()</code></pre><p><img src="/./res/image-rotate.png"></p><p><img src="/./res/image-transpose.png"></p></li><li><p>操作像素</p><pre class="language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;)&gt;&gt;&gt; for x in range(80, 310):...     for y in range(20, 360):...         image.putpixel((x, y), (128, 128, 128))... &gt;&gt;&gt; image.show()</code></pre><p><img src="/./res/image-putpixel.png"></p></li><li><p>滤镜效果</p><pre class="language-Python" data-language="Python"><code class="language-Python">&gt;&gt;&gt; from PIL import Image, ImageFilter&gt;&gt;&gt;&gt;&gt;&gt; image &#x3D; Image.open(&#39;.&#x2F;res&#x2F;guido.jpg&#39;)&gt;&gt;&gt; image.filter(ImageFilter.CONTOUR).show()</code></pre><p><img src="/./res/image-filter.png"></p></li></ol><h3 id="处理Excel电子表格"><a href="#处理Excel电子表格" class="headerlink" title="处理Excel电子表格"></a>处理Excel电子表格</h3><p>Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，由于微软从Office 2007开始使用了新的文件格式，这使得Office Excel和LibreOffice Calc、OpenOffice Calc是完全兼容的，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import datetimefrom openpyxl import Workbookwb &#x3D; Workbook()ws &#x3D; wb.activews[&#39;A1&#39;] &#x3D; 42ws.append([1, 2, 3])ws[&#39;A2&#39;] &#x3D; datetime.datetime.now()wb.save(&quot;sample.xlsx&quot;)</code></pre><h3 id="处理Word文档"><a href="#处理Word文档" class="headerlink" title="处理Word文档"></a>处理Word文档</h3><p>利用python-docx模块，Python可以创建和修改Word文档，当然这里的Word文档不仅仅是指通过微软的Office软件创建的扩展名为docx的文档，LibreOffice Writer和OpenOffice Writer都是免费的字处理软件。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from docx import Documentfrom docx.shared import Inchesdocument &#x3D; Document()document.add_heading(&#39;Document Title&#39;, 0)p &#x3D; document.add_paragraph(&#39;A plain paragraph having some &#39;)p.add_run(&#39;bold&#39;).bold &#x3D; Truep.add_run(&#39; and some &#39;)p.add_run(&#39;italic.&#39;).italic &#x3D; Truedocument.add_heading(&#39;Heading, level 1&#39;, level&#x3D;1)document.add_paragraph(&#39;Intense quote&#39;, style&#x3D;&#39;Intense Quote&#39;)document.add_paragraph(    &#39;first item in unordered list&#39;, style&#x3D;&#39;List Bullet&#39;)document.add_paragraph(    &#39;first item in ordered list&#39;, style&#x3D;&#39;List Number&#39;)document.add_picture(&#39;monty-truth.png&#39;, width&#x3D;Inches(1.25))records &#x3D; (    (3, &#39;101&#39;, &#39;Spam&#39;),    (7, &#39;422&#39;, &#39;Eggs&#39;),    (4, &#39;631&#39;, &#39;Spam, spam, eggs, and spam&#39;))table &#x3D; document.add_table(rows&#x3D;1, cols&#x3D;3)hdr_cells &#x3D; table.rows[0].cellshdr_cells[0].text &#x3D; &#39;Qty&#39;hdr_cells[1].text &#x3D; &#39;Id&#39;hdr_cells[2].text &#x3D; &#39;Desc&#39;for qty, id, desc in records:    row_cells &#x3D; table.add_row().cells    row_cells[0].text &#x3D; str(qty)    row_cells[1].text &#x3D; id    row_cells[2].text &#x3D; descdocument.add_page_break()document.save(&#39;demo.docx&#39;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图像和办公文档处理&quot;&gt;&lt;a href=&quot;#图像和办公文档处理&quot; class=&quot;headerlink&quot; title=&quot;图像和办公文档处理&quot;&gt;&lt;/a&gt;图像和办公文档处理&lt;/h2&gt;&lt;p&gt;用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>16-20.Python语言进阶</title>
    <link href="http://wstcly.xyz/2024/07/01/16-20.python-yu-yan-jin-jie/"/>
    <id>http://wstcly.xyz/2024/07/01/16-20.python-yu-yan-jin-jie/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:09.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python语言进阶"><a href="#Python语言进阶" class="headerlink" title="Python语言进阶"></a>Python语言进阶</h2><h3 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h3><ul><li><p>生成式（推导式）的用法</p><pre class="language-Python" data-language="Python"><code class="language-Python">prices &#x3D; &#123;    &#39;AAPL&#39;: 191.88,    &#39;GOOG&#39;: 1186.96,    &#39;IBM&#39;: 149.24,    &#39;ORCL&#39;: 48.44,    &#39;ACN&#39;: 166.89,    &#39;FB&#39;: 208.09,    &#39;SYMC&#39;: 21.29&#125;# 用股票价格大于100元的股票构造一个新的字典prices2 &#x3D; &#123;key: value for key, value in prices.items() if value &gt; 100&#125;print(prices2)</code></pre><blockquote><p>说明：生成式（推导式）可以用来生成列表、集合和字典。</p></blockquote></li><li><p>嵌套的列表的坑</p><pre class="language-Python" data-language="Python"><code class="language-Python">names &#x3D; [&#39;关羽&#39;, &#39;张飞&#39;, &#39;赵云&#39;, &#39;马超&#39;, &#39;黄忠&#39;]courses &#x3D; [&#39;语文&#39;, &#39;数学&#39;, &#39;英语&#39;]# 录入五个学生三门课程的成绩# 错误 - 参考http:&#x2F;&#x2F;pythontutor.com&#x2F;visualize.html#mode&#x3D;edit# scores &#x3D; [[None] * len(courses)] * len(names)scores &#x3D; [[None] * len(courses) for _ in range(len(names))]for row, name in enumerate(names):    for col, course in enumerate(courses):        scores[row][col] &#x3D; float(input(f&#39;请输入&#123;name&#125;的&#123;course&#125;成绩: &#39;))        print(scores)</code></pre><p><a href="http://pythontutor.com/">Python Tutor</a> - VISUALIZE CODE AND GET LIVE HELP</p></li><li><p><code>heapq</code>模块（堆排序）</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;从列表中找出最大的或最小的N个元素堆结构(大根堆&#x2F;小根堆)&quot;&quot;&quot;import heapqlist1 &#x3D; [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]list2 &#x3D; [    &#123;&#39;name&#39;: &#39;IBM&#39;, &#39;shares&#39;: 100, &#39;price&#39;: 91.1&#125;,    &#123;&#39;name&#39;: &#39;AAPL&#39;, &#39;shares&#39;: 50, &#39;price&#39;: 543.22&#125;,    &#123;&#39;name&#39;: &#39;FB&#39;, &#39;shares&#39;: 200, &#39;price&#39;: 21.09&#125;,    &#123;&#39;name&#39;: &#39;HPQ&#39;, &#39;shares&#39;: 35, &#39;price&#39;: 31.75&#125;,    &#123;&#39;name&#39;: &#39;YHOO&#39;, &#39;shares&#39;: 45, &#39;price&#39;: 16.35&#125;,    &#123;&#39;name&#39;: &#39;ACME&#39;, &#39;shares&#39;: 75, &#39;price&#39;: 115.65&#125;]print(heapq.nlargest(3, list1))print(heapq.nsmallest(3, list1))print(heapq.nlargest(2, list2, key&#x3D;lambda x: x[&#39;price&#39;]))print(heapq.nlargest(2, list2, key&#x3D;lambda x: x[&#39;shares&#39;]))</code></pre></li><li><p><code>itertools</code>模块</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;迭代工具模块&quot;&quot;&quot;import itertools# 产生ABCD的全排列itertools.permutations(&#39;ABCD&#39;)# 产生ABCDE的五选三组合itertools.combinations(&#39;ABCDE&#39;, 3)# 产生ABCD和123的笛卡尔积itertools.product(&#39;ABCD&#39;, &#39;123&#39;)# 产生ABC的无限循环序列itertools.cycle((&#39;A&#39;, &#39;B&#39;, &#39;C&#39;))</code></pre></li><li><p><code>collections</code>模块</p><p>常用的工具类：</p><ul><li><code>namedtuple</code>：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。</li><li><code>deque</code>：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而deque底层是双向链表，因此当你需要在头尾添加和删除元素时，deque会表现出更好的性能，渐近时间复杂度为$O(1)$。</li><li><code>Counter</code>：<code>dict</code>的子类，键是元素，值是元素的计数，它的<code>most_common()</code>方法可以帮助我们获取出现频率最高的元素。<code>Counter</code>和<code>dict</code>的继承关系我认为是值得商榷的，按照CARP原则，<code>Counter</code>跟<code>dict</code>的关系应该设计为关联关系更为合理。</li><li><code>OrderedDict</code>：<code>dict</code>的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。</li><li><code>defaultdict</code>：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的<code>setdefault()</code>方法，这种做法更加高效。</li></ul><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;找出序列中出现次数最多的元素&quot;&quot;&quot;from collections import Counterwords &#x3D; [    &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;,    &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;not&#39;, &#39;around&#39;,    &#39;the&#39;, &#39;eyes&#39;, &quot;don&#39;t&quot;, &#39;look&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;,    &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &quot;you&#39;re&quot;, &#39;under&#39;]counter &#x3D; Counter(words)print(counter.most_common(3))</code></pre></li></ul><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul><li><p>算法：解决问题的方法和步骤</p></li><li><p>评价算法的好坏：渐近时间复杂度和渐近空间复杂度。</p></li><li><p>渐近时间复杂度的大O标记：</p><ul><li><img src="http://latex.codecogs.com/gif.latex?O(c)" /> - 常量时间复杂度 - 布隆过滤器 &#x2F; 哈希存储</li><li><img src="http://latex.codecogs.com/gif.latex?O(log_2n)" /> - 对数时间复杂度 - 折半查找（二分查找）</li><li><img src="http://latex.codecogs.com/gif.latex?O(n)" /> - 线性时间复杂度 - 顺序查找 &#x2F; 计数排序</li><li><img src="http://latex.codecogs.com/gif.latex?O(n*log_2n)" /> - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序）</li><li><img src="http://latex.codecogs.com/gif.latex?O(n^2)" /> - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序）</li><li><img src="http://latex.codecogs.com/gif.latex?O(n^3)" /> - 立方时间复杂度 - Floyd算法 &#x2F; 矩阵乘法运算</li><li><img src="http://latex.codecogs.com/gif.latex?O(2^n)" /> - 几何级数时间复杂度 - 汉诺塔</li><li><img src="http://latex.codecogs.com/gif.latex?O(n!)" /> - 阶乘时间复杂度 - 旅行经销商问题 - NPC</li></ul><p><img src="/./res/algorithm_complexity_1.png"></p><p><img src="/./res/algorithm_complexity_2.png"></p></li><li><p>排序算法（选择、冒泡和归并）和查找算法（顺序和折半）</p><pre class="language-Python" data-language="Python"><code class="language-Python">def select_sort(items, comp&#x3D;lambda x, y: x &lt; y):    &quot;&quot;&quot;简单选择排序&quot;&quot;&quot;    items &#x3D; items[:]    for i in range(len(items) - 1):        min_index &#x3D; i        for j in range(i + 1, len(items)):            if comp(items[j], items[min_index]):                min_index &#x3D; j        items[i], items[min_index] &#x3D; items[min_index], items[i]    return items</code></pre><pre class="language-Python" data-language="Python"><code class="language-Python">def bubble_sort(items, comp&#x3D;lambda x, y: x &gt; y):    &quot;&quot;&quot;冒泡排序&quot;&quot;&quot;    items &#x3D; items[:]    for i in range(len(items) - 1):        swapped &#x3D; False        for j in range(len(items) - 1 - i):            if comp(items[j], items[j + 1]):                items[j], items[j + 1] &#x3D; items[j + 1], items[j]                swapped &#x3D; True        if not swapped:            break    return items</code></pre><pre class="language-Python" data-language="Python"><code class="language-Python">def bubble_sort(items, comp&#x3D;lambda x, y: x &gt; y):    &quot;&quot;&quot;搅拌排序(冒泡排序升级版)&quot;&quot;&quot;    items &#x3D; items[:]    for i in range(len(items) - 1):        swapped &#x3D; False        for j in range(len(items) - 1 - i):            if comp(items[j], items[j + 1]):                items[j], items[j + 1] &#x3D; items[j + 1], items[j]                swapped &#x3D; True        if swapped:            swapped &#x3D; False            for j in range(len(items) - 2 - i, i, -1):                if comp(items[j - 1], items[j]):                    items[j], items[j - 1] &#x3D; items[j - 1], items[j]                    swapped &#x3D; True        if not swapped:            break    return items</code></pre><pre class="language-Python" data-language="Python"><code class="language-Python">def merge(items1, items2, comp&#x3D;lambda x, y: x &lt; y):    &quot;&quot;&quot;合并(将两个有序的列表合并成一个有序的列表)&quot;&quot;&quot;    items &#x3D; []    index1, index2 &#x3D; 0, 0    while index1 &lt; len(items1) and index2 &lt; len(items2):        if comp(items1[index1], items2[index2]):            items.append(items1[index1])            index1 +&#x3D; 1        else:            items.append(items2[index2])            index2 +&#x3D; 1    items +&#x3D; items1[index1:]    items +&#x3D; items2[index2:]    return itemsdef merge_sort(items, comp&#x3D;lambda x, y: x &lt; y):    return _merge_sort(list(items), comp)def _merge_sort(items, comp):    &quot;&quot;&quot;归并排序&quot;&quot;&quot;    if len(items) &lt; 2:        return items    mid &#x3D; len(items) &#x2F;&#x2F; 2    left &#x3D; _merge_sort(items[:mid], comp)    right &#x3D; _merge_sort(items[mid:], comp)    return merge(left, right, comp)</code></pre><pre class="language-Python" data-language="Python"><code class="language-Python">def seq_search(items, key):    &quot;&quot;&quot;顺序查找&quot;&quot;&quot;    for index, item in enumerate(items):        if item &#x3D;&#x3D; key:            return index    return -1</code></pre><pre class="language-Python" data-language="Python"><code class="language-Python">def bin_search(items, key):    &quot;&quot;&quot;折半查找&quot;&quot;&quot;    start, end &#x3D; 0, len(items) - 1    while start &lt;&#x3D; end:        mid &#x3D; (start + end) &#x2F;&#x2F; 2        if key &gt; items[mid]:            start &#x3D; mid + 1        elif key &lt; items[mid]:            end &#x3D; mid - 1        else:            return mid    return -1</code></pre></li><li><p>常用算法：</p><ul><li>穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。</li><li>贪婪法 - 在对问题求解时，总是做出在当前看来</li><li>最好的选择，不追求最优解，快速找到满意解。</li><li>分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。</li><li>回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。</li><li>动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。</li></ul><p>穷举法例子：百钱百鸡和五人分鱼。</p><pre class="language-Python" data-language="Python"><code class="language-Python"># 公鸡5元一只 母鸡3元一只 小鸡1元三只# 用100元买100只鸡 问公鸡&#x2F;母鸡&#x2F;小鸡各多少只for x in range(20):    for y in range(33):        z &#x3D; 100 - x - y        if 5 * x + 3 * y + z &#x2F;&#x2F; 3 &#x3D;&#x3D; 100 and z % 3 &#x3D;&#x3D; 0:            print(x, y, z)# A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉# 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份# B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份# 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼fish &#x3D; 6while True:    total &#x3D; fish    enough &#x3D; True    for _ in range(5):        if (total - 1) % 5 &#x3D;&#x3D; 0:            total &#x3D; (total - 1) &#x2F;&#x2F; 5 * 4        else:            enough &#x3D; False            break    if enough:        print(fish)        break    fish +&#x3D; 5</code></pre><p>贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。</p><table><thead><tr><th align="center">名称</th><th align="center">价格（美元）</th><th align="center">重量（kg）</th></tr></thead><tbody><tr><td align="center">电脑</td><td align="center">200</td><td align="center">20</td></tr><tr><td align="center">收音机</td><td align="center">20</td><td align="center">4</td></tr><tr><td align="center">钟</td><td align="center">175</td><td align="center">10</td></tr><tr><td align="center">花瓶</td><td align="center">50</td><td align="center">2</td></tr><tr><td align="center">书</td><td align="center">10</td><td align="center">1</td></tr><tr><td align="center">油画</td><td align="center">90</td><td align="center">9</td></tr></tbody></table><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。输入：20 6电脑 200 20收音机 20 4钟 175 10花瓶 50 2书 10 1油画 90 9&quot;&quot;&quot;class Thing(object):    &quot;&quot;&quot;物品&quot;&quot;&quot;    def __init__(self, name, price, weight):        self.name &#x3D; name        self.price &#x3D; price        self.weight &#x3D; weight    @property    def value(self):        &quot;&quot;&quot;价格重量比&quot;&quot;&quot;        return self.price &#x2F; self.weightdef input_thing():    &quot;&quot;&quot;输入物品信息&quot;&quot;&quot;    name_str, price_str, weight_str &#x3D; input().split()    return name_str, int(price_str), int(weight_str)def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    max_weight, num_of_things &#x3D; map(int, input().split())    all_things &#x3D; []    for _ in range(num_of_things):        all_things.append(Thing(*input_thing()))    all_things.sort(key&#x3D;lambda x: x.value, reverse&#x3D;True)    total_weight &#x3D; 0    total_price &#x3D; 0    for thing in all_things:        if total_weight + thing.weight &lt;&#x3D; max_weight:            print(f&#39;小偷拿走了&#123;thing.name&#125;&#39;)            total_weight +&#x3D; thing.weight            total_price +&#x3D; thing.price    print(f&#39;总价值: &#123;total_price&#125;美元&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>分治法例子：<a href="https://zh.wikipedia.org/zh/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大&quot;&quot;&quot;def quick_sort(items, comp&#x3D;lambda x, y: x &lt;&#x3D; y):    items &#x3D; list(items)[:]    _quick_sort(items, 0, len(items) - 1, comp)    return itemsdef _quick_sort(items, start, end, comp):    if start &lt; end:        pos &#x3D; _partition(items, start, end, comp)        _quick_sort(items, start, pos - 1, comp)        _quick_sort(items, pos + 1, end, comp)def _partition(items, start, end, comp):    pivot &#x3D; items[end]    i &#x3D; start - 1    for j in range(start, end):        if comp(items[j], pivot):            i +&#x3D; 1            items[i], items[j] &#x3D; items[j], items[i]    items[i + 1], items[end] &#x3D; items[end], items[i + 1]    return i + 1</code></pre><p>回溯法例子：<a href="https://zh.wikipedia.org/zh/%E9%AA%91%E5%A3%AB%E5%B7%A1%E9%80%BB">骑士巡逻</a>。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。&quot;&quot;&quot;import sysimport timeSIZE &#x3D; 5total &#x3D; 0def print_board(board):    for row in board:        for col in row:            print(str(col).center(4), end&#x3D;&#39;&#39;)        print()def patrol(board, row, col, step&#x3D;1):    if row &gt;&#x3D; 0 and row &lt; SIZE and \        col &gt;&#x3D; 0 and col &lt; SIZE and \        board[row][col] &#x3D;&#x3D; 0:        board[row][col] &#x3D; step        if step &#x3D;&#x3D; SIZE * SIZE:            global total            total +&#x3D; 1            print(f&#39;第&#123;total&#125;种走法: &#39;)            print_board(board)        patrol(board, row - 2, col - 1, step + 1)        patrol(board, row - 1, col - 2, step + 1)        patrol(board, row + 1, col - 2, step + 1)        patrol(board, row + 2, col - 1, step + 1)        patrol(board, row + 2, col + 1, step + 1)        patrol(board, row + 1, col + 2, step + 1)        patrol(board, row - 1, col + 2, step + 1)        patrol(board, row - 2, col + 1, step + 1)        board[row][col] &#x3D; 0def main():    board &#x3D; [[0] * SIZE for _ in range(SIZE)]    patrol(board, SIZE - 1, SIZE - 1)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>动态规划例子：子列表元素之和的最大值。</p><blockquote><p>说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：</p><p>输入：1 -2 3 5 -3 2</p><p>输出：8</p><p>输入：0 -2 3 5 -1 2</p><p>输出：9</p><p>输入：-9 -2 -3 -5 -3</p><p>输出：-2</p></blockquote><pre class="language-Python" data-language="Python"><code class="language-Python">def main():    items &#x3D; list(map(int, input().split()))    overall &#x3D; partial &#x3D; items[0]    for i in range(1, len(items)):        partial &#x3D; max(items[i], partial + items[i])        overall &#x3D; max(partial, overall)    print(overall)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明</strong>：这个题目最容易想到的解法是使用二重循环，但是代码的时间性能将会变得非常的糟糕。使用动态规划的思想，仅仅是多用了两个变量，就将原来$O(N^2)$复杂度的问题变成了$O(N)$。</p></blockquote></li></ul><h3 id="函数的使用方式"><a href="#函数的使用方式" class="headerlink" title="函数的使用方式"></a>函数的使用方式</h3><ul><li><p>将函数视为“一等公民”</p><ul><li>函数可以赋值给变量</li><li>函数可以作为函数的参数</li><li>函数可以作为函数的返回值</li></ul></li><li><p>高阶函数的用法（<code>filter</code>、<code>map</code>以及它们的替代品）</p><pre class="language-Python" data-language="Python"><code class="language-Python">items1 &#x3D; list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10))))items2 &#x3D; [x ** 2 for x in range(1, 10) if x % 2]</code></pre></li><li><p>位置参数、可变参数、关键字参数、命名关键字参数</p></li><li><p>参数的元信息（代码可读性问题）</p></li><li><p>匿名函数和内联函数的用法（<code>lambda</code>函数）</p></li><li><p>闭包和作用域问题</p><ul><li><p>Python搜索变量的LEGB顺序（Local &gt;&gt;&gt; Embedded &gt;&gt;&gt; Global &gt;&gt;&gt; Built-in）</p></li><li><p><code>global</code>和<code>nonlocal</code>关键字的作用</p><p><code>global</code>：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。</p><p><code>nonlocal</code>：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。</p></li></ul></li><li><p>装饰器函数（使用装饰器和取消装饰器）</p><p>例子：输出函数执行时间的装饰器。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def record_time(func):    &quot;&quot;&quot;自定义装饰函数的装饰器&quot;&quot;&quot;        @wraps(func)    def wrapper(*args, **kwargs):        start &#x3D; time()        result &#x3D; func(*args, **kwargs)        print(f&#39;&#123;func.__name__&#125;: &#123;time() - start&#125;秒&#39;)        return result            return wrapper</code></pre><p>如果装饰器不希望跟<code>print</code>函数耦合，可以编写可以参数化的装饰器。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from functools import wrapsfrom time import timedef record(output):    &quot;&quot;&quot;可以参数化的装饰器&quot;&quot;&quot;def decorate(func):@wraps(func)def wrapper(*args, **kwargs):start &#x3D; time()result &#x3D; func(*args, **kwargs)output(func.__name__, time() - start)return result            return wrapperreturn decorate</code></pre><pre class="language-Python" data-language="Python"><code class="language-Python">from functools import wrapsfrom time import timeclass Record():    &quot;&quot;&quot;通过定义类的方式定义装饰器&quot;&quot;&quot;    def __init__(self, output):        self.output &#x3D; output    def __call__(self, func):        @wraps(func)        def wrapper(*args, **kwargs):            start &#x3D; time()            result &#x3D; func(*args, **kwargs)            self.output(func.__name__, time() - start)            return result        return wrapper</code></pre><blockquote><p><strong>说明</strong>：由于对带装饰功能的函数添加了@wraps装饰器，可以通过<code>func.__wrapped__</code>方式获得被装饰之前的函数或类来取消装饰器的作用。</p></blockquote><p>例子：用装饰器来实现单例模式。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from functools import wrapsdef singleton(cls):    &quot;&quot;&quot;装饰类的装饰器&quot;&quot;&quot;    instances &#x3D; &#123;&#125;    @wraps(cls)    def wrapper(*args, **kwargs):        if cls not in instances:            instances[cls] &#x3D; cls(*args, **kwargs)        return instances[cls]    return wrapper@singletonclass President:    &quot;&quot;&quot;总统(单例类)&quot;&quot;&quot;    pass</code></pre><blockquote><p><strong>提示</strong>：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？</p></blockquote><p>线程安全的单例装饰器。</p><pre class="language-Python" data-language="Python"><code class="language-Python">from functools import wrapsfrom threading import RLockdef singleton(cls):    &quot;&quot;&quot;线程安全的单例装饰器&quot;&quot;&quot;    instances &#x3D; &#123;&#125;    locker &#x3D; RLock()    @wraps(cls)    def wrapper(*args, **kwargs):        if cls not in instances:            with locker:                if cls not in instances:                    instances[cls] &#x3D; cls(*args, **kwargs)        return instances[cls]    return wrapper</code></pre><blockquote><p><strong>提示</strong>：上面的代码用到了<code>with</code>上下文语法来进行锁操作，因为锁对象本身就是上下文管理器对象（支持<code>__enter__</code>和<code>__exit__</code>魔术方法）。在<code>wrapper</code>函数中，我们先做了一次不带锁的检查，然后再做带锁的检查，这样做比直接加锁检查性能要更好，如果对象已经创建就没有必须再去加锁而是直接返回该对象就可以了。</p></blockquote></li></ul><h3 id="面向对象相关知识"><a href="#面向对象相关知识" class="headerlink" title="面向对象相关知识"></a>面向对象相关知识</h3><ul><li><p>三大支柱：封装、继承、多态</p><p>例子：工资结算系统。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成&quot;&quot;&quot;from abc import ABCMeta, abstractmethodclass Employee(metaclass&#x3D;ABCMeta):    &quot;&quot;&quot;员工(抽象类)&quot;&quot;&quot;    def __init__(self, name):        self.name &#x3D; name    @abstractmethod    def get_salary(self):        &quot;&quot;&quot;结算月薪(抽象方法)&quot;&quot;&quot;        passclass Manager(Employee):    &quot;&quot;&quot;部门经理&quot;&quot;&quot;    def get_salary(self):        return 15000.0class Programmer(Employee):    &quot;&quot;&quot;程序员&quot;&quot;&quot;    def __init__(self, name, working_hour&#x3D;0):        self.working_hour &#x3D; working_hour        super().__init__(name)    def get_salary(self):        return 200.0 * self.working_hourclass Salesman(Employee):    &quot;&quot;&quot;销售员&quot;&quot;&quot;    def __init__(self, name, sales&#x3D;0.0):        self.sales &#x3D; sales        super().__init__(name)    def get_salary(self):        return 1800.0 + self.sales * 0.05class EmployeeFactory:    &quot;&quot;&quot;创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）&quot;&quot;&quot;    @staticmethod    def create(emp_type, *args, **kwargs):        &quot;&quot;&quot;创建员工&quot;&quot;&quot;        all_emp_types &#x3D; &#123;&#39;M&#39;: Manager, &#39;P&#39;: Programmer, &#39;S&#39;: Salesman&#125;        cls &#x3D; all_emp_types[emp_type.upper()]        return cls(*args, **kwargs) if cls else Nonedef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    emps &#x3D; [        EmployeeFactory.create(&#39;M&#39;, &#39;曹操&#39;),         EmployeeFactory.create(&#39;P&#39;, &#39;荀彧&#39;, 120),        EmployeeFactory.create(&#39;P&#39;, &#39;郭嘉&#39;, 85),         EmployeeFactory.create(&#39;S&#39;, &#39;典韦&#39;, 123000),    ]    for emp in emps:        print(f&#39;&#123;emp.name&#125;: &#123;emp.get_salary():.2f&#125;元&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre></li><li><p>类与类之间的关系</p><ul><li>is-a关系：继承</li><li>has-a关系：关联 &#x2F; 聚合 &#x2F; 合成</li><li>use-a关系：依赖</li></ul><p>例子：扑克游戏。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择&quot;&quot;&quot;from enum import Enum, uniqueimport random@uniqueclass Suite(Enum):    &quot;&quot;&quot;花色&quot;&quot;&quot;    SPADE, HEART, CLUB, DIAMOND &#x3D; range(4)    def __lt__(self, other):        return self.value &lt; other.valueclass Card:    &quot;&quot;&quot;牌&quot;&quot;&quot;    def __init__(self, suite, face):        &quot;&quot;&quot;初始化方法&quot;&quot;&quot;        self.suite &#x3D; suite        self.face &#x3D; face    def show(self):        &quot;&quot;&quot;显示牌面&quot;&quot;&quot;        suites &#x3D; [&#39;♠︎&#39;, &#39;♥︎&#39;, &#39;♣︎&#39;, &#39;♦︎&#39;]        faces &#x3D; [&#39;&#39;, &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39;]        return f&#39;&#123;suites[self.suite.value]&#125;&#123;faces[self.face]&#125;&#39;    def __repr__(self):        return self.show()class Poker:    &quot;&quot;&quot;扑克&quot;&quot;&quot;    def __init__(self):        self.index &#x3D; 0        self.cards &#x3D; [Card(suite, face)                      for suite in Suite                      for face in range(1, 14)]    def shuffle(self):        &quot;&quot;&quot;洗牌（随机乱序）&quot;&quot;&quot;        random.shuffle(self.cards)        self.index &#x3D; 0    def deal(self):        &quot;&quot;&quot;发牌&quot;&quot;&quot;        card &#x3D; self.cards[self.index]        self.index +&#x3D; 1        return card    @property    def has_more(self):        return self.index &lt; len(self.cards)class Player:    &quot;&quot;&quot;玩家&quot;&quot;&quot;    def __init__(self, name):        self.name &#x3D; name        self.cards &#x3D; []    def get_one(self, card):        &quot;&quot;&quot;摸一张牌&quot;&quot;&quot;        self.cards.append(card)    def sort(self, comp&#x3D;lambda card: (card.suite, card.face)):        &quot;&quot;&quot;整理手上的牌&quot;&quot;&quot;        self.cards.sort(key&#x3D;comp)def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    poker &#x3D; Poker()    poker.shuffle()    players &#x3D; [Player(&#39;东邪&#39;), Player(&#39;西毒&#39;), Player(&#39;南帝&#39;), Player(&#39;北丐&#39;)]    while poker.has_more:        for player in players:                player.get_one(poker.deal())    for player in players:        player.sort()        print(player.name, end&#x3D;&#39;: &#39;)        print(player.cards)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明</strong>：上面的代码中使用了Emoji字符来表示扑克牌的四种花色，在某些不支持Emoji字符的系统上可能无法显示。</p></blockquote></li><li><p>对象的复制（深复制&#x2F;深拷贝&#x2F;深度克隆和浅复制&#x2F;浅拷贝&#x2F;影子克隆）</p></li><li><p>垃圾回收、循环引用和弱引用</p><p>Python使用了自动化内存管理，这种管理机制以<strong>引用计数</strong>为基础，同时也引入了<strong>标记-清除</strong>和<strong>分代收集</strong>两种机制为辅的策略。</p><pre class="language-C" data-language="C"><code class="language-C">typedef struct _object &#123;    &#x2F;* 引用计数 *&#x2F;    int ob_refcnt;    &#x2F;* 对象指针 *&#x2F;    struct _typeobject *ob_type;&#125; PyObject;</code></pre><pre class="language-C" data-language="C"><code class="language-C">&#x2F;* 增加引用计数的宏定义 *&#x2F;#define Py_INCREF(op)   ((op)-&gt;ob_refcnt++)&#x2F;* 减少引用计数的宏定义 *&#x2F;#define Py_DECREF(op) \ &#x2F;&#x2F;减少计数    if (--(op)-&gt;ob_refcnt !&#x3D; 0) \        ; \    else \        __Py_Dealloc((PyObject *)(op))</code></pre><p>导致引用计数+1的情况：</p><ul><li>对象被创建，例如<code>a = 23</code></li><li>对象被引用，例如<code>b = a</code></li><li>对象被作为参数，传入到一个函数中，例如<code>f(a)</code></li><li>对象作为一个元素，存储在容器中，例如<code>list1 = [a, a]</code></li></ul><p>导致引用计数-1的情况：</p><ul><li>对象的别名被显式销毁，例如<code>del a</code></li><li>对象的别名被赋予新的对象，例如<code>a = 24</code></li><li>一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会）</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ul><p>引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。</p><pre class="language-Python" data-language="Python"><code class="language-Python"># 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收# 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效# 如果不想造成循环引用可以使用弱引用list1 &#x3D; []list2 &#x3D; [] list1.append(list2)list2.append(list1)</code></pre><p>以下情况会导致垃圾回收：</p><ul><li>调用<code>gc.collect()</code></li><li><code>gc</code>模块的计数器达到阀值</li><li>程序退出</li></ul><p>如果循环引用中两个对象都定义了<code>__del__</code>方法，<code>gc</code>模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的<code>__del__</code>方法，这个问题在Python 3.6中得到了解决。</p><p>也可以通过<code>weakref</code>模块构造弱引用的方式来解决循环引用的问题。</p></li><li><p>魔法属性和方法（请参考《Python魔法方法指南》）</p><p>有几个小问题请大家思考：</p><ul><li>自定义的对象能不能使用运算符做运算？</li><li>自定义的对象能不能放到<code>set</code>中？能去重吗？</li><li>自定义的对象能不能作为<code>dict</code>的键？</li><li>自定义的对象能不能使用上下文语法？</li></ul></li><li><p>混入（Mixin）</p><p>例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。</p><pre class="language-Python" data-language="Python"><code class="language-Python">class SetOnceMappingMixin:    &quot;&quot;&quot;自定义混入类&quot;&quot;&quot;    __slots__ &#x3D; ()    def __setitem__(self, key, value):        if key in self:            raise KeyError(str(key) + &#39; already set&#39;)        return super().__setitem__(key, value)class SetOnceDict(SetOnceMappingMixin, dict):    &quot;&quot;&quot;自定义字典&quot;&quot;&quot;    passmy_dict&#x3D; SetOnceDict()try:    my_dict[&#39;username&#39;] &#x3D; &#39;jackfrued&#39;    my_dict[&#39;username&#39;] &#x3D; &#39;hellokitty&#39;except KeyError:    passprint(my_dict)</code></pre></li><li><p>元编程和元类</p><p>对象是通过类创建的，类是通过元类创建的，元类提供了创建类的元信息。所有的类都直接或间接的继承自<code>object</code>，所有的元类都直接或间接的继承自<code>type</code>。</p><p>例子：用元类实现单例模式。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import threadingclass SingletonMeta(type):    &quot;&quot;&quot;自定义元类&quot;&quot;&quot;    def __init__(cls, *args, **kwargs):        cls.__instance &#x3D; None        cls.__lock &#x3D; threading.RLock()        super().__init__(*args, **kwargs)    def __call__(cls, *args, **kwargs):        if cls.__instance is None:            with cls.__lock:                if cls.__instance is None:                    cls.__instance &#x3D; super().__call__(*args, **kwargs)        return cls.__instanceclass President(metaclass&#x3D;SingletonMeta):    &quot;&quot;&quot;总统(单例类)&quot;&quot;&quot;        pass</code></pre></li><li><p>面向对象设计原则</p><ul><li>单一职责原则 （<strong>S</strong>RP）- 一个类只做该做的事情（类的设计要高内聚）</li><li>开闭原则 （<strong>O</strong>CP）- 软件实体应该对扩展开发对修改关闭</li><li>依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化）</li><li>里氏替换原则（<strong>L</strong>SP） - 任何时候可以用子类对象替换掉父类对象</li><li>接口隔离原则（<strong>I</strong>SP）- 接口要小而专不要大而全（Python中没有接口的概念）</li><li>合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码</li><li>最少知识原则（迪米特法则，Lo<strong>D</strong>）- 不要给没有必然联系的对象发消息</li></ul><blockquote><p><strong>说明</strong>：上面加粗的字母放在一起称为面向对象的<strong>SOLID</strong>原则。</p></blockquote></li><li><p>GoF设计模式</p><ul><li>创建型模式：单例、工厂、建造者、原型</li><li>结构型模式：适配器、门面（外观）、代理</li><li>行为型模式：迭代器、观察者、状态、策略</li></ul><p>例子：可插拔的哈希算法（策略模式）。</p><pre class="language-Python" data-language="Python"><code class="language-Python">class StreamHasher():    &quot;&quot;&quot;哈希摘要生成器&quot;&quot;&quot;    def __init__(self, alg&#x3D;&#39;md5&#39;, size&#x3D;4096):        self.size &#x3D; size        alg &#x3D; alg.lower()        self.hasher &#x3D; getattr(__import__(&#39;hashlib&#39;), alg.lower())()    def __call__(self, stream):        return self.to_digest(stream)    def to_digest(self, stream):        &quot;&quot;&quot;生成十六进制形式的摘要&quot;&quot;&quot;        for buf in iter(lambda: stream.read(self.size), b&#39;&#39;):            self.hasher.update(buf)        return self.hasher.hexdigest()def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    hasher1 &#x3D; StreamHasher()    with open(&#39;Python-3.7.6.tgz&#39;, &#39;rb&#39;) as stream:        print(hasher1.to_digest(stream))    hasher2 &#x3D; StreamHasher(&#39;sha1&#39;)    with open(&#39;Python-3.7.6.tgz&#39;, &#39;rb&#39;) as stream:        print(hasher2(stream))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre></li></ul><h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><ul><li><p>迭代器是实现了迭代器协议的对象。</p><ul><li>Python中没有像<code>protocol</code>或<code>interface</code>这样的定义协议的关键字。</li><li>Python中用魔术方法表示协议。</li><li><code>__iter__</code>和<code>__next__</code>魔术方法就是迭代器协议。</li></ul><pre class="language-Python" data-language="Python"><code class="language-Python">class Fib(object):    &quot;&quot;&quot;迭代器&quot;&quot;&quot;        def __init__(self, num):        self.num &#x3D; num        self.a, self.b &#x3D; 0, 1        self.idx &#x3D; 0       def __iter__(self):        return self    def __next__(self):        if self.idx &lt; self.num:            self.a, self.b &#x3D; self.b, self.a + self.b            self.idx +&#x3D; 1            return self.a        raise StopIteration()</code></pre></li><li><p>生成器是语法简化版的迭代器。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def fib(num):    &quot;&quot;&quot;生成器&quot;&quot;&quot;    a, b &#x3D; 0, 1    for _ in range(num):        a, b &#x3D; b, a + b        yield a</code></pre></li><li><p>生成器进化为协程。</p><p>生成器对象可以使用<code>send()</code>方法发送数据，发送的数据会成为生成器函数中通过<code>yield</code>表达式获得的值。这样，生成器就可以作为协程使用，协程简单的说就是可以相互协作的子程序。</p><pre class="language-Python" data-language="Python"><code class="language-Python">def calc_avg():    &quot;&quot;&quot;流式计算平均值&quot;&quot;&quot;    total, counter &#x3D; 0, 0    avg_value &#x3D; None    while True:        value &#x3D; yield avg_value        total, counter &#x3D; total + value, counter + 1        avg_value &#x3D; total &#x2F; countergen &#x3D; calc_avg()next(gen)print(gen.send(10))print(gen.send(20))print(gen.send(30))</code></pre></li></ul><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><p>Python中实现并发编程的三种方案：多线程、多进程和异步I&#x2F;O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。</p><ul><li><p>多线程：Python中提供了<code>Thread</code>类并辅以<code>Lock</code>、<code>Condition</code>、<code>Event</code>、<code>Semaphore</code>和<code>Barrier</code>。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;面试题：进程和线程的区别和联系？进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程线程 - 操作系统分配CPU的基本单位并发编程（concurrent programming）1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行2. 改善用户体验 - 让耗时间的操作不会造成程序的假死&quot;&quot;&quot;import globimport osimport threadingfrom PIL import ImagePREFIX &#x3D; &#39;thumbnails&#39;def generate_thumbnail(infile, size, format&#x3D;&#39;PNG&#39;):    &quot;&quot;&quot;生成指定图片文件的缩略图&quot;&quot;&quot;file, ext &#x3D; os.path.splitext(infile)file &#x3D; file[file.rfind(&#39;&#x2F;&#39;) + 1:]outfile &#x3D; f&#39;&#123;PREFIX&#125;&#x2F;&#123;file&#125;_&#123;size[0]&#125;_&#123;size[1]&#125;.&#123;ext&#125;&#39;img &#x3D; Image.open(infile)img.thumbnail(size, Image.ANTIALIAS)img.save(outfile, format)def main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;if not os.path.exists(PREFIX):os.mkdir(PREFIX)for infile in glob.glob(&#39;images&#x2F;*.png&#39;):for size in (32, 64, 128):            # 创建并启动线程threading.Thread(target&#x3D;generate_thumbnail, args&#x3D;(infile, (size, size))).start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:main()</code></pre><p>多个线程竞争资源的情况。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;多线程程序如果没有竞争资源处理起来通常也比较简单当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱说明：临界资源就是被多个线程竞争的资源&quot;&quot;&quot;import timeimport threadingfrom concurrent.futures import ThreadPoolExecutorclass Account(object):    &quot;&quot;&quot;银行账户&quot;&quot;&quot;    def __init__(self):        self.balance &#x3D; 0.0        self.lock &#x3D; threading.Lock()    def deposit(self, money):        # 通过锁保护临界资源        with self.lock:            new_balance &#x3D; self.balance + money            time.sleep(0.001)            self.balance &#x3D; new_balancedef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    account &#x3D; Account()    # 创建线程池    pool &#x3D; ThreadPoolExecutor(max_workers&#x3D;10)    futures &#x3D; []    for _ in range(100):        future &#x3D; pool.submit(account.deposit, 1)        futures.append(future)    # 关闭线程池    pool.shutdown()    for future in futures:        future.result()    print(account.balance)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><p>修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用<code>threading</code>模块的<code>Condition</code>来实现线程调度，该对象也是基于锁来创建的，代码如下所示：</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;多个线程竞争一个资源 - 保护临界资源 - 锁（Lock&#x2F;RLock）多个线程竞争多个资源（线程数&gt;资源数） - 信号量（Semaphore）多个线程的调度 - 暂停线程执行&#x2F;唤醒等待中的线程 - Condition&quot;&quot;&quot;from concurrent.futures import ThreadPoolExecutorfrom random import randintfrom time import sleepimport threadingclass Account:    &quot;&quot;&quot;银行账户&quot;&quot;&quot;    def __init__(self, balance&#x3D;0):        self.balance &#x3D; balance        lock &#x3D; threading.RLock()        self.condition &#x3D; threading.Condition(lock)    def withdraw(self, money):        &quot;&quot;&quot;取钱&quot;&quot;&quot;        with self.condition:            while money &gt; self.balance:                self.condition.wait()            new_balance &#x3D; self.balance - money            sleep(0.001)            self.balance &#x3D; new_balance    def deposit(self, money):        &quot;&quot;&quot;存钱&quot;&quot;&quot;        with self.condition:            new_balance &#x3D; self.balance + money            sleep(0.001)            self.balance &#x3D; new_balance            self.condition.notify_all()def add_money(account):    while True:        money &#x3D; randint(5, 10)        account.deposit(money)        print(threading.current_thread().name,               &#39;:&#39;, money, &#39;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&#39;, account.balance)        sleep(0.5)def sub_money(account):    while True:        money &#x3D; randint(10, 30)        account.withdraw(money)        print(threading.current_thread().name,               &#39;:&#39;, money, &#39;&lt;&#x3D;&#x3D;&#x3D;&#x3D;&#39;, account.balance)        sleep(1)def main():    account &#x3D; Account()    with ThreadPoolExecutor(max_workers&#x3D;15) as pool:        for _ in range(5):            pool.submit(add_money, account)        for _ in range(10):            pool.submit(sub_money, account)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre></li><li><p>多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是<code>Process</code>，其他辅助的类跟<code>threading</code>模块中的类似，进程间共享数据可以使用管道、套接字等，在<code>multiprocessing</code>模块中有一个<code>Queue</code>类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;多进程和进程池的使用多线程因为GIL的存在不能够发挥CPU的多核特性对于计算密集型任务应该考虑使用多进程time python3 example22.pyreal    0m11.512suser    0m39.319ssys     0m0.169s使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU&quot;&quot;&quot;import concurrent.futuresimport mathPRIMES &#x3D; [    1116281,    1297337,    104395303,    472882027,    533000389,    817504243,    982451653,    112272535095293,    112582705942171,    112272535095293,    115280095190773,    115797848077099,    1099726899285419] * 5def is_prime(n):    &quot;&quot;&quot;判断素数&quot;&quot;&quot;    if n % 2 &#x3D;&#x3D; 0:        return False    sqrt_n &#x3D; int(math.floor(math.sqrt(n)))    for i in range(3, sqrt_n + 1, 2):        if n % i &#x3D;&#x3D; 0:            return False    return Truedef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    with concurrent.futures.ProcessPoolExecutor() as executor:        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):            print(&#39;%d is prime: %s&#39; % (number, prime))if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>重点</strong>：<strong>多线程和多进程的比较</strong>。</p><p>以下情况需要使用多线程：</p><ol><li>程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。</li><li>程序会花费大量时间在I&#x2F;O操作上，没有太多并行计算的需求且不需占用太多的内存。</li></ol><p>以下情况需要使用多进程：</p><ol><li>程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。</li><li>程序的输入可以并行的分成块，并且可以将运算结果合并。</li><li>程序在内存使用方面没有任何限制且不强依赖于I&#x2F;O操作（如：读写文件、套接字等）。</li></ol></blockquote></li><li><p>异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者<code>future</code>对象来获取任务执行的结果。Python 3通过<code>asyncio</code>模块和<code>await</code>和<code>async</code>关键字（在Python 3.7中正式被列为关键字）来支持异步处理。</p><pre class="language-Python" data-language="Python"><code class="language-Python">&quot;&quot;&quot;异步I&#x2F;O - async &#x2F; await&quot;&quot;&quot;import asynciodef num_generator(m, n):    &quot;&quot;&quot;指定范围的数字生成器&quot;&quot;&quot;    yield from range(m, n + 1)async def prime_filter(m, n):    &quot;&quot;&quot;素数过滤器&quot;&quot;&quot;    primes &#x3D; []    for i in num_generator(m, n):        flag &#x3D; True        for j in range(2, int(i ** 0.5 + 1)):            if i % j &#x3D;&#x3D; 0:                flag &#x3D; False                break        if flag:            print(&#39;Prime &#x3D;&gt;&#39;, i)            primes.append(i)        await asyncio.sleep(0.001)    return tuple(primes)async def square_mapper(m, n):    &quot;&quot;&quot;平方映射器&quot;&quot;&quot;    squares &#x3D; []    for i in num_generator(m, n):        print(&#39;Square &#x3D;&gt;&#39;, i * i)        squares.append(i * i)        await asyncio.sleep(0.001)    return squaresdef main():    &quot;&quot;&quot;主函数&quot;&quot;&quot;    loop &#x3D; asyncio.get_event_loop()    future &#x3D; asyncio.gather(prime_filter(2, 100), square_mapper(1, 100))    future.add_done_callback(lambda x: print(x.result()))    loop.run_until_complete(future)    loop.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>说明</strong>：上面的代码使用<code>get_event_loop</code>函数获得系统默认的事件循环，通过<code>gather</code>函数可以获得一个<code>future</code>对象，<code>future</code>对象的<code>add_done_callback</code>可以添加执行完成时的回调函数，<code>loop</code>对象的<code>run_until_complete</code>方法可以等待通过<code>future</code>对象获得协程执行结果。</p></blockquote><p>Python中有一个名为<code>aiohttp</code>的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟<code>asyncio</code>模块一起工作，并提供了对<code>Future</code>对象的支持。Python 3.6中引入了<code>async</code>和<code>await</code>来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。</p><pre class="language-Python" data-language="Python"><code class="language-Python">import asyncioimport reimport aiohttpPATTERN &#x3D; re.compile(r&#39;\&lt;title\&gt;(?P&lt;title&gt;.*)\&lt;\&#x2F;title\&gt;&#39;)async def fetch_page(session, url):    async with session.get(url, ssl&#x3D;False) as resp:        return await resp.text()async def show_title(url):    async with aiohttp.ClientSession() as session:        html &#x3D; await fetch_page(session, url)        print(PATTERN.search(html).group(&#39;title&#39;))def main():    urls &#x3D; (&#39;https:&#x2F;&#x2F;www.python.org&#x2F;&#39;,            &#39;https:&#x2F;&#x2F;git-scm.com&#x2F;&#39;,            &#39;https:&#x2F;&#x2F;www.jd.com&#x2F;&#39;,            &#39;https:&#x2F;&#x2F;www.taobao.com&#x2F;&#39;,            &#39;https:&#x2F;&#x2F;www.douban.com&#x2F;&#39;)    loop &#x3D; asyncio.get_event_loop()    cos &#x3D; [show_title(url) for url in urls]    loop.run_until_complete(asyncio.wait(cos))    loop.close()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()</code></pre><blockquote><p><strong>重点</strong>：<strong>异步I&#x2F;O与多进程的比较</strong>。</p><p>当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，<code>asyncio</code>就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑<code>asyncio</code>，它很适合编写没有实时数据处理需求的Web应用服务器。</p></blockquote><p>Python还有很多用于处理并行任务的三方库，例如：<code>joblib</code>、<code>PyMP</code>等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。</p><p>要实现任务的异步化，可以使用名为<code>Celery</code>的三方库。<code>Celery</code>是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python语言进阶&quot;&gt;&lt;a href=&quot;#Python语言进阶&quot; class=&quot;headerlink&quot; title=&quot;Python语言进阶&quot;&gt;&lt;/a&gt;Python语言进阶&lt;/h2&gt;&lt;h3 id=&quot;重要知识点&quot;&gt;&lt;a href=&quot;#重要知识点&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>21-30.Web前端概述</title>
    <link href="http://wstcly.xyz/2024/07/01/21-30.web-qian-duan-gai-shu/"/>
    <id>http://wstcly.xyz/2024/07/01/21-30.web-qian-duan-gai-shu/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:08.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web前端概述"><a href="#Web前端概述" class="headerlink" title="Web前端概述"></a>Web前端概述</h2><blockquote><p><strong>说明</strong>：本文使用的部分插图来自<em>Jon Duckett</em>先生的*<a href="https://www.amazon.cn/dp/1118008189/ref=sr_1_5?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&keywords=html+&+css&qid=1554609325&s=gateway&sr=8-5">HTML and CSS: Design and Build Websites</a>*一书，这是一本非常棒的前端入门书，有兴趣的读者可以在亚马逊或者其他网站上找到该书的购买链接。</p></blockquote><p>HTML 是用来描述网页的一种语言，全称是 Hyper-Text Markup Language，即超文本标记语言。我们浏览网页时看到的文字、按钮、图片、视频等元素，它们都是通过 HTML 书写并通过浏览器来呈现的。</p><h3 id="HTML简史"><a href="#HTML简史" class="headerlink" title="HTML简史"></a>HTML简史</h3><ol><li>1991年10月：一个非正式CERN（<a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E6%B4%B2%E6%A0%B8%E5%AD%90%E7%A0%94%E7%A9%B6%E7%B5%84%E7%B9%94">欧洲核子研究中心</a>）文件首次公开18个HTML标签，这个文件的作者是物理学家<a href="https://zh.wikipedia.org/wiki/%E8%92%82%E5%A7%86%C2%B7%E4%BC%AF%E7%BA%B3%E6%96%AF-%E6%9D%8E">蒂姆·伯纳斯-李</a>，因此他是<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网</a>的发明者，也是<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91%E8%81%94%E7%9B%9F">万维网联盟</a>的主席。</li><li>1995年11月：HTML 2.0标准发布（RFC 1866）。</li><li>1997年1月：HTML 3.2作为<a href="https://zh.wikipedia.org/wiki/W3C">W3C</a>推荐标准发布。</li><li>1997年12月：HTML 4.0作为W3C推荐标准发布。</li><li>1999年12月：HTML4.01作为W3C推荐标准发布。</li><li>2008年1月：HTML5由W3C作为工作草案发布。</li><li>2011年5月：W3C将HTML5推进至“最终征求”（Last Call）阶段。</li><li>2012年12月：W3C指定HTML5作为“候选推荐”阶段。</li><li>2014年10月：HTML5作为稳定W3C推荐标准发布，这意味着HTML5的标准化已经完成。</li></ol><h4 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h4><ol><li>引入原生多媒体支持（audio和video标签）</li><li>引入可编程内容（canvas标签）</li><li>引入语义Web（article、aside、details、figure、footer、header、nav、section、summary等标签）</li><li>引入新的表单控件（日历、邮箱、搜索、滑条等）</li><li>引入对离线存储更好的支持（localStorage和sessionStorage）</li><li>引入对定位、拖放、WebSocket、后台任务等的支持</li></ol><h3 id="使用标签承载内容"><a href="#使用标签承载内容" class="headerlink" title="使用标签承载内容"></a>使用标签承载内容</h3><img src="https://gitee.com/jackfrued/mypic/raw/master/20211107163448.png" style="zoom:35%"><img src="https://gitee.com/jackfrued/mypic/raw/master/20211107163741.png" style="zoom:75%"><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li>html<ul><li>head<ul><li>title</li><li>meta</li></ul></li><li>body</li></ul></li></ul><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><ul><li>标题（heading）和段落（paragraph）<ul><li>h1 ~ h6</li><li>p</li></ul></li><li>上标（superscript）和下标（subscript）<ul><li>sup</li><li>sub</li></ul></li><li>空白（白色空间折叠）</li><li>折行（break）和水平标尺（horizontal ruler）<ul><li>br</li><li>hr</li></ul></li><li>语义化标签<ul><li>加粗和强调 - strong</li><li>引用 - blockquote</li><li>缩写词和首字母缩写词 - abbr &#x2F; acronym</li><li>引文 - cite</li><li>所有者联系信息 - address</li><li>内容的修改 - ins &#x2F; del</li></ul></li></ul><h4 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h4><ul><li>有序列表（ordered list）- ol &#x2F; li</li><li>无序列表（unordered list）- ul &#x2F; li</li><li>定义列表（definition list）- dl &#x2F; dt &#x2F; dd</li></ul><h4 id="链接（anchor）"><a href="#链接（anchor）" class="headerlink" title="链接（anchor）"></a>链接（anchor）</h4><ul><li>页面链接</li><li>锚链接</li><li>功能链接</li></ul><h4 id="图像（image）"><a href="#图像（image）" class="headerlink" title="图像（image）"></a>图像（image）</h4><ul><li><p>图像存储位置</p><p><img src="/./res/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84.png"></p></li><li><p>图像及其宽高</p></li><li><p>选择正确的图像格式</p><ul><li>JPEG</li><li>GIF</li><li>PNG</li></ul></li><li><p>矢量图</p></li><li><p>语义化标签 - figure &#x2F; figcaption</p></li></ul><h4 id="表格（table）"><a href="#表格（table）" class="headerlink" title="表格（table）"></a>表格（table）</h4><ul><li>基本的表格结构 - table &#x2F; tr &#x2F; td &#x2F; th</li><li>表格的标题 - caption</li><li>跨行和跨列 - rowspan属性 &#x2F; colspan属性</li><li>长表格 - thead &#x2F; tbody &#x2F; tfoot</li></ul><h4 id="表单（form）"><a href="#表单（form）" class="headerlink" title="表单（form）"></a>表单（form）</h4><ul><li>重要属性 - action &#x2F; method &#x2F; enctype</li><li>表单控件（input）- type属性<ul><li>文本框 - <code>text</code> &#x2F; 密码框 - <code>password</code> &#x2F; 数字框 - <code>number</code></li><li>邮箱 - <code>email</code> &#x2F; 电话 - <code>tel</code> &#x2F; 日期 - <code>date</code> &#x2F; 滑条 - <code>range</code> &#x2F; URL - <code>url</code> &#x2F; 搜索 - <code>search</code></li><li>单选按钮 - <code>radio</code> &#x2F; 复选按钮 - <code>checkbox</code></li><li>文件上传 - <code>file</code> &#x2F; 隐藏域 - <code>hidden</code></li><li>提交按钮 - <code>submit</code> &#x2F; 图像按钮 - <code>image</code>  &#x2F; 重置按钮 - <code>reset</code></li></ul></li><li>下拉列表 - select &#x2F; option</li><li>文本域（多行文本）- textarea</li><li>组合表单元素 - fieldset &#x2F; legend</li></ul><h4 id="音视频（audio-video）"><a href="#音视频（audio-video）" class="headerlink" title="音视频（audio &#x2F; video）"></a>音视频（audio &#x2F; video）</h4><ul><li>视频格式和播放器</li><li>视频托管服务</li><li>添加视频的准备工作</li><li>video标签和属性 - autoplay &#x2F; controls &#x2F; loop &#x2F; muted &#x2F; preload &#x2F; src</li><li>audio标签和属性 - autoplay &#x2F; controls &#x2F; loop &#x2F; muted &#x2F; preload &#x2F; src &#x2F; width &#x2F; height &#x2F; poster</li></ul><h4 id="窗口（frame）"><a href="#窗口（frame）" class="headerlink" title="窗口（frame）"></a>窗口（frame）</h4><ul><li><p>框架集（过时，不建议使用） - frameset &#x2F; frame</p></li><li><p>内嵌窗口 - iframe</p></li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><p>文档类型</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;!doctype html&gt;</code></pre><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;strict.dtd&quot;&gt;</code></pre><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;html4&#x2F;loose.dtd&quot;&gt;</code></pre></li><li><p>注释</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;!-- 这是一段注释，注释不能够嵌套 --&gt;</code></pre></li><li><p>属性</p><ul><li>id：唯一标识</li><li>class：元素所属的类，用于区分不同的元素</li><li>title：元素的额外信息（鼠标悬浮时会显示工具提示文本）</li><li>tabindex：Tab键切换顺序</li><li>contenteditable：元素是否可编辑</li><li>draggable：元素是否可拖拽</li></ul></li><li><p>块级元素 &#x2F; 行级元素</p></li><li><p>字符实体（实体替换符）</p><p><img src="/./res/%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93.png"></p></li></ul><h3 id="使用CSS渲染页面"><a href="#使用CSS渲染页面" class="headerlink" title="使用CSS渲染页面"></a>使用CSS渲染页面</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li><p>CSS的作用</p></li><li><p>CSS的工作原理</p></li><li><p>规则、属性和值</p><p><img src="/./res/%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%AD%E6%B3%95.png"></p></li><li><p>常用选择器</p><p><img src="/./res/%E5%B8%B8%E7%94%A8%E9%80%89%E6%8B%A9%E5%99%A8.png"></p></li></ul><h4 id="颜色（color）"><a href="#颜色（color）" class="headerlink" title="颜色（color）"></a>颜色（color）</h4><ul><li>如何指定颜色</li><li>颜色术语和颜色对比</li><li>背景色</li></ul><h4 id="文本（text-font）"><a href="#文本（text-font）" class="headerlink" title="文本（text &#x2F; font）"></a>文本（text &#x2F; font）</h4><ul><li><p>文本的大小和字型(font-size &#x2F; font-family)</p><p><img src="/./res/%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D.png"></p><p><img src="/./res/%E8%A1%AC%E7%BA%BF%E5%AD%97%E4%BD%93+%E9%9D%9E%E8%A1%AC%E7%BA%BF%E5%AD%97%E4%BD%93+%E7%AD%89%E5%AE%BD%E5%AD%97%E4%BD%93.png"></p></li><li><p>粗细、样式、拉伸和装饰(font-weight &#x2F; font-style &#x2F; font-stretch &#x2F; text-decoration)</p><p><img src="/./res/%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F.png"></p></li><li><p>行间距(line-height)、字母间距(letter-spacing)和单词间距(word-spacing)</p></li><li><p>对齐(text-align)方式和缩进(text-ident)</p></li><li><p>链接样式（:link &#x2F; :visited &#x2F; :active &#x2F; :hover）</p></li><li><p>CSS3新属性</p><ul><li>阴影效果 - text-shadow</li><li>首字母和首行文本(:first-letter &#x2F; :first-line)</li><li>响应用户</li></ul></li></ul><h4 id="盒子（box-model）"><a href="#盒子（box-model）" class="headerlink" title="盒子（box model）"></a>盒子（box model）</h4><ul><li><p>盒子大小的控制（width &#x2F; height）</p><p><img src="/./res/%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D.png"></p></li><li><p>盒子的边框、外边距和内边距（border &#x2F;  margin &#x2F; padding）</p><p><img src="/./res/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png"></p></li><li><p>盒子的显示和隐藏（display &#x2F; visibility）</p></li><li><p>CSS3新属性</p><ul><li>边框图像（border-image）</li><li>投影（border-shadow）</li><li>圆角（border-radius）</li></ul></li></ul><h4 id="列表、表格和表单"><a href="#列表、表格和表单" class="headerlink" title="列表、表格和表单"></a>列表、表格和表单</h4><ul><li>列表的项目符号（list-style）</li><li>表格的边框和背景（border-collapse）</li><li>表单控件的外观</li><li>表单控件的对齐</li><li>浏览器的开发者工具</li></ul><h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><ul><li>控制图像的大小（display: inline-block）</li><li>对齐图像</li><li>背景图像（background &#x2F; background-image &#x2F; background-repeat &#x2F; background-position）</li></ul><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><ul><li><p>控制元素的位置（position &#x2F; z-index）</p><ul><li>普通流</li><li>相对定位</li><li>绝对定位</li><li>固定定位</li><li>浮动元素（float &#x2F; clear）</li></ul></li><li><p>网站布局</p><ul><li><p>HTML5布局</p><p><img src="/./res/%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80-2.png"></p></li></ul></li><li><p>适配屏幕尺寸</p><ul><li>固定宽度布局</li><li>流体布局</li><li>布局网格</li></ul></li></ul><h3 id="使用JavaScript控制行为"><a href="#使用JavaScript控制行为" class="headerlink" title="使用JavaScript控制行为"></a>使用JavaScript控制行为</h3><h4 id="JavaScript基本语法"><a href="#JavaScript基本语法" class="headerlink" title="JavaScript基本语法"></a>JavaScript基本语法</h4><ul><li>语句和注释</li><li>变量和数据类型<ul><li>声明和赋值</li><li>简单数据类型和复杂数据类型</li><li>变量的命名规则</li></ul></li><li>表达式和运算符<ul><li>赋值运算符</li><li>算术运算符</li><li>比较运算符</li><li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li></ul></li><li>分支结构<ul><li><code>if...else...</code></li><li><code>switch...cas...default...</code></li></ul></li><li>循环结构<ul><li><code>for</code>循环</li><li><code>while</code>循环</li><li><code>do...while</code>循环</li></ul></li><li>数组<ul><li>创建数组</li><li>操作数组中的元素</li></ul></li><li>函数<ul><li>声明函数</li><li>调用函数</li><li>参数和返回值</li><li>匿名函数</li><li>立即调用函数</li></ul></li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li>对象的概念</li><li>创建对象的字面量语法</li><li>访问成员运算符</li><li>创建对象的构造函数语法<ul><li><code>this</code>关键字</li></ul></li><li>添加和删除属性<ul><li><code>delete</code>关键字</li></ul></li><li>标准对象<ul><li><code>Number</code> &#x2F; <code>String</code> &#x2F; <code>Boolean</code> &#x2F; <code>Symbol</code> &#x2F; <code>Array</code> &#x2F; <code>Function</code> </li><li><code>Date</code> &#x2F; <code>Error</code> &#x2F; <code>Math</code> &#x2F; <code>RegExp</code> &#x2F; <code>Object</code> &#x2F; <code>Map</code> &#x2F; <code>Set</code></li><li><code>JSON</code> &#x2F; <code>Promise</code> &#x2F; <code>Generator</code> &#x2F; <code>Reflect</code> &#x2F; <code>Proxy</code></li></ul></li></ul><h4 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h4><ul><li><code>window</code>对象的属性和方法</li><li><code>history</code>对象<ul><li><code>forward()</code> &#x2F; <code>back()</code> &#x2F; <code>go()</code></li></ul></li><li><code>location</code>对象</li><li><code>navigator</code>对象</li><li><code>screen</code>对象</li></ul><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><ul><li>DOM树</li><li>访问元素<ul><li><code>getElementById()</code> &#x2F; <code>querySelector()</code></li><li><code>getElementsByClassName()</code> &#x2F; <code>getElementsByTagName()</code> &#x2F; <code>querySelectorAll()</code></li><li><code>parentNode</code> &#x2F; <code>previousSibling</code> &#x2F; <code>nextSibling</code> &#x2F; <code>children</code> &#x2F; <code>firstChild</code> &#x2F; <code>lastChild</code></li></ul></li><li>操作元素<ul><li><code>nodeValue</code></li><li><code>innerHTML</code> &#x2F; <code>textContent</code> &#x2F; <code>createElement()</code> &#x2F; <code>createTextNode()</code> &#x2F; <code>appendChild()</code> &#x2F; <code>insertBefore()</code> &#x2F; <code>removeChild()</code></li><li><code>className</code> &#x2F; <code>id</code> &#x2F; <code>hasAttribute()</code> &#x2F; <code>getAttribute()</code> &#x2F; <code>setAttribute()</code> &#x2F; <code>removeAttribute()</code></li></ul></li><li>事件处理<ul><li>事件类型<ul><li>UI事件：<code>load</code> &#x2F; <code>unload</code> &#x2F; <code>error</code> &#x2F; <code>resize</code> &#x2F; <code>scroll</code></li><li>键盘事件：<code>keydown</code> &#x2F; <code>keyup</code> &#x2F; <code>keypress</code></li><li>鼠标事件：<code>click</code> &#x2F; <code>dbclick</code> &#x2F; <code>mousedown</code> &#x2F; <code>mouseup</code> &#x2F; <code>mousemove</code> &#x2F; <code>mouseover</code> &#x2F; <code>mouseout</code></li><li>焦点事件：<code>focus</code> &#x2F; <code>blur</code></li><li>表单事件：<code>input</code> &#x2F; <code>change</code> &#x2F; <code>submit</code> &#x2F; <code>reset</code> &#x2F; <code>cut</code> &#x2F; <code>copy</code> &#x2F; <code>paste</code> &#x2F; <code>select</code></li></ul></li><li>事件绑定<ul><li>HTML事件处理程序（不推荐使用，因为要做到标签与代码分离）</li><li>传统的DOM事件处理程序（只能附加一个回调函数）</li><li>事件监听器（旧的浏览器中不被支持）</li></ul></li><li>事件流：事件捕获 &#x2F; 事件冒泡</li><li>事件对象（低版本IE中的window.event）<ul><li><code>target</code>（有些浏览器使用srcElement）</li><li><code>type</code></li><li><code>cancelable</code></li><li><code>preventDefault()</code></li><li><code>stopPropagation()</code>（低版本IE中的cancelBubble）</li></ul></li><li>鼠标事件 - 事件发生的位置<ul><li>屏幕位置：<code>screenX</code>和<code>screenY</code></li><li>页面位置：<code>pageX</code>和<code>pageY</code></li><li>客户端位置：<code>clientX</code>和<code>clientY</code></li></ul></li><li>键盘事件 - 哪个键被按下了<ul><li><code>keyCode</code>属性（有些浏览器使用<code>which</code>）</li><li><code>String.fromCharCode(event.keyCode)</code></li></ul></li><li>HTML5事件<ul><li><code>DOMContentLoaded</code></li><li><code>hashchange</code></li><li><code>beforeunload</code></li></ul></li></ul></li></ul><h4 id="JavaScript-API"><a href="#JavaScript-API" class="headerlink" title="JavaScript API"></a>JavaScript API</h4><ul><li><p>客户端存储 - <code>localStorage</code>和<code>sessionStorage</code></p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">localStorage.colorSetting &#x3D; &#39;#a4509b&#39;;localStorage[&#39;colorSetting&#39;] &#x3D; &#39;#a4509b&#39;;localStorage.setItem(&#39;colorSetting&#39;, &#39;#a4509b&#39;);</code></pre></li><li><p>获取位置信息 - <code>geolocation</code></p><pre class="language-JavaScript" data-language="JavaScript"><code class="language-JavaScript">navigator.geolocation.getCurrentPosition(function(pos) &#123;       console.log(pos.coords.latitude)    console.log(pos.coords.longitude)&#125;)</code></pre></li><li><p>从服务器获取数据 - Fetch API</p></li><li><p>绘制图形 - <code>&lt;canvas&gt;</code>的API</p></li><li><p>音视频 - <code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>的API</p></li></ul><h3 id="使用jQuery"><a href="#使用jQuery" class="headerlink" title="使用jQuery"></a>使用jQuery</h3><h4 id="jQuery概述"><a href="#jQuery概述" class="headerlink" title="jQuery概述"></a>jQuery概述</h4><ol><li>Write Less Do More（用更少的代码来完成更多的工作）</li><li>使用CSS选择器来查找元素（更简单更方便）</li><li>使用jQuery方法来操作元素（解决浏览器兼容性问题、应用于所有元素并施加多个方法）</li></ol><h4 id="引入jQuery"><a href="#引入jQuery" class="headerlink" title="引入jQuery"></a>引入jQuery</h4><ul><li>下载jQuery的开发版和压缩版</li><li>从CDN加载jQuery</li></ul><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.3.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    window.jQuery ||         document.write(&#39;&lt;script src&#x3D;&quot;js&#x2F;jquery-3.3.1.min.js&quot;&gt;&lt;&#x2F;script&gt;&#39;)&lt;&#x2F;script&gt;</code></pre><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><ul><li>选择器<ul><li>* &#x2F; element &#x2F; #id &#x2F; .class &#x2F; selector1, selector2</li><li>ancestor descendant &#x2F; parent&gt;child &#x2F; previous+next &#x2F; previous~siblings</li></ul></li><li>筛选器<ul><li>基本筛选器：:not(selector) &#x2F; :first &#x2F; :last &#x2F; :even &#x2F; :odd &#x2F; :eq(index) &#x2F; :gt(index) &#x2F; :lt(index) &#x2F; :animated &#x2F; :focus</li><li>内容筛选器：:contains(‘…’) &#x2F; :empty &#x2F; :parent &#x2F; :has(selector)</li><li>可见性筛选器：:hidden &#x2F; :visible</li><li>子节点筛选器：:nth-child(expr) &#x2F; :first-child &#x2F; :last-child &#x2F; :only-child</li><li>属性筛选器：[attribute] &#x2F; [attribute&#x3D;’value’] &#x2F; [attribute!&#x3D;’value’] &#x2F; [attribute^&#x3D;’value’] &#x2F; [attribute$&#x3D;’value’] &#x2F; [attribute|&#x3D;’value’] &#x2F; [attribute~&#x3D;’value’]</li></ul></li><li>表单：:input &#x2F; :text &#x2F; :password &#x2F; :radio &#x2F; :checkbox &#x2F; :submit &#x2F; :image &#x2F; :reset &#x2F; :button &#x2F; :file &#x2F; :selected &#x2F; :enabled &#x2F; :disabled &#x2F; :checked</li></ul><h4 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h4><ul><li>内容操作<ul><li>获取&#x2F;修改内容：<code>html()</code> &#x2F; <code>text()</code> &#x2F; <code>replaceWith()</code> &#x2F; <code>remove()</code></li><li>获取&#x2F;设置元素：<code>before()</code> &#x2F; <code>after()</code> &#x2F; <code>prepend()</code> &#x2F; <code>append()</code> &#x2F; <code>remove()</code> &#x2F; <code>clone()</code> &#x2F; <code>unwrap()</code> &#x2F; <code>detach()</code> &#x2F; <code>empty()</code> &#x2F; <code>add()</code></li><li>获取&#x2F;修改属性：<code>attr()</code> &#x2F; <code>removeAttr()</code> &#x2F; <code>addClass()</code> &#x2F; <code>removeClass()</code> &#x2F; <code>css()</code></li><li>获取&#x2F;设置表单值：<code>val()</code></li></ul></li><li>查找操作<ul><li>查找方法：<code>find()</code> &#x2F;  <code>parent()</code> &#x2F; <code>children()</code> &#x2F; <code>siblings()</code> &#x2F; <code>next()</code> &#x2F; <code>nextAll()</code> &#x2F; <code>prev()</code> &#x2F; <code>prevAll()</code></li><li>筛选器：<code>filter()</code> &#x2F; <code>not()</code> &#x2F; <code>has()</code> &#x2F; <code>is()</code> &#x2F; <code>contains()</code></li><li>索引编号：<code>eq()</code></li></ul></li><li>尺寸和位置<ul><li>尺寸相关：<code>height()</code> &#x2F; <code>width()</code> &#x2F; <code>innerHeight()</code> &#x2F; <code>innerWidth()</code> &#x2F; <code>outerWidth()</code> &#x2F; <code>outerHeight()</code></li><li>位置相关：<code>offset()</code> &#x2F; <code>position()</code> &#x2F; <code>scrollLeft()</code> &#x2F; <code>scrollTop()</code></li></ul></li><li>特效和动画<ul><li>基本动画：<code>show()</code> &#x2F; <code>hide()</code> &#x2F; <code>toggle()</code></li><li>消失出现：<code>fadeIn()</code> &#x2F; <code>fadeOut()</code> &#x2F; <code>fadeTo()</code> &#x2F; <code>fadeToggle()</code></li><li>滑动效果：<code>slideDown()</code> &#x2F; <code>slideUp()</code> &#x2F; <code>slideToggle()</code></li><li>自定义：<code>delay()</code> &#x2F; <code>stop()</code> &#x2F; <code>animate()</code></li></ul></li><li>事件<ul><li>文档加载：<code>ready()</code> &#x2F; <code>load()</code></li><li>用户交互：<code>on()</code> &#x2F; <code>off()</code></li></ul></li></ul><h4 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h4><h4 id="检测页面是否可用"><a href="#检测页面是否可用" class="headerlink" title="检测页面是否可用"></a>检测页面是否可用</h4><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;script&gt;    $(document).ready(function() &#123;            &#125;);&lt;&#x2F;script&gt;</code></pre><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;script&gt;    $(function() &#123;            &#125;);&lt;&#x2F;script&gt;</code></pre><h4 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h4><ul><li>jQuery Validation</li><li>jQuery Treeview</li><li>jQuery Autocomplete</li><li>jQuery UI</li></ul><h4 id="避免和其他库的冲突"><a href="#避免和其他库的冲突" class="headerlink" title="避免和其他库的冲突"></a>避免和其他库的冲突</h4><p>先引入其他库再引入jQuery的情况。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;script src&#x3D;&quot;other.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;jquery.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;jQuery.noConflict();    jQuery(function() &#123;        jQuery(&#39;div&#39;).hide();    &#125;);&lt;&#x2F;script&gt;</code></pre><p>先引入jQuery再引入其他库的情况。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;script src&#x3D;&quot;jquery.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;other.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    jQuery(function() &#123;        jQuery(&#39;div&#39;).hide();    &#125;);&lt;&#x2F;script&gt;</code></pre><h4 id="使用Ajax"><a href="#使用Ajax" class="headerlink" title="使用Ajax"></a>使用Ajax</h4><p>Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p><ul><li>原生的Ajax</li><li>基于jQuery的Ajax<ul><li>加载内容</li><li>提交表单</li></ul></li></ul><h3 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h3><h4 id="渐进式框架-Vue-js"><a href="#渐进式框架-Vue-js" class="headerlink" title="渐进式框架 - Vue.js"></a>渐进式框架 - <a href="https://cn.vuejs.org/">Vue.js</a></h4><p>前后端分离开发（前端渲染）必选框架。</p><h5 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h5><ol><li><p>引入Vue的JavaScript文件，我们仍然推荐从CDN服务器加载它。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;</code></pre></li><li><p>数据绑定（声明式渲染 ）。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;h1&gt;&#123;&#123; product &#125;&#125;库存信息&lt;&#x2F;h1&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;const app &#x3D; new Vue(&#123;el: &#39;#app&#39;,data: &#123;product: &#39;iPhone X&#39;&#125;&#125;);&lt;&#x2F;script&gt;</code></pre></li><li><p>条件与循环。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;h1&gt;库存信息&lt;&#x2F;h1&gt;    &lt;hr&gt;&lt;ul&gt;&lt;li v-for&#x3D;&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;&lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt;已经售罄&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;const app &#x3D; new Vue(&#123;el: &#39;#app&#39;,data: &#123;products: [&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;]&#125;&#125;);&lt;&#x2F;script&gt;</code></pre></li><li><p>计算属性。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;h1&gt;库存信息&lt;&#x2F;h1&gt;&lt;hr&gt;&lt;ul&gt;&lt;li v-for&#x3D;&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;&lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt;已经售罄&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;const app &#x3D; new Vue(&#123;el: &#39;#app&#39;,data: &#123;products: [&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;]&#125;,computed: &#123;totalQuantity() &#123;return this.products.reduce((sum, product) &#x3D;&gt; &#123;return sum + product.quantity&#125;, 0);&#125;&#125;&#125;);&lt;&#x2F;script&gt;</code></pre></li><li><p>处理事件。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;h1&gt;库存信息&lt;&#x2F;h1&gt;&lt;hr&gt;&lt;ul&gt;&lt;li v-for&#x3D;&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;&lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt;已经售罄&lt;&#x2F;span&gt;&lt;button @click&#x3D;&quot;product.quantity +&#x3D; 1&quot;&gt;增加库存&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;const app &#x3D; new Vue(&#123;el: &#39;#app&#39;,data: &#123;products: [&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;]&#125;,computed: &#123;totalQuantity() &#123;return this.products.reduce((sum, product) &#x3D;&gt; &#123;return sum + product.quantity&#125;, 0);&#125;&#125;&#125;);&lt;&#x2F;script&gt;</code></pre></li><li><p>用户输入。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;h1&gt;库存信息&lt;&#x2F;h1&gt;&lt;hr&gt;&lt;ul&gt;&lt;li v-for&#x3D;&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &lt;input type&#x3D;&quot;number&quot; v-model.number&#x3D;&quot;product.quantity&quot; min&#x3D;&quot;0&quot;&gt;&lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt;已经售罄&lt;&#x2F;span&gt;&lt;button @click&#x3D;&quot;product.quantity +&#x3D; 1&quot;&gt;增加库存&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;h2&gt;库存总量：&#123;&#123; totalQuantity &#125;&#125;台&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;const app &#x3D; new Vue(&#123;el: &#39;#app&#39;,data: &#123;products: [&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;iPhone X&quot;, &quot;quantity&quot;: 20&#125;,&#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;华为 Mate20&quot;, &quot;quantity&quot;: 0&#125;,&#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;小米 Mix3&quot;, &quot;quantity&quot;: 50&#125;]&#125;,computed: &#123;totalQuantity() &#123;return this.products.reduce((sum, product) &#x3D;&gt; &#123;return sum + product.quantity&#125;, 0);&#125;&#125;&#125;);&lt;&#x2F;script&gt;</code></pre></li><li><p>通过网络加载JSON数据。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;h2&gt;库存信息&lt;&#x2F;h2&gt;&lt;ul&gt;&lt;li v-for&#x3D;&quot;product in products&quot;&gt;&#123;&#123; product.name &#125;&#125; - &#123;&#123; product.quantity &#125;&#125;&lt;span v-if&#x3D;&quot;product.quantity &#x3D;&#x3D;&#x3D; 0&quot;&gt;已经售罄&lt;&#x2F;span&gt;&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;const app &#x3D; new Vue(&#123;el: &#39;#app&#39;,data: &#123;products: []&#125;，created() &#123;fetch(&#39;https:&#x2F;&#x2F;jackfrued.top&#x2F;api&#x2F;products&#39;).then(response &#x3D;&gt; response.json()).then(json &#x3D;&gt; &#123;this.products &#x3D; json&#125;);&#125;&#125;);&lt;&#x2F;script&gt;</code></pre></li></ol><h5 id="使用脚手架-vue-cli"><a href="#使用脚手架-vue-cli" class="headerlink" title="使用脚手架 - vue-cli"></a>使用脚手架 - vue-cli</h5><p>Vue为商业项目开发提供了非常便捷的脚手架工具vue-cli，通过工具可以省去手工配置开发环境、测试环境和运行环境的步骤，让开发者只需要关注要解决的问题。</p><ol><li>安装脚手架。</li><li>创建项目。</li><li>安装依赖包。</li><li>运行项目。</li></ol><h4 id="UI框架-Element"><a href="#UI框架-Element" class="headerlink" title="UI框架 - Element"></a>UI框架 - <a href="http://element-cn.eleme.io/#/zh-CN">Element</a></h4><p>基于Vue 2.0的桌面端组件库，用于构造用户界面，支持响应式布局。</p><ol><li><p>引入Element的CSS和JavaScript文件。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;!-- 引入样式 --&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt;&lt;!-- 引入组件库 --&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</code></pre></li><li><p>一个简单的例子。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;&lt;el-button @click&#x3D;&quot;visible &#x3D; true&quot;&gt;点我&lt;&#x2F;el-button&gt;&lt;el-dialog :visible.sync&#x3D;&quot;visible&quot; title&#x3D;&quot;Hello world&quot;&gt;&lt;p&gt;开始使用Element吧&lt;&#x2F;p&gt;&lt;&#x2F;el-dialog&gt;            &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;new Vue(&#123;el: &#39;#app&#39;,data: &#123;visible: false,&#125;&#125;)&lt;&#x2F;script&gt;&lt;&#x2F;html&gt;</code></pre></li><li><p>使用组件。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;&lt;el-table :data&#x3D;&quot;tableData&quot; stripe style&#x3D;&quot;width: 100%&quot;&gt;&lt;el-table-column prop&#x3D;&quot;date&quot; label&#x3D;&quot;日期&quot; width&#x3D;&quot;180&quot;&gt;&lt;&#x2F;el-table-column&gt;&lt;el-table-column prop&#x3D;&quot;name&quot; label&#x3D;&quot;姓名&quot; width&#x3D;&quot;180&quot;&gt;&lt;&#x2F;el-table-column&gt;&lt;el-table-column prop&#x3D;&quot;address&quot; label&#x3D;&quot;地址&quot;&gt;&lt;&#x2F;el-table-column&gt;&lt;&#x2F;el-table&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;element-ui&#x2F;lib&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;new Vue(&#123;el: &#39;#app&#39;,data: &#123;tableData:  [&#123;date: &#39;2016-05-02&#39;,name: &#39;王一霸&#39;,address: &#39;上海市普陀区金沙江路 1518 弄&#39;&#125;, &#123;date: &#39;2016-05-04&#39;,name: &#39;刘二狗&#39;,address: &#39;上海市普陀区金沙江路 1517 弄&#39;&#125;, &#123;date: &#39;2016-05-01&#39;,name: &#39;杨三萌&#39;,address: &#39;上海市普陀区金沙江路 1519 弄&#39;&#125;, &#123;date: &#39;2016-05-03&#39;,name: &#39;陈四吹&#39;,address: &#39;上海市普陀区金沙江路 1516 弄&#39;&#125;]&#125;&#125;)&lt;&#x2F;script&gt;&lt;&#x2F;html&gt;</code></pre></li></ol><h4 id="报表框架-ECharts"><a href="#报表框架-ECharts" class="headerlink" title="报表框架 - ECharts"></a>报表框架 - <a href="https://echarts.baidu.com/">ECharts</a></h4><p>百度出品的开源可视化库，常用于生成各种类型的报表。</p><p><img src="/./res/baidu_echarts.png"></p><h4 id="基于弹性盒子的CSS框架-Bulma"><a href="#基于弹性盒子的CSS框架-Bulma" class="headerlink" title="基于弹性盒子的CSS框架 - Bulma"></a>基于弹性盒子的CSS框架 - <a href="https://bulma.io/">Bulma</a></h4><p>Bulma是一个基于Flexbox的现代化的CSS框架，其初衷就是移动优先（Mobile First），模块化设计，可以轻松用来实现各种简单或者复杂的内容布局，即使不懂CSS的开发者也能够使用它定制出漂亮的页面。</p><pre class="language-HTML" data-language="HTML"><code class="language-HTML">&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&lt;title&gt;Bulma&lt;&#x2F;title&gt;&lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;bulma&#x2F;0.7.4&#x2F;css&#x2F;bulma.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;div &#123; margin-top: 10px; &#125;.column &#123; color: #fff; background-color: #063; margin: 10px 10px; text-align: center; &#125;&lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div class&#x3D;&quot;columns&quot;&gt;&lt;div class&#x3D;&quot;column&quot;&gt;1&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;column&quot;&gt;2&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;column&quot;&gt;3&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;column&quot;&gt;4&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;a class&#x3D;&quot;button is-primary&quot;&gt;Primary&lt;&#x2F;a&gt;&lt;a class&#x3D;&quot;button is-link&quot;&gt;Link&lt;&#x2F;a&gt;&lt;a class&#x3D;&quot;button is-info&quot;&gt;Info&lt;&#x2F;a&gt;&lt;a class&#x3D;&quot;button is-success&quot;&gt;Success&lt;&#x2F;a&gt;&lt;a class&#x3D;&quot;button is-warning&quot;&gt;Warning&lt;&#x2F;a&gt;&lt;a class&#x3D;&quot;button is-danger&quot;&gt;Danger&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;progress class&#x3D;&quot;progress is-danger is-medium&quot; max&#x3D;&quot;100&quot;&gt;60%&lt;&#x2F;progress&gt;&lt;&#x2F;div&gt;&lt;div&gt;&lt;table class&#x3D;&quot;table is-hoverable&quot;&gt;&lt;tr&gt;&lt;th&gt;One&lt;&#x2F;th&gt;&lt;th&gt;Two&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;Three&lt;&#x2F;td&gt;&lt;td&gt;Four&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;Five&lt;&#x2F;td&gt;&lt;td&gt;Six&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;Seven&lt;&#x2F;td&gt;&lt;td&gt;Eight&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;Nine&lt;&#x2F;td&gt;&lt;td&gt;Ten&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;tr&gt;&lt;td&gt;Eleven&lt;&#x2F;td&gt;&lt;td&gt;Twelve&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4 id="响应式布局框架-Bootstrap"><a href="#响应式布局框架-Bootstrap" class="headerlink" title="响应式布局框架 - Bootstrap"></a>响应式布局框架 - <a href="http://www.bootcss.com/">Bootstrap</a></h4><p>用于快速开发Web应用程序的前端框架，支持响应式布局。</p><ol><li><p>特点</p><ul><li>支持主流的浏览器和移动设备</li><li>容易上手</li><li>响应式设计</li></ul></li><li><p>内容</p><ul><li>网格系统</li><li>封装的CSS</li><li>现成的组件</li><li>JavaScript插件</li></ul></li><li><p>可视化</p><p><img src="/./res/bootstrap-layoutit.png"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Web前端概述&quot;&gt;&lt;a href=&quot;#Web前端概述&quot; class=&quot;headerlink&quot; title=&quot;Web前端概述&quot;&gt;&lt;/a&gt;Web前端概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：本文使用的部分插图来自&lt;em&gt;Jo</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>31-35.玩转Linux操作系统</title>
    <link href="http://wstcly.xyz/2024/07/01/31-35.wan-zhuan-linux-cao-zuo-xi-tong/"/>
    <id>http://wstcly.xyz/2024/07/01/31-35.wan-zhuan-linux-cao-zuo-xi-tong/</id>
    <published>2024-07-01T13:08:26.000Z</published>
    <updated>2024-07-01T13:18:10.721Z</updated>
    
    <content type="html"><![CDATA[<p>玩转Linux操作系统</p><blockquote><p><strong>说明</strong>：本文中对Linux命令的讲解都是基于名为CentOS的Linux发行版本，我自己使用的是阿里云服务器，系统版本为CentOS Linux release 7.6.1810。不同的Linux发行版本在Shell命令和工具程序上会有一些差别，但是这些差别是很小的。</p></blockquote><h3 id="操作系统发展史"><a href="#操作系统发展史" class="headerlink" title="操作系统发展史"></a>操作系统发展史</h3><p>只有硬件没有软件的计算机系统被称之为“裸机”，我们很难用“裸机”来完成计算机日常的工作（如存储和运算），所以必须用特定的软件来控制硬件的工作。最靠近计算机硬件的软件是系统软件，其中最为重要的就是“操作系统”。“操作系统”是控制和管理整个计算机硬件和软件资源、实现资源分配和任务调配、为系统用户以及其他软件提供接口和环境的程序的集合。</p><h4 id="没有操作系统（手工操作）"><a href="#没有操作系统（手工操作）" class="headerlink" title="没有操作系统（手工操作）"></a>没有操作系统（手工操作）</h4><p>在计算机诞生之初没有操作系统的年代，人们先把程序纸带（或卡片）装上计算机，然后启动输入机把程序送入计算机，接着通过控制台开关启动程序运行。当程序执行完毕，打印机输出计算的结果，用户卸下并取走纸带（或卡片）。第二个用户上机，重复同样的步骤。在整个过程中用户独占机器，CPU等待手工操作，资源利用率极低。</p><h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>首先启动计算机上的一个监督程序，在监督程序的控制下，计算机能够自动的、成批的处理一个或多个用户的作业。完成一批作业后，监督程度又从输入机读取作业存入磁带机。按照上面的步骤重复处理任务。监督程序不停的处理各个作业，实现了作业的自动转接，减少了作业的建立时间和手工操作时间，提高了计算机资源的利用率。 批处理系统又可以分为单道批处理系统、多道批处理系统、联机批处理系统、脱机批处理系统。</p><h4 id="分时系统和实时系统"><a href="#分时系统和实时系统" class="headerlink" title="分时系统和实时系统"></a>分时系统和实时系统</h4><p>分时系统是把处理器的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。 若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮调度时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在在严格的时间范围内完成事件处理，及时响应随机外部事件的实时系统。</p><h4 id="通用操作系统"><a href="#通用操作系统" class="headerlink" title="通用操作系统"></a>通用操作系统</h4><ol><li><p>1960s：IBM的System&#x2F;360系列的机器有了统一的操作系统OS&#x2F;360。</p></li><li><p>1965年：AT&amp;T的贝尔实验室加入GE和MIT的合作计划开始开发MULTICS。</p></li><li><p>1969年：MULTICS项目失败，Ken Tompson赋闲在家，为了玩“Space Travel”游戏用汇编语言在当时已经被淘汰的PDP-7上开发了Unics。</p><blockquote><p>注：很难想象，Unix这么伟大的操作系统，居然是一个赋闲在家的程序员（关键是老婆回娘家还带上了孩子）在一台被淘汰的设备上为了玩游戏开发出来的。</p></blockquote></li><li><p>1970年~1971年：Ken Thompson和Dennis Ritchie用B语言在PDP-11上重写了Unics，并在Brian Kernighan的建议下将其更名为Unix。</p><img src="res/ken-and-dennis-pdp-11.png" style="zoom:62%;" /></li><li><p>1972年~1973年：Dennis Ritchie发明了C语言来取代可移植性较差的B语言，并开启了用C语言重写Unix的工作。</p></li><li><p>1974年：Unix推出了里程碑意义的第5版，几乎完全用C语言来实现。</p></li><li><p>1979年：从Unix第7版开始，AT&amp;T发布新的使用条款，将Unix私有化。</p></li><li><p>1987年：Andrew S. Tanenbaum教授为了能在课堂上为学生讲解操作系统运作的细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与Unix兼容的操作系统以避免版权上的争议，该系统被命名为Minix。</p><img src="res/andrew.jpg" style="zoom:50%;" /></li><li><p>1991年：Linus Torvalds就读于芬兰赫尔辛基大学期间，尝试在Minix上做一些开发工作，但因为Minix只是作为教学用途的操作系统，功能并不强大，为了方便在学校的新闻组和邮件系统中读写和下载文件，Linus编写了磁盘驱动程序和文件系统，这些东西形成了Linux系统内核的雏形。</p><p><img src="/./res/linus.png"></p></li></ol><p>下图是Unix操作系统家族的图谱。</p><p><img src="/./res/history-of-unix.png"></p><h3 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h3><p>Linux是一个通用操作系统。一个操作系统要负责任务调度、内存分配、处理外围设备I&#x2F;O等操作。操作系统通常由内核（运行其他程序，管理像磁盘、打印机等硬件设备的核心程序）和系统程序（设备驱动、底层库、shell、服务程序等）两部分组成。</p><p>Linux内核是芬兰人Linus Torvalds开发的，于1991年9月发布。而Linux操作系统作为Internet时代的产物，它是由全世界许多开发者共同合作开发的，是一个自由的操作系统（注意自由和免费并不是同一个概念，想了解二者的差别可以<a href="https://www.debian.org/intro/free">点击这里</a>）。</p><h3 id="Linux系统优点"><a href="#Linux系统优点" class="headerlink" title="Linux系统优点"></a>Linux系统优点</h3><ol><li>通用操作系统，不跟特定的硬件绑定。</li><li>用C语言编写，可移植性强，有内核编程接口。</li><li>支持多用户和多任务，支持安全的分层文件系统。</li><li>大量的实用程序，完善的网络功能以及强大的支持文档。</li><li>可靠的安全性和良好的稳定性，对开发者更友好。</li></ol><h3 id="Linux系统发行版本"><a href="#Linux系统发行版本" class="headerlink" title="Linux系统发行版本"></a>Linux系统发行版本</h3><ol><li><a href="https://www.redhat.com/en">Redhat</a></li><li><a href="https://www.ubuntu.com/">Ubuntu</a></li><li><a href="https://www.centos.org/">CentOS</a></li><li><a href="https://getfedora.org/">Fedora</a></li><li><a href="https://www.debian.org/">Debian</a></li><li><a href="https://www.opensuse.org/">openSUSE</a></li></ol><h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p>Linux系统的命令通常都是如下所示的格式：</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">命令名称 [命名参数] [命令对象]</code></pre><ol><li><p>获取登录信息 - <strong>w</strong> &#x2F; <strong>who</strong> &#x2F; <strong>last</strong>&#x2F; <strong>lastb</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# w 23:31:16 up 12:16,  2 users,  load average: 0.00, 0.01, 0.05USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATroot     pts&#x2F;0    182.139.66.250   23:03    4.00s  0.02s  0.00s wjackfrue pts&#x2F;1    182.139.66.250   23:26    3:56   0.00s  0.00s -bash[root ~]# whoroot     pts&#x2F;0        2018-04-12 23:03 (182.139.66.250)jackfrued pts&#x2F;1        2018-04-12 23:26 (182.139.66.250)[root ~]# who am iroot     pts&#x2F;0        2018-04-12 23:03 (182.139.66.250)[root ~]# who mom likesroot     pts&#x2F;0        2018-04-12 23:03 (182.139.66.250)[root ~]# lastroot     pts&#x2F;0        117.136.63.184   Sun May 26 18:57   still logged in   reboot   system boot  3.10.0-957.10.1. Mon May 27 02:52 - 19:10  (-7:-42)   root     pts&#x2F;4        117.136.63.184   Sun May 26 18:51 - crash  (08:01)    root     pts&#x2F;4        117.136.63.184   Sun May 26 18:49 - 18:49  (00:00)    root     pts&#x2F;3        117.136.63.183   Sun May 26 18:35 - crash  (08:17)    root     pts&#x2F;2        117.136.63.183   Sun May 26 18:34 - crash  (08:17)    root     pts&#x2F;0        117.136.63.183   Sun May 26 18:10 - crash  (08:42)    </code></pre></li><li><p>查看自己使用的Shell - <strong>ps</strong>。</p><p>Shell也被称为“壳”或“壳程序”，它是用户与操作系统内核交流的翻译官，简单的说就是人与计算机交互的界面和接口。目前很多Linux系统默认的Shell都是bash（<u>B</u>ourne <u>A</u>gain <u>SH</u>ell），因为它可以使用tab键进行命令和路径补全、可以保存历史命令、可以方便的配置环境变量以及执行批处理操作。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ps  PID TTY          TIME CMD 3531 pts&#x2F;0    00:00:00 bash 3553 pts&#x2F;0    00:00:00 ps</code></pre></li><li><p>查看命令的说明和位置 - <strong>whatis</strong> &#x2F; <strong>which</strong> &#x2F; <strong>whereis</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# whatis psps (1)        - report a snapshot of the current processes.[root ~]# whatis pythonpython (1)    - an interpreted, interactive, object-oriented programming language[root ~]# whereis psps: &#x2F;usr&#x2F;bin&#x2F;ps &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;ps.1.gz[root ~]# whereis pythonpython: &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;python2.7 &#x2F;usr&#x2F;lib&#x2F;python2.7 &#x2F;usr&#x2F;lib64&#x2F;python2.7 &#x2F;etc&#x2F;python &#x2F;usr&#x2F;include&#x2F;python2.7 &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;python.1.gz[root ~]# which ps&#x2F;usr&#x2F;bin&#x2F;ps[root ~]# which python&#x2F;usr&#x2F;bin&#x2F;python</code></pre></li><li><p>清除屏幕上显示的内容 - <strong>clear</strong>。</p></li><li><p>查看帮助文档 - <strong>man</strong> &#x2F; <strong>info</strong> &#x2F; <strong>–help</strong> &#x2F; <strong>apropos</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@izwz97tbgo9lkabnat2lo8z ~]# ps --helpUsage: ps [options] Try &#39;ps --help &lt;simple|list|output|threads|misc|all&gt;&#39;  or &#39;ps --help &lt;s|l|o|t|m|a&gt;&#39; for additional help text.For more details see ps(1).[root@izwz97tbgo9lkabnat2lo8z ~]# man psPS(1)                                User Commands                                PS(1)NAME       ps - report a snapshot of the current processes.SYNOPSIS       ps [options]DESCRIPTION...</code></pre></li><li><p>查看系统和主机名 - <strong>uname</strong> &#x2F; <strong>hostname</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@izwz97tbgo9lkabnat2lo8z ~]# unameLinux[root@izwz97tbgo9lkabnat2lo8z ~]# hostnameizwz97tbgo9lkabnat2lo8z[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat &#x2F;etc&#x2F;centos-releaseCentOS Linux release 7.6.1810 (Core)</code></pre><blockquote><p>说明：<code>cat</code>是连接文件内容并打印到标准输出的命令，后面会讲到该命令；<code>/etc</code>是Linux系统上的一个非常重要的目录，它保存了很多的配置文件；<code>centos-release</code>是该目录下的一个文件，因为我自己使用的Linux发行版本是CentOS 7.6，因此这里会有一个这样的文件。</p></blockquote></li><li><p>时间和日期 - <strong>date</strong> &#x2F; <strong>cal</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# dateWed Jun 20 12:53:19 CST 2018[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal      June 2018Su Mo Tu We Th Fr Sa                1  2 3  4  5  6  7  8  910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 30[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal 5 2017      May 2017Su Mo Tu We Th Fr Sa    1  2  3  4  5  6 7  8  9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31</code></pre></li><li><p>重启和关机 - <strong>reboot</strong> &#x2F; <strong>shutdown</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# shutdown -h +5Shutdown scheduled for Sun 2019-05-26 19:34:27 CST, use &#39;shutdown -c&#39; to cancel.[root ~]# Broadcast message from root (Sun 2019-05-26 19:29:27 CST):The system is going down for power-off at Sun 2019-05-26 19:34:27 CST![root ~]# shutdown -cBroadcast message from root (Sun 2019-05-26 19:30:22 CST):The system shutdown has been cancelled at Sun 2019-05-26 19:31:22 CST![root ~]# shutdown -r 23:58Shutdown scheduled for Sun 2019-05-26 23:58:00 CST, use &#39;shutdown -c&#39; to cancel.[root ~]# shutdown -cBroadcast message from root (Sun 2019-05-26 19:31:06 CST):The system shutdown has been cancelled at Sun 2019-05-26 19:32:06 CST!</code></pre><blockquote><p>说明：在执行<code>shutdown</code>命令时会向登录系统的用户发出警告，可以在命令后面跟上警告消息来替换默认的警告消息，也可以在<code>-h</code>参数后通过<code>now</code>来表示立刻关机。</p></blockquote></li><li><p>退出登录 -  <strong>exit</strong> &#x2F; <strong>logout</strong>。</p></li><li><p>查看历史命令 - <strong>history</strong>。</p></li></ol>  <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# history...452  ls453  cd Python-3.6.5&#x2F;454  clear455  history[root@iZwz97tbgo9lkabnat2lo8Z ~]# !454</code></pre><blockquote><p><strong>说明</strong>：查看到历史命令之后，可以用<code>!历史命令编号</code>来重新执行该命令；通过<code>history -c</code>可以清除历史命令。</p></blockquote><h3 id="实用程序"><a href="#实用程序" class="headerlink" title="实用程序"></a>实用程序</h3><h4 id="文件和文件夹操作"><a href="#文件和文件夹操作" class="headerlink" title="文件和文件夹操作"></a>文件和文件夹操作</h4><ol><li><p>创建&#x2F;删除空目录 - <strong>mkdir</strong> &#x2F; <strong>rmdir</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# mkdir abc[root ~]# mkdir -p xyz&#x2F;abc[root ~]# rmdir abc</code></pre></li><li><p>创建&#x2F;删除文件 - <strong>touch</strong> &#x2F; <strong>rm</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# touch readme.txt[root ~]# touch error.txt[root ~]# rm error.txtrm: remove regular empty file ‘error.txt’? y[root ~]# rm -rf xyz</code></pre><ul><li><code>touch</code>命令用于创建空白文件或修改文件时间。在Linux系统中一个文件有三种时间：<ul><li>更改内容的时间 - mtime。</li><li>更改权限的时间 - ctime。</li><li>最后访问时间 - atime。</li></ul></li><li><code>rm</code>的几个重要参数：<ul><li><code>-i</code>：交互式删除，每个删除项都会进行询问。</li><li><code>-r</code>：删除目录并递归的删除目录中的文件和目录。</li><li><code>-f</code>：强制删除，忽略不存在的文件，没有任何提示。</li></ul></li></ul></li><li><p>切换和查看当前工作目录 - <strong>cd</strong> &#x2F; <strong>pwd</strong>。</p><blockquote><p>说明：<code>cd</code>命令后面可以跟相对路径（以当前路径作为参照）或绝对路径（以<code>/</code>开头）来切换到指定的目录，也可以用<code>cd ..</code>来返回上一级目录。请大家想一想，如果要返回到上上一级目录应该给<code>cd</code>命令加上什么样的参数呢？</p></blockquote></li><li><p>查看目录内容 - <strong>ls</strong>。</p><ul><li><code>-l</code>：以长格式查看文件和目录。</li><li><code>-a</code>：显示以点开头的文件和目录（隐藏文件）。</li><li><code>-R</code>：遇到目录要进行递归展开（继续列出目录下面的文件和目录）。</li><li><code>-d</code>：只列出目录，不列出其他内容。</li><li><code>-S</code> &#x2F; <code>-t</code>：按大小&#x2F;时间排序。</li></ul></li><li><p>查看文件内容 - <strong>cat</strong> &#x2F; <strong>tac</strong> &#x2F; <strong>head</strong> &#x2F; <strong>tail</strong> &#x2F; <strong>more</strong> &#x2F; <strong>less</strong> &#x2F; <strong>rev</strong> &#x2F; <strong>od</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# wget http:&#x2F;&#x2F;www.sohu.com&#x2F; -O sohu.html--2018-06-20 18:42:34--  http:&#x2F;&#x2F;www.sohu.com&#x2F;Resolving www.sohu.com (www.sohu.com)... 14.18.240.6Connecting to www.sohu.com (www.sohu.com)|14.18.240.6|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 212527 (208K) [text&#x2F;html]Saving to: ‘sohu.html’100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 212,527     --.-K&#x2F;s   in 0.03s2018-06-20 18:42:34 (7.48 MB&#x2F;s) - ‘sohu.html’ saved [212527&#x2F;212527][root ~]# cat sohu.html...[root ~]# head -10 sohu.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;搜狐&lt;&#x2F;title&gt;&lt;meta name&#x3D;&quot;Keywords&quot; content&#x3D;&quot;搜狐,门户网站,新媒体,网络媒体,新闻,财经,体育,娱乐,时尚,汽车,房产,科技,图片,论坛,微博,博客,视频,电影,电视剧&quot;&#x2F;&gt;&lt;meta name&#x3D;&quot;Description&quot; content&#x3D;&quot;搜狐网为用户提供24小时不间断的最新资讯，及搜索、邮件等网络服务。内容包括全球热点事件、突发新闻、时事评论、热播影视剧、体育赛事、行业动态、生活服务信息，以及论坛、博客、微博、我的搜狐等互动空间。&quot; &#x2F;&gt;&lt;meta name&#x3D;&quot;shenma-site-verification&quot; content&#x3D;&quot;1237e4d02a3d8d73e96cbd97b699e9c3_1504254750&quot;&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&#x2F;&gt;&lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;Edge,chrome&#x3D;1&quot;&#x2F;&gt;[root ~]# tail -2 sohu.html&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;[root ~]# less sohu.html...[root ~]# cat -n sohu.html | more...</code></pre><blockquote><p><strong>说明</strong>：上面用到了一个名为<code>wget</code>的命令，它是一个网络下载器程序，可以从指定的URL下载资源。</p></blockquote></li><li><p>拷贝&#x2F;移动文件 - <strong>cp</strong> &#x2F; <strong>mv</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# mkdir backup[root ~]# cp sohu.html backup&#x2F;[root ~]# cd backup[root backup]# lssohu.html[root backup]# mv sohu.html sohu_index.html[root backup]# lssohu_index.html</code></pre></li><li><p>文件重命名 - <strong>rename</strong>。</p></li></ol>  <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# rename .htm .html *.htm</code></pre><ol start="8"><li><p>查找文件和查找内容 - <strong>find</strong> &#x2F; <strong>grep</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find &#x2F; -name &quot;*.html&quot;&#x2F;root&#x2F;sohu.html&#x2F;root&#x2F;backup&#x2F;sohu_index.html[root@izwz97tbgo9lkabnat2lo8z ~]# find . -atime 7 -type f -print[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -size +2k[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -name &quot;*.swp&quot; -delete[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep &quot;&lt;script&gt;&quot; sohu.html -n20:&lt;script&gt;[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep -E \&lt;\&#x2F;?script.*\&gt; sohu.html -n20:&lt;script&gt;22:&lt;&#x2F;script&gt;24:&lt;script src&#x3D;&quot;&#x2F;&#x2F;statics.itc.cn&#x2F;web&#x2F;v3&#x2F;static&#x2F;js&#x2F;es5-shim-08e41cfc3e.min.js&quot;&gt;&lt;&#x2F;script&gt;25:&lt;script src&#x3D;&quot;&#x2F;&#x2F;statics.itc.cn&#x2F;web&#x2F;v3&#x2F;static&#x2F;js&#x2F;es5-sham-1d5fa1124b.min.js&quot;&gt;&lt;&#x2F;script&gt;26:&lt;script src&#x3D;&quot;&#x2F;&#x2F;statics.itc.cn&#x2F;web&#x2F;v3&#x2F;static&#x2F;js&#x2F;html5shiv-21fc8c2ba6.js&quot;&gt;&lt;&#x2F;script&gt;29:&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;52:&lt;&#x2F;script&gt;...</code></pre><blockquote><p><strong>说明</strong>：<code>grep</code>在搜索字符串时可以使用正则表达式，如果需要使用正则表达式可以用<code>grep -E</code>或者直接使用<code>egrep</code>。</p></blockquote></li><li><p>创建链接和查看链接 - <strong>ln</strong> &#x2F; <strong>readlink</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html-rw-r--r-- 1 root root 212131 Jun 20 19:15 sohu.html[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln &#x2F;root&#x2F;sohu.html &#x2F;root&#x2F;backup&#x2F;sohu_backup[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html-rw-r--r-- 2 root root 212131 Jun 20 19:15 sohu.html[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln &#x2F;root&#x2F;sohu.html &#x2F;root&#x2F;backup&#x2F;sohu_backup2[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html-rw-r--r-- 3 root root 212131 Jun 20 19:15 sohu.html[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln -s &#x2F;etc&#x2F;centos-release sysinfo[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sysinfolrwxrwxrwx 1 root root 19 Jun 20 19:21 sysinfo -&gt; &#x2F;etc&#x2F;centos-release[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat sysinfoCentOS Linux release 7.4.1708 (Core)[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat &#x2F;etc&#x2F;centos-releaseCentOS Linux release 7.4.1708 (Core)</code></pre><blockquote><p><strong>说明</strong>：链接可以分为硬链接和软链接（符号链接）。硬链接可以认为是一个指向文件数据的指针，就像Python中对象的引用计数，每添加一个硬链接，文件的对应链接数就增加1，只有当文件的链接数为0时，文件所对应的存储空间才有可能被其他文件覆盖。我们平常删除文件时其实并没有删除硬盘上的数据，我们删除的只是一个指针，或者说是数据的一条使用记录，所以类似于“文件粉碎机”之类的软件在“粉碎”文件时除了删除文件指针，还会在文件对应的存储区域填入数据来保证文件无法再恢复。软链接类似于Windows系统下的快捷方式，当软链接链接的文件被删除时，软链接也就失效了。</p></blockquote></li><li><p>压缩&#x2F;解压缩和归档&#x2F;解归档 - <strong>gzip</strong> &#x2F; <strong>gunzip</strong> &#x2F; <strong>xz</strong>。</p></li></ol>  <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.10.tar.gz--2018-06-20 19:29:59--  http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.10.tar.gzResolving download.redis.io (download.redis.io)... 109.74.203.151Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 1738465 (1.7M) [application&#x2F;x-gzip]Saving to: ‘redis-4.0.10.tar.gz’100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 1,738,465   70.1KB&#x2F;s   in 74s2018-06-20 19:31:14 (22.9 KB&#x2F;s) - ‘redis-4.0.10.tar.gz’ saved [1738465&#x2F;1738465][root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*redis-4.0.10.tar.gz[root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip redis-4.0.10.tar.gz[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*redis-4.0.10.tar</code></pre><ol start="11"><li>归档和解归档 - <strong>tar</strong>。</li></ol>   <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis-4.0.10.tarredis-4.0.10&#x2F;redis-4.0.10&#x2F;.gitignoreredis-4.0.10&#x2F;00-RELEASENOTESredis-4.0.10&#x2F;BUGSredis-4.0.10&#x2F;CONTRIBUTINGredis-4.0.10&#x2F;COPYINGredis-4.0.10&#x2F;INSTALLredis-4.0.10&#x2F;MANIFESTOredis-4.0.10&#x2F;Makefileredis-4.0.10&#x2F;README.mdredis-4.0.10&#x2F;deps&#x2F;redis-4.0.10&#x2F;deps&#x2F;Makefileredis-4.0.10&#x2F;deps&#x2F;README.md...</code></pre><blockquote><p>说明：归档（也称为创建归档）和解归档都使用<code>tar</code>命令，通常创建归档需要<code>-cvf</code>三个参数，其中<code>c</code>表示创建（create），<code>v</code>表示显示创建归档详情（verbose），<code>f</code>表示指定归档的文件（file）；解归档需要加上<code>-xvf</code>参数，其中<code>x</code>表示抽取（extract），其他两个参数跟创建归档相同。</p></blockquote><ol start="12"><li>将标准输入转成命令行参数 - <strong>xargs</strong>。</li></ol><p>   下面的命令会将查找当前路径下的html文件，然后通过<code>xargs</code>将这些文件作为参数传给<code>rm</code>命令，实现查找并删除文件的操作。</p>   <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find . -type f -name &quot;*.html&quot; | xargs rm -f</code></pre><p>   下面的命令将a.txt文件中的多行内容变成一行输出到b.txt文件中，其中<code>&lt;</code>表示从a.txt中读取输入，<code>&gt;</code>表示将命令的执行结果输出到b.txt中。</p>   <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root@iZwz97tbgo9lkabnat2lo8Z ~]# xargs &lt; a.txt &gt; b.txt</code></pre><blockquote><p><strong>说明</strong>：这个命令就像上面演示的那样常在管道（实现进程间通信的一种方式）和重定向（重新指定输入输出的位置）操作中用到，后面的内容中会讲到管道操作和输入输出重定向操作。</p></blockquote><ol start="13"><li><p>显示文件或目录 - <strong>basename</strong> &#x2F; <strong>dirname</strong>。</p></li><li><p>其他相关工具。</p></li></ol><ul><li><strong>sort</strong> - 对内容排序</li><li><strong>uniq</strong> - 去掉相邻重复内容</li><li><strong>tr</strong> - 替换指定内容为新内容</li><li><strong>cut</strong> &#x2F; <strong>paste</strong> - 剪切&#x2F;黏贴内容</li><li><strong>split</strong> - 拆分文件</li><li><strong>file</strong> - 判断文件类型</li><li><strong>wc</strong> - 统计文件行数、单词数、字节数</li><li><strong>iconv</strong> - 编码转换</li></ul>   <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# cat foo.txtgrapeapplepitaya[root ~]# cat bar.txt100200300400[root ~]# paste foo.txt bar.txtgrape   100apple   200pitaya  300        400[root ~]# paste foo.txt bar.txt &gt; hello.txt[root ~]# cut -b 4-8 hello.txtpe      10le      20aya     30[root ~]# cat hello.txt | tr &#39;\t&#39; &#39;,&#39;grape,100apple,200pitaya,300,400[root ~]# split -l 100 sohu.html hello[root ~]# wget https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;bd_logo1.png[root ~]# file bd_logo1.pngbd_logo1.png: PNG image data, 540 x 258, 8-bit colormap, non-interlaced[root ~]# wc sohu.html  2979   6355 212527 sohu.html[root ~]# wc -l sohu.html2979 sohu.html[root ~]# wget http:&#x2F;&#x2F;www.qq.com -O qq.html[root ~]# iconv -f gb2312 -t utf-8 qq.html</code></pre><h4 id="管道和重定向"><a href="#管道和重定向" class="headerlink" title="管道和重定向"></a>管道和重定向</h4><ol><li><p>管道的使用 - <strong>|</strong>。</p><p>例子：查找当前目录下文件个数。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# find .&#x2F; | wc -l6152</code></pre><p>例子：列出当前路径下的文件和文件夹，给每一项加一个编号。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ls | cat -n     1  dump.rdb     2  mongodb-3.6.5     3  Python-3.6.5     4  redis-3.2.11     5  redis.conf</code></pre><p>例子：查找record.log中包含AAA，但不包含BBB的记录的总数</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# cat record.log | grep AAA | grep -v BBB | wc -l</code></pre></li><li><p>输出重定向和错误重定向 - <strong>&gt;</strong> &#x2F; <strong>&gt;&gt;</strong> &#x2F; <strong>2&gt;</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# cat readme.txtbananaapplegrapeapplegrapewatermelonpearpitaya[root ~]# cat readme.txt | sort | uniq &gt; result.txt[root ~]# cat result.txtapplebananagrapepearpitayawatermelon</code></pre></li><li><p>输入重定向 - <strong>&lt;</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# echo &#39;hello, world!&#39; &gt; hello.txt[root ~]# wall &lt; hello.txt[root ~]#Broadcast message from root (Wed Jun 20 19:43:05 2018):hello, world![root ~]# echo &#39;I will show you some code.&#39; &gt;&gt; hello.txt[root ~]# wall &lt; hello.txt[root ~]#Broadcast message from root (Wed Jun 20 19:43:55 2018):hello, world!I will show you some code.</code></pre></li><li><p>多重定向 - <strong>tee</strong>。</p><p>下面的命令除了在终端显示命令<code>ls</code>的结果之外，还会追加输出到<code>ls.txt</code>文件中。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ls | tee -a ls.txt</code></pre></li></ol><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><ol><li><p><strong>alias</strong></p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# alias ll&#x3D;&#39;ls -l&#39;[root ~]# alias frm&#x3D;&#39;rm -rf&#39;[root ~]# ll...drwxr-xr-x  2 root       root   4096 Jun 20 12:52 abc...[root ~]# frm abc</code></pre></li><li><p><strong>unalias</strong></p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# unalias frm[root ~]# frm sohu.html-bash: frm: command not found</code></pre></li></ol><h4 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h4><ol><li><p>字符流编辑器 - <strong>sed</strong>。</p><p>sed是操作、过滤和转换文本内容的工具。假设有一个名为fruit.txt的文件，内容如下所示。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# cat -n fruit.txt      1  banana     2  grape     3  apple     4  watermelon     5  orange</code></pre><p>接下来，我们在第2行后面添加一个pitaya。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# sed &#39;2a pitaya&#39; fruit.txt bananagrapepitayaapplewatermelonorange</code></pre><blockquote><p>注意：刚才的命令和之前我们讲过的很多命令一样并没有改变fruit.txt文件，而是将添加了新行的内容输出到终端中，如果想保存到fruit.txt中，可以使用输出重定向操作。</p></blockquote><p>在第2行前面插入一个waxberry。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# sed &#39;2i waxberry&#39; fruit.txtbananawaxberrygrapeapplewatermelonorange</code></pre><p>删除第3行。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# sed &#39;3d&#39; fruit.txtbananagrapewatermelonorange</code></pre><p>删除第2行到第4行。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# sed &#39;2,4d&#39; fruit.txtbananaorange</code></pre><p>将文本中的字符a替换为@。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# sed &#39;s#a#@#&#39; fruit.txt b@nanagr@pe@pplew@termelonor@nge</code></pre><p>将文本中的字符a替换为@，使用全局模式。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# sed &#39;s#a#@#g&#39; fruit.txt b@n@n@gr@pe@pplew@termelonor@nge</code></pre></li><li><p>模式匹配和处理语言 - <strong>awk</strong>。</p><p>awk是一种编程语言，也是Linux系统中处理文本最为强大的工具，它的作者之一和现在的维护者就是之前提到过的Brian Kernighan（ken和dmr最亲密的伙伴）。通过该命令可以从文本中提取出指定的列、用正则表达式从文本中取出我们想要的内容、显示指定的行以及进行统计和运算，总之它非常强大。</p><p>假设有一个名为fruit2.txt的文件，内容如下所示。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# cat fruit2.txt 1       banana      1202       grape       5003       apple       12304       watermelon  805       orange      400</code></pre><p>显示文件的第3行。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# awk &#39;NR&#x3D;&#x3D;3&#39; fruit2.txt 3       apple       1230</code></pre><p>显示文件的第2列。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# awk &#39;&#123;print $2&#125;&#39; fruit2.txt bananagrapeapplewatermelonorange</code></pre><p>显示文件的最后一列。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# awk &#39;&#123;print $NF&#125;&#39; fruit2.txt 120500123080400</code></pre><p>输出末尾数字大于等于300的行。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# awk &#39;&#123;if($3 &gt;&#x3D; 300) &#123;print $0&#125;&#125;&#39; fruit2.txt 2       grape       5003       apple       12305       orange      400</code></pre><p>上面展示的只是awk命令的冰山一角，更多的内容留给读者自己在实践中去探索。</p></li></ol><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><ol><li><p>创建和删除用户 - <strong>useradd</strong> &#x2F; <strong>userdel</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root home]# useradd hellokitty[root home]# userdel hellokitty</code></pre><ul><li><code>-d</code> - 创建用户时为用户指定用户主目录</li><li><code>-g</code> - 创建用户时指定用户所属的用户组</li></ul></li><li><p>创建和删除用户组 - <strong>groupadd</strong> &#x2F; <strong>groupdel</strong>。</p><blockquote><p>说明：用户组主要是为了方便对一个组里面所有用户的管理。</p></blockquote></li><li><p>修改密码 - <strong>passwd</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# passwd hellokittyNew password: Retype new password: passwd: all authentication tokens updated successfully.</code></pre><blockquote><p>说明：输入密码和确认密码没有回显且必须一气呵成的输入完成（不能使用退格键），密码和确认密码需要一致。如果使用<code>passwd</code>命令时没有指定命令作用的对象，则表示要修改当前用户的密码。如果想批量修改用户密码，可以使用<code>chpasswd</code>命令。</p></blockquote><ul><li><code>-l</code> &#x2F; <code>-u</code> - 锁定&#x2F;解锁用户。</li><li><code>-d</code> - 清除用户密码。</li><li><code>-e</code> - 设置密码立即过期，用户登录时会强制要求修改密码。</li><li><code>-i</code> - 设置密码过期多少天以后禁用该用户。</li></ul></li><li><p>查看和修改密码有效期 - <strong>chage</strong>。</p><p>设置hellokitty用户100天后必须修改密码，过期前15天通知该用户，过期后7天禁用该用户。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">chage -M 100 -W 15 -I 7 hellokitty</code></pre></li><li><p>切换用户 - <strong>su</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# su hellokitty[hellokitty root]$</code></pre></li><li><p>以管理员身份执行命令 - <strong>sudo</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[hellokitty ~]$ ls &#x2F;rootls: cannot open directory &#x2F;root: Permission denied[hellokitty ~]$ sudo ls &#x2F;root[sudo] password for hellokitty:</code></pre><blockquote><p><strong>说明</strong>：如果希望用户能够以管理员身份执行命令，用户必须要出现在sudoers名单中，sudoers文件在 <code>/etc</code>目录下，如果希望直接编辑该文件也可以使用下面的命令。</p></blockquote></li><li><p>编辑sudoers文件 - <strong>visudo</strong>。</p><p>这里使用的编辑器是vi，关于vi的知识在后面有讲解。该文件的部分内容如下所示：</p><pre class="language-none"><code class="language-none">## Allow root to run any commands anywhere root    ALL&#x3D;(ALL)   ALL## Allows members of the &#39;sys&#39; group to run networking, software, ## service management apps and more.# %sys ALL &#x3D; NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS## Allows people in group wheel to run all commands%wheel  ALL&#x3D;(ALL)   ALL## Same thing without a password# %wheel    ALL&#x3D;(ALL)   NOPASSWD: ALL## Allows members of the users group to mount and unmount the## cdrom as root# %users  ALL&#x3D;&#x2F;sbin&#x2F;mount &#x2F;mnt&#x2F;cdrom, &#x2F;sbin&#x2F;umount &#x2F;mnt&#x2F;cdrom## Allows members of the users group to shutdown this system# %users  localhost&#x3D;&#x2F;sbin&#x2F;shutdown -h now</code></pre></li><li><p>显示用户与用户组的信息 - <strong>id</strong>。</p></li><li><p>给其他用户发消息 -<strong>write</strong> &#x2F; <strong>wall</strong>。</p><p>发送方：</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# write hellokittyDinner is on me.Call me at 6pm.</code></pre><p>接收方：</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[hellokitty ~]$ Message from root on pts&#x2F;0 at 17:41 ...Dinner is on me.Call me at 6pm.EOF</code></pre></li><li><p>查看&#x2F;设置是否接收其他用户发送的消息 - <strong>mesg</strong>。</p></li></ol>   <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[hellokitty ~]$ mesgis y[hellokitty ~]$ mesg n[hellokitty ~]$ mesgis n</code></pre><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件和路径"><a href="#文件和路径" class="headerlink" title="文件和路径"></a>文件和路径</h4><ol><li>命名规则：文件名的最大长度与文件系统类型有关，一般情况下，文件名不应该超过255个字符，虽然绝大多数的字符都可以用于文件名，但是最好使用英文大小写字母、数字、下划线、点这样的符号。文件名中虽然可以使用空格，但应该尽可能避免使用空格，否则在输入文件名时需要用将文件名放在双引号中或者通过<code>\</code>对空格进行转义。</li><li>扩展名：在Linux系统下文件的扩展名是可选的，但是使用扩展名有助于对文件内容的理解。有些应用程序要通过扩展名来识别文件，但是更多的应用程序并不依赖文件的扩展名，就像<code>file</code>命令在识别文件时并不是依据扩展名来判定文件的类型。</li><li>隐藏文件：以点开头的文件在Linux系统中是隐藏文件（不可见文件）。</li></ol><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><ol><li>&#x2F;bin - 基本命令的二进制文件。</li><li>&#x2F;boot - 引导加载程序的静态文件。</li><li>&#x2F;dev - 设备文件。</li><li><strong>&#x2F;etc</strong> - 配置文件。</li><li>&#x2F;home - 普通用户主目录的父目录。</li><li>&#x2F;lib - 共享库文件。</li><li>&#x2F;lib64 - 共享64位库文件。</li><li>&#x2F;lost+found - 存放未链接文件。</li><li>&#x2F;media - 自动识别设备的挂载目录。</li><li>&#x2F;mnt - 临时挂载文件系统的挂载点。</li><li>&#x2F;opt - 可选插件软件包安装位置。</li><li>&#x2F;proc -  内核和进程信息。</li><li><strong>&#x2F;root</strong> - 超级管理员用户主目录。</li><li>&#x2F;run - 存放系统运行时需要的东西。</li><li>&#x2F;sbin - 超级用户的二进制文件。</li><li>&#x2F;sys - 设备的伪文件系统。</li><li>&#x2F;tmp - 临时文件夹。</li><li><strong>&#x2F;usr</strong> - 用户应用目录。</li><li>&#x2F;var - 变量数据目录。</li></ol><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><ol><li><p><strong>chmod</strong> - 改变文件模式比特。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ls -l...-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html...[root ~]# chmod g+w,o+w sohu.html[root ~]# ls -l...-rw-rw-rw-  1 root       root 211878 Jun 19 16:06 sohu.html...[root ~]# chmod 644 sohu.html[root ~]# ls -l...-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html...</code></pre><blockquote><p>说明：通过上面的例子可以看出，用<code>chmod</code>改变文件模式比特有两种方式：一种是字符设定法，另一种是数字设定法。除了<code>chmod</code>之外，可以通过<code>umask</code>来设定哪些权限将在新文件的默认权限中被删除。</p></blockquote><p>长格式查看目录或文件时显示结果及其对应权限的数值如下表所示。</p><p><img src="/./res/file-mode.png"></p></li><li><p><strong>chown</strong> - 改变文件所有者。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ls -l...-rw-r--r--  1 root root     54 Jun 20 10:06 readme.txt...[root ~]# chown hellokitty readme.txt[root ~]# ls -l...-rw-r--r--  1 hellokitty root     54 Jun 20 10:06 readme.txt...</code></pre></li><li><p><strong>chgrp</strong> - 改变用户组。</p></li></ol><h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><ol><li><p>列出文件系统的磁盘使用状况 - <strong>df</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# df -hFilesystem      Size  Used Avail Use% Mounted on&#x2F;dev&#x2F;vda1        40G  5.0G   33G  14% &#x2F;devtmpfs        486M     0  486M   0% &#x2F;devtmpfs           497M     0  497M   0% &#x2F;dev&#x2F;shmtmpfs           497M  356K  496M   1% &#x2F;runtmpfs           497M     0  497M   0% &#x2F;sys&#x2F;fs&#x2F;cgrouptmpfs           100M     0  100M   0% &#x2F;run&#x2F;user&#x2F;0</code></pre></li><li><p>磁盘分区表操作 - <strong>fdisk</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# fdisk -lDisk &#x2F;dev&#x2F;vda: 42.9 GB, 42949672960 bytes, 83886080 sectorsUnits &#x3D; sectors of 1 * 512 &#x3D; 512 bytesSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytesI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytesDisk label type: dosDisk identifier: 0x000a42f4   Device Boot      Start         End      Blocks   Id  System&#x2F;dev&#x2F;vda1   *        2048    83884031    41940992   83  LinuxDisk &#x2F;dev&#x2F;vdb: 21.5 GB, 21474836480 bytes, 41943040 sectorsUnits &#x3D; sectors of 1 * 512 &#x3D; 512 bytesSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytesI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</code></pre></li><li><p>磁盘分区工具 - <strong>parted</strong>。</p></li><li><p>格式化文件系统 - <strong>mkfs</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# mkfs -t ext4 -v &#x2F;dev&#x2F;sdb</code></pre><ul><li><code>-t</code> - 指定文件系统的类型。</li><li><code>-c</code> - 创建文件系统时检查磁盘损坏情况。</li><li><code>-v</code> - 显示详细信息。</li></ul></li><li><p>文件系统检查 - <strong>fsck</strong>。</p></li><li><p>转换或拷贝文件 - <strong>dd</strong>。</p></li><li><p>挂载&#x2F;卸载 - <strong>mount</strong> &#x2F; <strong>umount</strong>。</p></li><li><p>创建&#x2F;激活&#x2F;关闭交换分区 - <strong>mkswap</strong> &#x2F; <strong>swapon</strong> &#x2F; <strong>swapoff</strong>。</p></li></ol><blockquote><p><strong>说明</strong>：执行上面这些命令会带有一定的风险，如果不清楚这些命令的用法，最好不用随意使用，在使用的过程中，最好对照参考资料进行操作，并在操作前确认是否要这么做。</p></blockquote><h3 id="编辑器-vim"><a href="#编辑器-vim" class="headerlink" title="编辑器 - vim"></a>编辑器 - vim</h3><ol><li><p>启动vim。可以通过<code>vi</code>或<code>vim</code>命令来启动vim，启动时可以指定文件名来打开一个文件，如果没有指定文件名，也可以在保存的时候指定文件名。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# vim guess.py</code></pre></li><li><p>命令模式、编辑模式和末行模式：启动vim进入的是命令模式（也称为Normal模式），在命令模式下输入英文字母<code>i</code>会进入编辑模式（Insert模式），屏幕下方出现<code>-- INSERT --</code>提示；在编辑模式下按下<code>Esc</code>会回到命令模式，此时如果输入英文<code>:</code>会进入末行模式，在末行模式下输入<code>q!</code>可以在不保存当前工作的情况下强行退出vim；在命令模式下输入<code>v</code>会进入可视模式（Visual模式），可以用光标选择一个区域再完成对应的操作。</p></li><li><p>保存和退出vim：在命令模式下输入<code>:</code> 进入末行模式，输入<code>wq</code>可以实现保存退出；如果想放弃编辑的内容输入<code>q!</code>强行退出，这一点刚才已经提到过了；在命令模式下也可以直接输入<code>ZZ</code>实现保存退出。如果只想保存文件不退出，那么可以在末行模式下输入<code>w</code>；可以在<code>w</code>后面输入空格再指定要保存的文件名。</p></li><li><p>光标操作。</p><ul><li>在命令模式下可以通过<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>来控制光标向左、下、上、右的方向移动，可以在字母前输入数字来表示移动的距离，例如：<code>10h</code>表示向左移动10个字符。</li><li>在命令模式下可以通过<code>Ctrl+y</code>和<code>Ctrl+e</code>来实现向上、向下滚动一行文本的操作，可以通过<code>Ctrl+f</code>和<code>Ctrl+b</code>来实现向前和向后翻页的操作。</li><li>在命令模式下可以通过输入英文字母<code>G</code>将光标移到文件的末尾，可以通过<code>gg</code>将光标移到文件的开始，也可以通过在<code>G</code>前输入数字来将光标移动到指定的行。</li></ul></li><li><p>文本操作。</p><ul><li>删除：在命令模式下可以用<code>dd</code>来删除整行；可以在<code>dd</code>前加数字来指定删除的行数；可以用<code>d$</code>来实现删除从光标处删到行尾的操作，也可以通过<code>d0</code>来实现从光标处删到行首的操作；如果想删除一个单词，可以使用<code>dw</code>；如果要删除全文，可以在输入<code>:%d</code>（其中<code>:</code>用来从命令模式进入末行模式）。</li><li>复制和粘贴：在命令模式下可以用<code>yy</code>来复制整行；可以在<code>yy</code>前加数字来指定复制的行数；可以通过<code>p</code>将复制的内容粘贴到光标所在的地方。</li><li>撤销和恢复：在命令模式下输入<code>u</code>可以撤销之前的操作；通过<code>Ctrl+r</code>可以恢复被撤销的操作。</li><li>对内容进行排序：在命令模式下输入<code>%!sort</code>。</li></ul></li><li><p>查找和替换。</p><ul><li>查找操作需要输入<code>/</code>进入末行模式并提供正则表达式来匹配与之对应的内容，例如：<code>/doc.*\.</code>，输入<code>n</code>来向前搜索，也可以输入<code>N</code>来向后搜索。</li><li>替换操作需要输入<code>:</code>进入末行模式并指定搜索的范围、正则表达式以及替换后的内容和匹配选项，例如：<code>:1,$s/doc.*/hello/gice</code>，其中：<ul><li><code>g</code> - global：全局匹配。</li><li><code>i</code> - ignore case：忽略大小写匹配。</li><li><code>c</code> - confirm：替换时需要确认。</li><li><code>e</code> - error：忽略错误。</li></ul></li></ul></li><li><p>参数设定：在输入<code>:</code>进入末行模式后可以对vim进行设定。</p><ul><li><p>设置Tab键的空格数：<code>set ts=4</code></p></li><li><p>设置显示&#x2F;不显示行号：<code>set nu</code> &#x2F; <code>set nonu</code></p></li><li><p>设置启用&#x2F;关闭高亮语法：<code>syntax on</code> &#x2F; <code>syntax off</code></p></li><li><p>设置显示标尺（光标所在的行和列）： <code>set ruler</code></p></li><li><p>设置启用&#x2F;关闭搜索结果高亮：<code>set hls</code> &#x2F; <code>set nohls</code></p><blockquote><p>说明：如果希望上面的这些设定在每次启动vim时都能自动生效，需要将这些设定写到用户主目录下的.vimrc文件中。</p></blockquote></li></ul></li><li><p>高级技巧</p><ul><li><p>比较多个文件。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# vim -d foo.txt bar.txt</code></pre><p><img src="/./res/vim-diff.png"></p></li><li><p>打开多个文件。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# vim foo.txt bar.txt hello.txt</code></pre><p>启动vim后只有一个窗口显示的是foo.txt，可以在末行模式中输入<code>ls</code>查看到打开的三个文件，也可以在末行模式中输入<code>b &lt;num&gt;</code>来显示另一个文件，例如可以用<code>:b 2</code>将bar.txt显示出来，可以用<code>:b 3</code>将hello.txt显示出来。</p></li><li><p>拆分和切换窗口。</p><p>可以在末行模式中输入<code>sp</code>或<code>vs</code>来实现对窗口的水平或垂直拆分，这样我们就可以同时打开多个编辑窗口，通过按两次<code>Ctrl+w</code>就可以实现编辑窗口的切换，在一个窗口中执行退出操作只会关闭对应的窗口，其他的窗口继续保留。</p><p><img src="/./res/vim-multi-window.png"></p></li><li><p>映射快捷键：在vim下可以将一些常用操作映射为快捷键来提升工作效率。</p><ul><li><p>例子1：在命令模式下输入<code>F4</code>执行从第一行开始删除10000行代码的操作。</p><p><code>:map &lt;F4&gt; gg10000dd</code>。</p><p>例子2：在编辑模式下输入<code>__main</code>直接补全为<code>if __name__ == &#39;__main__&#39;:</code>。</p><p><code>:inoremap __main if __name__ == &#39;__main__&#39;:</code></p></li></ul><blockquote><p>说明：上面例子2的<code>inoremap</code>中的<code>i</code>表示映射的键在编辑模式使用， <code>nore</code>表示不要递归，这一点非常重要，否则如果键对应的内容中又出现键本身，就会引发递归（相当于进入了死循环）。如果希望映射的快捷键每次启动vim时都能生效，需要将映射写到用户主目录下的.vimrc文件中。</p></blockquote></li><li><p>录制宏。</p><ul><li><p>在命令模式下输入<code>qa</code>开始录制宏（其中<code>a</code>是寄存器的名字，也可以是其他英文字母或0-9的数字）。</p></li><li><p>执行你的操作（光标操作、编辑操作等），这些操作都会被录制下来。</p></li><li><p>如果录制的操作已经完成了，按<code>q</code>结束录制。</p></li><li><p>通过<code>@a</code>（<code>a</code>是刚才使用的寄存器的名字）播放宏，如果要多次执行宏可以在前面加数字，例如<code>100@a</code>表示将宏播放100次。</p></li><li><p>可以试一试下面的例子来体验录制宏的操作，该例子来源于<a href="https://harttle.land/tags.html#Vim">Harttle Land网站</a>，该网站上提供了很多关于vim的使用技巧，有兴趣的可以了解一下。</p><p><img src="/./res/vim-macro.png"></p></li></ul></li></ul></li></ol><h3 id="软件安装和配置"><a href="#软件安装和配置" class="headerlink" title="软件安装和配置"></a>软件安装和配置</h3><h4 id="使用包管理工具"><a href="#使用包管理工具" class="headerlink" title="使用包管理工具"></a>使用包管理工具</h4><ol><li><strong>yum</strong> - Yellowdog Updater Modified。<ul><li><code>yum search</code>：搜索软件包，例如<code>yum search nginx</code>。</li><li><code>yum list installed</code>：列出已经安装的软件包，例如<code>yum list installed | grep zlib</code>。</li><li><code>yum install</code>：安装软件包，例如<code>yum install nginx</code>。</li><li><code>yum remove</code>：删除软件包，例如<code>yum remove nginx</code>。</li><li><code>yum update</code>：更新软件包，例如<code>yum update</code>可以更新所有软件包，而<code>yum update tar</code>只会更新tar。</li><li><code>yum check-update</code>：检查有哪些可以更新的软件包。</li><li><code>yum info</code>：显示软件包的相关信息，例如<code>yum info nginx</code>。</li></ul></li><li><strong>rpm</strong> - Redhat Package Manager。<ul><li>安装软件包：<code>rpm -ivh &lt;packagename&gt;.rpm</code>。</li><li>移除软件包：<code>rpm -e &lt;packagename&gt;</code>。</li><li>查询软件包：<code>rpm -qa</code>，例如可以用<code>rpm -qa | grep mysql</code>来检查是否安装了MySQL相关的软件包。</li></ul></li></ol><p>下面以Nginx为例，演示如何使用yum安装软件。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# yum -y install nginx...Installed:  nginx.x86_64 1:1.12.2-2.el7Dependency Installed:  nginx-all-modules.noarch 1:1.12.2-2.el7  nginx-mod-http-geoip.x86_64 1:1.12.2-2.el7  nginx-mod-http-image-filter.x86_64 1:1.12.2-2.el7  nginx-mod-http-perl.x86_64 1:1.12.2-2.el7  nginx-mod-http-xslt-filter.x86_64 1:1.12.2-2.el7  nginx-mod-mail.x86_64 1:1.12.2-2.el7  nginx-mod-stream.x86_64 1:1.12.2-2.el7Complete![root ~]# yum info nginxLoaded plugins: fastestmirrorLoading mirror speeds from cached hostfileInstalled PackagesName        : nginxArch        : x86_64Epoch       : 1Version     : 1.12.2Release     : 2.el7Size        : 1.5 MRepo        : installedFrom repo   : epelSummary     : A high performance web server and reverse proxy serverURL         : http:&#x2F;&#x2F;nginx.org&#x2F;License     : BSDDescription : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and            : IMAP protocols, with a strong focus on high concurrency, performance and low            : memory usage.[root ~]# nginx -vnginx version: nginx&#x2F;1.12.2</code></pre><p>移除Nginx。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# yum -y remove nginx</code></pre><p>下面以MySQL为例，演示如何使用rpm安装软件。要安装MySQL需要先到<a href="https://www.mysql.com/">MySQL官方网站</a>下载对应的<a href="https://dev.mysql.com/downloads/mysql/">RPM文件</a>，当然要选择和你使用的Linux系统对应的版本。MySQL现在是Oracle公司旗下的产品，在MySQL被收购后，MySQL的作者重新制作了一个MySQL的分支MariaDB，可以通过yum进行安装。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root mysql]# lsmysql-community-client-5.7.22-1.el7.x86_64.rpmmysql-community-common-5.7.22-1.el7.x86_64.rpmmysql-community-libs-5.7.22-1.el7.x86_64.rpmmysql-community-server-5.7.22-1.el7.x86_64.rpm[root mysql]# yum -y remove mariadb-libs[root mysql]# yum -y install libaio[root mysql]#rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm...[root mysql]#rpm -ivh mysql-community-libs-5.7.26-1.el7.x86_64.rpm...[root mysql]#rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm...[root mysql]#rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm...</code></pre><blockquote><p>说明：由于MySQL和<a href="https://mariadb.org/">MariaDB</a>的底层依赖库是有冲突的，所以上面我们首先用<code>yum</code>移除了名为mariadb-libs的依赖库并安装了名为libaio支持异步I&#x2F;O操作的依赖库。关于MySQL和MariaDB之间的关系，可以阅读<a href="https://zh.wikipedia.org/wiki/MariaDB">维基百科</a>上关于MariaDB的介绍。</p></blockquote><p>移除安装的MySQL。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# rpm -qa | grep mysql | xargs rpm -e</code></pre><h4 id="下载解压配置环境变量"><a href="#下载解压配置环境变量" class="headerlink" title="下载解压配置环境变量"></a>下载解压配置环境变量</h4><p>下面以安装MongoDB为例，演示这类软件应该如何安装。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# wget https:&#x2F;&#x2F;fastdl.mongodb.org&#x2F;linux&#x2F;mongodb-linux-x86_64-rhel70-3.6.5.tgz--2018-06-21 18:32:53--  https:&#x2F;&#x2F;fastdl.mongodb.org&#x2F;linux&#x2F;mongodb-linux-x86_64-rhel70-3.6.5.tgzResolving fastdl.mongodb.org (fastdl.mongodb.org)... 52.85.83.16, 52.85.83.228, 52.85.83.186, ...Connecting to fastdl.mongodb.org (fastdl.mongodb.org)|52.85.83.16|:443... connected.HTTP request sent, awaiting response... 200 OKLength: 100564462 (96M) [application&#x2F;x-gzip]Saving to: ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;] 100,564,462  630KB&#x2F;s   in 2m 9s2018-06-21 18:35:04 (760 KB&#x2F;s) - ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’ saved [100564462&#x2F;100564462][root ~]# gunzip mongodb-linux-x86_64-rhel70-3.6.5.tgz[root ~]# tar -xvf mongodb-linux-x86_64-rhel70-3.6.5.tarmongodb-linux-x86_64-rhel70-3.6.5&#x2F;READMEmongodb-linux-x86_64-rhel70-3.6.5&#x2F;THIRD-PARTY-NOTICESmongodb-linux-x86_64-rhel70-3.6.5&#x2F;MPL-2mongodb-linux-x86_64-rhel70-3.6.5&#x2F;GNU-AGPL-3.0mongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongodumpmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongorestoremongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongoexportmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongoimportmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongostatmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongotopmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;bsondumpmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongofilesmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongoreplaymongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongoperfmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongodmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongosmongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;mongomongodb-linux-x86_64-rhel70-3.6.5&#x2F;bin&#x2F;install_compass[root ~]# vim .bash_profile...PATH&#x3D;$PATH:$HOME&#x2F;bin:$HOME&#x2F;mongodb-linux-x86_64-rhel70-3.6.5&#x2F;binexport PATH...[root ~]# source .bash_profile[root ~]# mongod --versiondb version v3.6.5git version: a20ecd3e3a174162052ff99913bc2ca9a839d618OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013allocator: tcmallocmodules: nonebuild environment:    distmod: rhel70    distarch: x86_64    target_arch: x86_64[root ~]# mongo --versionMongoDB shell version v3.6.5git version: a20ecd3e3a174162052ff99913bc2ca9a839d618OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013allocator: tcmallocmodules: nonebuild environment:    distmod: rhel70    distarch: x86_64    target_arch: x86_64</code></pre><blockquote><p>说明：当然也可以通过yum来安装MongoDB，具体可以参照<a href="https://docs.mongodb.com/master/administration/install-on-linux/">官方网站</a>上给出的说明。</p></blockquote><h4 id="源代码构建安装"><a href="#源代码构建安装" class="headerlink" title="源代码构建安装"></a>源代码构建安装</h4><ol><li><p>安装Python 3.6。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# yum install gcc[root ~]# wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.6.5&#x2F;Python-3.6.5.tgz[root ~]# gunzip Python-3.6.5.tgz[root ~]# tar -xvf Python-3.6.5.tar[root ~]# cd Python-3.6.5[root ~]# .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python36 --enable-optimizations[root ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel[root ~]# make &amp;&amp; make install...[root ~]# ln -s &#x2F;usr&#x2F;local&#x2F;python36&#x2F;bin&#x2F;python3.6 &#x2F;usr&#x2F;bin&#x2F;python3[root ~]# python3 --versionPython 3.6.5[root ~]# python3 -m pip install -U pip[root ~]# pip3 --version</code></pre><blockquote><p>说明：上面在安装好Python之后还需要注册PATH环境变量，将Python安装路径下bin文件夹的绝对路径注册到PATH环境变量中。注册环境变量可以修改用户主目录下的.bash_profile或者&#x2F;etc目录下的profile文件，二者的区别在于前者相当于是用户环境变量，而后者相当于是系统环境变量。</p></blockquote></li><li><p>安装Redis-3.2.12。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.12.tar.gz[root ~]# gunzip redis-3.2.12.tar.gz[root ~]# tar -xvf redis-3.2.12.tar[root ~]# cd redis-3.2.12[root ~]# make &amp;&amp; make install[root ~]# redis-server --versionRedis server v&#x3D;3.2.12 sha&#x3D;00000000:0 malloc&#x3D;jemalloc-4.0.3 bits&#x3D;64 build&#x3D;5bc5cd3c03d6ceb6[root ~]# redis-cli --versionredis-cli 3.2.12</code></pre></li></ol><h3 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h3><p>我们可以Linux系统下安装和配置各种服务，也就是说我们可以把Linux系统打造成数据库服务器、Web服务器、缓存服务器、文件服务器、消息队列服务器等等。Linux下的大多数服务都被设置为守护进程（驻留在系统后台运行，但不会因为服务还在运行而导致Linux无法停止运行），所以我们安装的服务通常名字后面都有一个字母<code>d</code>，它是英文单词<code>daemon</code>的缩写，例如：防火墙服务叫firewalld，我们之前安装的MySQL服务叫mysqld，Apache服务器叫httpd等。在安装好服务之后，可以使用<code>systemctl</code>命令或<code>service</code>命令来完成对服务的启动、停止等操作，具体操作如下所示。</p><ol><li><p>启动防火墙服务。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# systemctl start firewalld</code></pre></li><li><p>终止防火墙服务。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# systemctl stop firewalld</code></pre></li><li><p>重启防火墙服务。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# systemctl restart firewalld</code></pre></li><li><p>查看防火墙服务状态。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# systemctl status firewalld</code></pre></li><li><p>设置&#x2F;禁用防火墙服务开机自启。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# systemctl enable firewalldCreated symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;dbus-org.fedoraproject.FirewallD1.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service.Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;firewalld.service to &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service.[root ~]# systemctl disable firewalldRemoved symlink &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;firewalld.service.Removed symlink &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;dbus-org.fedoraproject.FirewallD1.service.</code></pre></li></ol><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><ol><li><p>在指定的时间执行命令。</p><ul><li><strong>at</strong> - 将任务排队，在指定的时间执行。</li><li><strong>atq</strong> - 查看待执行的任务队列。</li><li><strong>atrm</strong> - 从队列中删除待执行的任务。</li></ul><p>指定3天以后下午5点要执行的任务。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# at 5pm+3daysat&gt; rm -f &#x2F;root&#x2F;*.htmlat&gt; &lt;EOT&gt;job 9 at Wed Jun  5 17:00:00 2019</code></pre><p>查看待执行的任务队列。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# atq9       Wed Jun  5 17:00:00 2019 a root</code></pre><p>从队列中删除指定的任务。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]$ atrm 9</code></pre></li><li><p>计划任务表 - <strong>crontab</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# crontab -e* * * * * echo &quot;hello, world!&quot; &gt;&gt; &#x2F;root&#x2F;hello.txt59 23 * * * rm -f &#x2F;root&#x2F;*.log</code></pre><blockquote><p>说明：输入<code>crontab -e</code>命令会打开vim来编辑Cron表达式并指定触发的任务，上面我们定制了两个计划任务，一个是每分钟向&#x2F;root目录下的hello.txt中追加输出<code>hello, world!</code>；另一个是每天23时59分执行删除&#x2F;root目录下以log为后缀名的文件。如果不知道Cron表达式如何书写，可以参照&#x2F;etc&#x2F;crontab文件中的提示（下面会讲到）或者用搜索引擎找一下“Cron表达式在线生成器”来生成Cron表达式。</p></blockquote><p>和crontab相关的文件在<code>/etc</code>目录下，通过修改<code>/etc</code>目录下的crontab文件也能够定制计划任务。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# cd &#x2F;etc[root etc]# ls -l | grep cron-rw-------.  1 root root      541 Aug  3  2017 anacrontabdrwxr-xr-x.  2 root root     4096 Mar 27 11:56 cron.ddrwxr-xr-x.  2 root root     4096 Mar 27 11:51 cron.daily-rw-------.  1 root root        0 Aug  3  2017 cron.denydrwxr-xr-x.  2 root root     4096 Mar 27 11:50 cron.hourlydrwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.monthly-rw-r--r--   1 root root      493 Jun 23 15:09 crontabdrwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.weekly[root etc]# vim crontab  1 SHELL&#x3D;&#x2F;bin&#x2F;bash  2 PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin  3 MAILTO&#x3D;root  4  5 # For details see man 4 crontabs  6  7 # Example of job definition:  8 # .---------------- minute (0 - 59)  9 # |  .------------- hour (0 - 23) 10 # |  |  .---------- day of month (1 - 31) 11 # |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ... 12 # |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat 13 # |  |  |  |  | 14 # *  *  *  *  * user-name  command to be executed</code></pre></li></ol><h3 id="网络访问和管理"><a href="#网络访问和管理" class="headerlink" title="网络访问和管理"></a>网络访问和管理</h3><ol><li><p>安全远程连接 - <strong>ssh</strong>。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]$ ssh root@120.77.222.217The authenticity of host &#39;120.77.222.217 (120.77.222.217)&#39; can&#39;t be established.ECDSA key fingerprint is SHA256:BhUhykv+FvnIL03I9cLRpWpaCxI91m9n7zBWrcXRa8w.ECDSA key fingerprint is MD5:cc:85:e9:f0:d7:07:1a:26:41:92:77:6b:7f:a0:92:65.Are you sure you want to continue connecting (yes&#x2F;no)? yesWarning: Permanently added &#39;120.77.222.217&#39; (ECDSA) to the list of known hosts.root@120.77.222.217&#39;s password: </code></pre></li><li><p>通过网络获取资源 - <strong>wget</strong>。</p><ul><li>-b 后台下载模式</li><li>-O 下载到指定的目录</li><li>-r 递归下载</li></ul></li><li><p>发送和接收邮件 - <strong>mail</strong>。</p></li><li><p>网络配置工具（旧） - <strong>ifconfig</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ifconfig eth0eth0: flags&#x3D;4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.18.61.250  netmask 255.255.240.0  broadcast 172.18.63.255        ether 00:16:3e:02:b6:46  txqueuelen 1000  (Ethernet)        RX packets 1067841  bytes 1296732947 (1.2 GiB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 409912  bytes 43569163 (41.5 MiB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions </code></pre></li><li><p>网络配置工具（新） - <strong>ip</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ip address1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1&#x2F;8 scope host lo       valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link&#x2F;ether 00:16:3e:02:b6:46 brd ff:ff:ff:ff:ff:ff    inet 172.18.61.250&#x2F;20 brd 172.18.63.255 scope global eth0       valid_lft forever preferred_lft forever</code></pre></li><li><p>网络可达性检查 - <strong>ping</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ping www.baidu.com -c 3PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data.64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq&#x3D;1 ttl&#x3D;51 time&#x3D;36.3 ms64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq&#x3D;2 ttl&#x3D;51 time&#x3D;36.4 ms64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq&#x3D;3 ttl&#x3D;51 time&#x3D;36.4 ms--- www.a.shifen.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2002msrtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 36.392&#x2F;36.406&#x2F;36.427&#x2F;0.156 ms</code></pre></li><li><p>显示或管理路由表 - <strong>route</strong>。</p></li><li><p>查看网络服务和端口 - <strong>netstat</strong> &#x2F; <strong>ss</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# netstat -nap | grep nginx</code></pre></li><li><p>网络监听抓包 - <strong>tcpdump</strong>。</p></li><li><p>安全文件拷贝 - <strong>scp</strong>。</p></li></ol>  <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# scp root@1.2.3.4:&#x2F;root&#x2F;guido.jpg hellokitty@4.3.2.1:&#x2F;home&#x2F;hellokitty&#x2F;pic.jpg</code></pre><ol start="11"><li><p>文件同步工具 - <strong>rsync</strong>。</p><blockquote><p>说明：使用<code>rsync</code>可以实现文件的自动同步，这个对于文件服务器来说相当重要。关于这个命令的用法，我们在后面讲项目部署的时候为大家详细说明。</p></blockquote></li><li><p>安全文件传输 - <strong>sftp</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# sftp root@1.2.3.4root@1.2.3.4&#39;s password:Connected to 1.2.3.4.sftp&gt;</code></pre><ul><li><p><code>help</code>：显示帮助信息。</p></li><li><p><code>ls</code>&#x2F;<code>lls</code>：显示远端&#x2F;本地目录列表。</p></li><li><p><code>cd</code>&#x2F;<code>lcd</code>：切换远端&#x2F;本地路径。</p></li><li><p><code>mkdir</code>&#x2F;<code>lmkdir</code>：创建远端&#x2F;本地目录。</p></li><li><p><code>pwd</code>&#x2F;<code>lpwd</code>：显示远端&#x2F;本地当前工作目录。</p></li><li><p><code>get</code>：下载文件。</p></li><li><p><code>put</code>：上传文件。</p></li><li><p><code>rm</code>：删除远端文件。</p></li><li><p><code>bye</code>&#x2F;<code>exit</code>&#x2F;<code>quit</code>：退出sftp。</p></li></ul></li></ol><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li><p>查看进程 - <strong>ps</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ps -efUID        PID  PPID  C STIME TTY          TIME CMDroot         1     0  0 Jun23 ?        00:00:05 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd --switched-root --system --deserialize 21root         2     0  0 Jun23 ?        00:00:00 [kthreadd]...[root ~]# ps -ef | grep mysqldroot      4943  4581  0 22:45 pts&#x2F;0    00:00:00 grep --color&#x3D;auto mysqldmysql    25257     1  0 Jun25 ?        00:00:39 &#x2F;usr&#x2F;sbin&#x2F;mysqld --daemonize --pid-file&#x3D;&#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid</code></pre></li><li><p>显示进程状态树 - <strong>pstree</strong>。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# pstreesystemd─┬─AliYunDun───18*[&#123;AliYunDun&#125;]        ├─AliYunDunUpdate───3*[&#123;AliYunDunUpdate&#125;]        ├─2*[agetty]        ├─aliyun-service───2*[&#123;aliyun-service&#125;]        ├─atd        ├─auditd───&#123;auditd&#125;        ├─dbus-daemon        ├─dhclient        ├─irqbalance        ├─lvmetad        ├─mysqld───28*[&#123;mysqld&#125;]        ├─nginx───2*[nginx]        ├─ntpd        ├─polkitd───6*[&#123;polkitd&#125;]        ├─rsyslogd───2*[&#123;rsyslogd&#125;]        ├─sshd───sshd───bash───pstree        ├─systemd-journal        ├─systemd-logind        ├─systemd-udevd        └─tuned───4*[&#123;tuned&#125;]</code></pre></li><li><p>查找与指定条件匹配的进程 - <strong>pgrep</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]$ pgrep mysqld3584</code></pre></li><li><p>通过进程号终止进程 - <strong>kill</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]$ kill -l 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR111) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+338) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+843) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-758) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-263) SIGRTMAX-1  64) SIGRTMAX[root ~]# kill 1234[root ~]# kill -9 1234</code></pre></li><li><p>通过进程名终止进程 - <strong>killall</strong> &#x2F; <strong>pkill</strong>。</p><p> 结束名为mysqld的进程。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# pkill mysqld</code></pre><p> 结束hellokitty用户的所有进程。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# pkill -u hellokitty</code></pre><blockquote><p>说明：这样的操作会让hellokitty用户和服务器断开连接。</p></blockquote></li><li><p>将进程置于后台运行。</p><ul><li><code>Ctrl+Z</code> - 快捷键，用于停止进程并置于后台。</li><li><code>&amp;</code> - 将进程置于后台运行。</li></ul><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# mongod &amp;[root ~]# redis-server...^Z[4]+  Stopped                 redis-server</code></pre></li><li><p>查询后台进程 - <strong>jobs</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# jobs[2]   Running                 mongod &amp;[3]-  Stopped                 cat[4]+  Stopped                 redis-server</code></pre></li><li><p>让进程在后台继续运行 - <strong>bg</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# bg %4[4]+ redis-server &amp;[root ~]# jobs[2]   Running                 mongod &amp;[3]+  Stopped                 cat[4]-  Running                 redis-server &amp;</code></pre></li><li><p>将后台进程置于前台 - <strong>fg</strong>。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# fg %4redis-server</code></pre><blockquote><p>说明：置于前台的进程可以使用<code>Ctrl+C</code>来终止它。</p></blockquote></li><li><p>调整程序&#x2F;进程运行时优先级 - <strong>nice</strong> &#x2F; <strong>renice</strong>。</p></li><li><p>用户登出后进程继续工作 - <strong>nohup</strong>。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# nohup ping www.baidu.com &gt; result.txt &amp;</code></pre></li><li><p>跟踪进程系统调用情况 - <strong>strace</strong>。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# pgrep mysqld8803[root ~]# strace -c -p 8803strace: Process 8803 attached^Cstrace: Process 8803 detached% time     seconds  usecs&#x2F;call     calls    errors syscall------ ----------- ----------- --------- --------- ---------------- 99.18    0.005719        5719         1           restart_syscall  0.49    0.000028          28         1           mprotect  0.24    0.000014          14         1           clone  0.05    0.000003           3         1           mmap  0.03    0.000002           2         1           accept------ ----------- ----------- --------- --------- ----------------100.00    0.005766                     5           total</code></pre><blockquote><p>说明：这个命令的用法和参数都比较复杂，建议大家在真正用到这个命令的时候再根据实际需要进行了解。</p></blockquote></li><li><p>查看当前运行级别 - <strong>runlevel</strong>。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# runlevelN 3</code></pre></li><li><p>实时监控进程占用资源状况 - <strong>top</strong>。</p> <pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# toptop - 23:04:23 up 3 days, 14:10,  1 user,  load average: 0.00, 0.01, 0.05Tasks:  65 total,   1 running,  64 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem :  1016168 total,   191060 free,   324700 used,   500408 buff&#x2F;cacheKiB Swap:        0 total,        0 free,        0 used.   530944 avail Mem...</code></pre><ul><li><code>-c</code> - 显示进程的整个路径。</li><li><code>-d</code> - 指定两次刷屏之间的间隔时间（秒为单位）。</li><li><code>-i</code> - 不显示闲置进程或僵尸进程。</li><li><code>-p</code> - 显示指定进程的信息。</li></ul></li></ol><h3 id="系统诊断"><a href="#系统诊断" class="headerlink" title="系统诊断"></a>系统诊断</h3><ol><li><p>系统启动异常诊断 - <strong>dmesg</strong>。</p></li><li><p>查看系统活动信息 - <strong>sar</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# sar -u -r 5 10Linux 3.10.0-957.10.1.el7.x86_64 (izwz97tbgo9lkabnat2lo8z)      06&#x2F;02&#x2F;2019      _x86_64_        (2 CPU)06:48:30 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle06:48:35 PM     all      0.10      0.00      0.10      0.00      0.00     99.8006:48:30 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty06:48:35 PM   1772012   2108392     54.33    102816   1634528    784940     20.23    793328   1164704         0</code></pre><ul><li><code>-A</code> - 显示所有设备（CPU、内存、磁盘）的运行状况。</li><li><code>-u</code> - 显示所有CPU的负载情况。</li><li><code>-d</code> - 显示所有磁盘的使用情况。</li><li><code>-r</code> - 显示内存的使用情况。</li><li><code>-n</code> - 显示网络运行状态。</li></ul></li><li><p>查看内存使用情况 - <strong>free</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# free              total        used        free      shared  buff&#x2F;cache   availableMem:        1016168      323924      190452         356      501792      531800Swap:             0           0           0</code></pre></li><li><p>虚拟内存统计 - <strong>vmstat</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st 2  0      0 204020  79036 667532    0    0     5    18  101   58  1  0 99  0  0</code></pre></li><li><p>CPU信息统计 - <strong>mpstat</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# mpstatLinux 3.10.0-957.5.1.el7.x86_64 (iZ8vba0s66jjlfmo601w4xZ)       05&#x2F;30&#x2F;2019      _x86_64_        (1 CPU)01:51:54 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle01:51:54 AM  all    0.71    0.00    0.17    0.04    0.00    0.00    0.00    0.00    0.00   99.07</code></pre></li><li><p>查看进程使用内存状况 - <strong>pmap</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ps  PID TTY          TIME CMD 4581 pts&#x2F;0    00:00:00 bash 5664 pts&#x2F;0    00:00:00 ps[root ~]# pmap 45814581:   -bash0000000000400000    884K r-x-- bash00000000006dc000      4K r---- bash00000000006dd000     36K rw--- bash00000000006e6000     24K rw---   [ anon ]0000000001de0000    400K rw---   [ anon ]00007f82fe805000     48K r-x-- libnss_files-2.17.so00007f82fe811000   2044K ----- libnss_files-2.17.so...</code></pre></li><li><p>报告设备CPU和I&#x2F;O统计信息 - <strong>iostat</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# iostatLinux 3.10.0-693.11.1.el7.x86_64 (iZwz97tbgo9lkabnat2lo8Z)      06&#x2F;26&#x2F;2018      _x86_64_       (1 CPU)avg-cpu:  %user   %nice %system %iowait  %steal   %idle           0.79    0.00    0.20    0.04    0.00   98.97Device:            tps    kB_read&#x2F;s    kB_wrtn&#x2F;s    kB_read    kB_wrtnvda               0.85         6.78        21.32    2106565    6623024vdb               0.00         0.01         0.00       2088          0</code></pre></li><li><p>显示所有PCI设备 - <strong>lspci</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# lspci00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma&#x2F;Triton II]00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma&#x2F;Triton II]00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma&#x2F;Triton II] (rev 01)00:01.3 Bridge: Intel Corporation 82371AB&#x2F;EB&#x2F;MB PIIX4 ACPI (rev 03)00:02.0 VGA compatible controller: Cirrus Logic GD 544600:03.0 Ethernet controller: Red Hat, Inc. Virtio network device00:04.0 Communication controller: Red Hat, Inc. Virtio console00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device00:06.0 SCSI storage controller: Red Hat, Inc. Virtio block device00:07.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon</code></pre></li><li><p>显示进程间通信设施的状态 - <strong>ipcs</strong>。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">[root ~]# ipcs------ Message Queues --------key        msqid      owner      perms      used-bytes   messages    ------ Shared Memory Segments --------key        shmid      owner      perms      bytes      nattch     status      ------ Semaphore Arrays --------key        semid      owner      perms      nsems</code></pre></li></ol><h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><p>之前我们提到过，Shell是一个连接用户和操作系统的应用程序，它提供了人机交互的界面（接口），用户通过这个界面访问操作系统内核的服务。Shell脚本是一种为Shell编写的脚本程序，我们可以通过Shell脚本来进行系统管理，同时也可以通过它进行文件操作。总之，编写Shell脚本对于使用Linux系统的人来说，应该是一项标配技能。</p><p>互联网上有大量关于Shell脚本的相关知识，我不打算再此对Shell脚本做一个全面系统的讲解，我们通过下面的代码来感性的认识下Shell脚本就行了。</p><p>例子1：输入两个整数m和n，计算从m到n的整数求和的结果。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">#!&#x2F;usr&#x2F;bin&#x2F;bashprintf &#39;m &#x3D; &#39;read mprintf &#39;n &#x3D; &#39;read na&#x3D;$msum&#x3D;0while [ $a -le $n ]do    sum&#x3D;$[ sum + a ]    a&#x3D;$[ a + 1 ]doneecho &#39;结果: &#39;$sum</code></pre><p>例子2：自动创建文件夹和指定数量的文件。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">#!&#x2F;usr&#x2F;bin&#x2F;bashprintf &#39;输入文件夹名: &#39;read dirprintf &#39;输入文件名: &#39;read fileprintf &#39;输入文件数量(&lt;1000): &#39;read numif [ $num -ge 1000 ]then    echo &#39;文件数量不能超过1000&#39;else    if [ -e $dir -a -d $dir ]    then        rm -rf $dir    else        if [ -e $dir -a -f $dir ]        then            rm -f $dir        fi    fi    mkdir -p $dir    index&#x3D;1    while [ $index -le $num ]    do        if [ $index -lt 10 ]        then            pre&#x3D;&#39;00&#39;        elif [ $index -lt 100 ]        then            pre&#x3D;&#39;0&#39;        else            pre&#x3D;&#39;&#39;        fi        touch $dir&#39;&#x2F;&#39;$file&#39;_&#39;$pre$index        index&#x3D;$[ index + 1 ]    donefi</code></pre><p>例子3：自动安装指定版本的Redis。</p><pre class="language-Shell" data-language="Shell"><code class="language-Shell">#!&#x2F;usr&#x2F;bin&#x2F;bashinstall_redis() &#123;    if ! which redis-server &gt; &#x2F;dev&#x2F;null    then        cd &#x2F;root        wget $1$2&#39;.tar.gz&#39; &gt;&gt; install.log        gunzip &#x2F;root&#x2F;$2&#39;.tar.gz&#39;        tar -xf &#x2F;root&#x2F;$2&#39;.tar&#39;        cd &#x2F;root&#x2F;$2        make &gt;&gt; install.log        make install &gt;&gt; install.log        echo &#39;安装完成&#39;    else        echo &#39;已经安装过Redis&#39;    fi&#125;install_redis &#39;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;&#39; $1</code></pre><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ol><li><p>Linux命令行常用快捷键</p><table><thead><tr><th>快捷键</th><th>功能说明</th></tr></thead><tbody><tr><td>tab</td><td>自动补全命令或路径</td></tr><tr><td>Ctrl+a</td><td>将光标移动到命令行行首</td></tr><tr><td>Ctrl+e</td><td>将光标移动到命令行行尾</td></tr><tr><td>Ctrl+f</td><td>将光标向右移动一个字符</td></tr><tr><td>Ctrl+b</td><td>将光标向左移动一个字符</td></tr><tr><td>Ctrl+k</td><td>剪切从光标到行尾的字符</td></tr><tr><td>Ctrl+u</td><td>剪切从光标到行首的字符</td></tr><tr><td>Ctrl+w</td><td>剪切光标前面的一个单词</td></tr><tr><td>Ctrl+y</td><td>复制剪切命名剪切的内容</td></tr><tr><td>Ctrl+c</td><td>中断正在执行的任务</td></tr><tr><td>Ctrl+h</td><td>删除光标前面的一个字符</td></tr><tr><td>Ctrl+d</td><td>退出当前命令行</td></tr><tr><td>Ctrl+r</td><td>搜索历史命令</td></tr><tr><td>Ctrl+g</td><td>退出历史命令搜索</td></tr><tr><td>Ctrl+l</td><td>清除屏幕上所有内容在屏幕的最上方开启一个新行</td></tr><tr><td>Ctrl+s</td><td>锁定终端使之暂时无法输入内容</td></tr><tr><td>Ctrl+q</td><td>退出终端锁定</td></tr><tr><td>Ctrl+z</td><td>将正在终端执行的任务停下来放到后台</td></tr><tr><td>!!</td><td>执行上一条命令</td></tr><tr><td>!数字</td><td>执行数字对应的历史命令</td></tr><tr><td>!字母</td><td>执行最近的以字母打头的命令</td></tr><tr><td>!$ &#x2F; Esc+.</td><td>获得上一条命令最后一个参数</td></tr><tr><td>Esc+b</td><td>移动到当前单词的开头</td></tr><tr><td>Esc+f</td><td>移动到当前单词的结尾</td></tr></tbody></table></li><li><p>man查阅命令手册的内容说明</p><table><thead><tr><th>手册中的标题</th><th>功能说明</th></tr></thead><tbody><tr><td>NAME</td><td>命令的说明和介绍</td></tr><tr><td>SYNOPSIS</td><td>使用该命令的基本语法</td></tr><tr><td>DESCRIPTION</td><td>使用该命令的详细描述，各个参数的作用，有时候这些信息会出现在OPTIONS中</td></tr><tr><td>OPTIONS</td><td>命令相关参数选项的说明</td></tr><tr><td>EXAMPLES</td><td>使用该命令的参考例子</td></tr><tr><td>EXIT STATUS</td><td>命令结束的退出状态码，通常0表示成功执行</td></tr><tr><td>SEE ALSO</td><td>和命令相关的其他命令或信息</td></tr><tr><td>BUGS</td><td>和命令相关的缺陷的描述</td></tr><tr><td>AUTHOR</td><td>该命令的作者介绍</td></tr></tbody></table></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;玩转Linux操作系统&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：本文中对Linux命令的讲解都是基于名为CentOS的Linux发行版本，我自己使用的是阿里云服务器，系统版本为CentOS Linux release 7.6.1810</summary>
      
    
    
    
    <category term="Python" scheme="http://wstcly.xyz/categories/Python/"/>
    
    
    <category term="Python学习" scheme="http://wstcly.xyz/tags/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
